(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BLPType;
(function (BLPType) {
    BLPType[BLPType["BLP0"] = 0] = "BLP0";
    BLPType[BLPType["BLP1"] = 1] = "BLP1";
    BLPType[BLPType["BLP2"] = 2] = "BLP2";
})(BLPType = exports.BLPType || (exports.BLPType = {}));
var BLPContent;
(function (BLPContent) {
    BLPContent[BLPContent["JPEG"] = 0] = "JPEG";
    BLPContent[BLPContent["Direct"] = 1] = "Direct";
})(BLPContent = exports.BLPContent || (exports.BLPContent = {}));
//# sourceMappingURL=blpimage.js.map
},{}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var decodeJPEG = require("../third_party/decoder");
var blpimage_1 = require("./blpimage");
function keyword(view, offset) {
    return String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));
}
function uint32(view, offset) {
    return view.getUint32(offset * 4, true);
}
function bitVal(data, bitCount, index) {
    // only 1, 4 or 8 bits
    var byte = data[Math.floor(index * bitCount / 8)], valsPerByte = 8 / bitCount;
    return (byte >> (valsPerByte - index % valsPerByte - 1)) & ((1 << bitCount) - 1);
}
// node.js have no native ImageData
function createImageData(width, height) {
    if (typeof ImageData !== 'undefined') {
        return new ImageData(width, height);
    }
    else {
        return {
            width: width,
            height: height,
            data: new Uint8ClampedArray(width * height * 4)
        };
    }
}
function decode(arrayBuffer) {
    var view = new DataView(arrayBuffer);
    var image = {
        type: blpimage_1.BLPType.BLP1,
        width: 0,
        height: 0,
        content: blpimage_1.BLPContent.JPEG,
        alphaBits: 0,
        mipmaps: [],
        data: arrayBuffer,
    };
    var type = keyword(view, 0);
    if (type === 'BLP0' || type === 'BLP2') {
        throw new Error('BLP0/BLP2 not supported');
    }
    if (type !== 'BLP1') {
        throw new Error('Not a blp image');
    }
    image.content = uint32(view, 1);
    if (image.content !== blpimage_1.BLPContent.JPEG && image.content !== blpimage_1.BLPContent.Direct) {
        throw new Error('Unknown BLP content');
    }
    image.alphaBits = uint32(view, 2);
    image.width = uint32(view, 3);
    image.height = uint32(view, 4);
    for (var i = 0; i < 16; ++i) {
        var mipmap = {
            offset: uint32(view, 7 + i),
            size: uint32(view, 7 + 16 + i)
        };
        if (mipmap.size > 0) {
            image.mipmaps.push(mipmap);
        }
        else {
            break;
        }
    }
    return image;
}
exports.decode = decode;
function getImageData(blp, mipmapLevel) {
    var view = new DataView(blp.data), uint8Data = new Uint8Array(blp.data), mipmap = blp.mipmaps[mipmapLevel];
    if (blp.content === blpimage_1.BLPContent.JPEG) {
        var headerSize = uint32(view, 39), data = new Uint8Array(headerSize + mipmap.size);
        data.set(uint8Data.subarray(40 * 4, 40 * 4 + headerSize));
        data.set(uint8Data.subarray(mipmap.offset, mipmap.offset + mipmap.size), headerSize);
        return decodeJPEG(data);
    }
    else {
        var palette = new Uint8Array(blp.data, 39 * 4, 256 * 4), width = blp.width / (1 << mipmapLevel), height = blp.height / (1 << mipmapLevel), size = width * height, alphaData = new Uint8Array(blp.data, mipmap.offset + size, Math.ceil(size * blp.alphaBits / 8)), imageData = createImageData(width, height), valPerAlphaBit = 255 / ((1 << blp.alphaBits) - 1);
        for (var i = 0; i < size; ++i) {
            var paletteIndex = view.getUint8(mipmap.offset + i) * 4;
            // BGRA order
            imageData.data[i * 4] = palette[paletteIndex + 2];
            imageData.data[i * 4 + 1] = palette[paletteIndex + 1];
            imageData.data[i * 4 + 2] = palette[paletteIndex];
            if (blp.alphaBits > 0) {
                imageData.data[i * 4 + 3] = bitVal(alphaData, blp.alphaBits, i) * valPerAlphaBit;
            }
            else {
                imageData.data[i * 4 + 3] = 255;
            }
        }
        return imageData;
    }
}
exports.getImageData = getImageData;
//# sourceMappingURL=decode.js.map
},{"../third_party/decoder":24,"./blpimage":1}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var parse_1 = require("../../mdl/parse");
var parse_2 = require("../../mdx/parse");
var gl_matrix_1 = require("gl-matrix");
var modelRenderer_1 = require("../../renderer/modelRenderer");
var util_1 = require("../../renderer/util");
var decode_1 = require("../../blp/decode");
require("../shim");
var model;
var modelRenderer;
var canvas;
var gl;
var pMatrix = gl_matrix_1.mat4.create();
var mvMatrix = gl_matrix_1.mat4.create();
var loadedTextures = 0;
var totalTextures = 0;
var cleanupNameRegexp = /.*?([^\\\/]+)\.\w+$/;
var cameraTheta = Math.PI / 4;
var cameraPhi = 0;
var cameraDistance = 500;
var cameraTargetZ = 50;
var cameraBasePos = gl_matrix_1.vec3.create();
var cameraPos = gl_matrix_1.vec3.create();
var cameraTarget = gl_matrix_1.vec3.create();
var cameraUp = gl_matrix_1.vec3.fromValues(0, 0, 1);
var cameraQuat = gl_matrix_1.quat.create();
var start;
function updateModel(timestamp) {
    if (!start) {
        start = timestamp;
    }
    var delta = timestamp - start;
    // delta /= 10;
    start = timestamp;
    modelRenderer.update(delta);
}
function initGL() {
    if (gl) {
        return;
    }
    try {
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
    }
    catch (err) {
        alert(err);
    }
}
var cameraPosProjected = gl_matrix_1.vec3.create();
var verticalQuat = gl_matrix_1.quat.create();
var fromCameraBaseVec = gl_matrix_1.vec3.fromValues(1, 0, 0);
function calcCameraQuat() {
    gl_matrix_1.vec3.set(cameraPosProjected, cameraPos[0], cameraPos[1], 0);
    gl_matrix_1.vec3.subtract(cameraPos, cameraPos, cameraTarget);
    gl_matrix_1.vec3.normalize(cameraPosProjected, cameraPosProjected);
    gl_matrix_1.vec3.normalize(cameraPos, cameraPos);
    gl_matrix_1.quat.rotationTo(cameraQuat, fromCameraBaseVec, cameraPosProjected);
    gl_matrix_1.quat.rotationTo(verticalQuat, cameraPosProjected, cameraPos);
    gl_matrix_1.quat.mul(cameraQuat, verticalQuat, cameraQuat);
}
function drawScene() {
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.depthMask(true);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl_matrix_1.mat4.perspective(pMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 10000.0);
    gl_matrix_1.vec3.set(cameraBasePos, Math.cos(cameraTheta) * Math.cos(cameraPhi) * cameraDistance, Math.cos(cameraTheta) * Math.sin(cameraPhi) * cameraDistance, Math.sin(cameraTheta) * cameraDistance);
    cameraTarget[2] = cameraTargetZ;
    // tslint:disable-next-line
    util_1.vec3RotateZ(cameraPos, cameraBasePos, window['angle'] || 0);
    gl_matrix_1.mat4.lookAt(mvMatrix, cameraPos, cameraTarget, cameraUp);
    calcCameraQuat();
    modelRenderer.setCamera(cameraPos, cameraQuat);
    modelRenderer.render(mvMatrix, pMatrix);
}
function tick(timestamp) {
    requestAnimationFrame(tick);
    updateModel(timestamp);
    drawScene();
}
function loadTexture(src, textureName, flags) {
    var img = new Image();
    img.onload = function () {
        modelRenderer.setTextureImage(textureName, img, flags);
        handleLoadedTexture();
    };
    img.src = src;
}
function handleLoadedTexture() {
    if (++loadedTextures === totalTextures) {
        requestAnimationFrame(tick);
    }
}
function parseModel(isBinary, xhr) {
    if (isBinary) {
        return parse_2.parse(xhr.response);
    }
    else {
        return parse_1.parse(xhr.responseText);
    }
}
function processModelLoading() {
    console.log(model);
    loadedTextures = totalTextures = 0;
    modelRenderer = new modelRenderer_1.ModelRenderer(model);
    initGL();
    modelRenderer.initGL(gl);
    setAnimationList();
}
function setSampleTextures() {
    for (var _i = 0, _a = model.Textures; _i < _a.length; _i++) {
        var texture = _a[_i];
        if (texture.Image) {
            ++totalTextures;
            loadTexture(texture.Image, texture.Image, texture.Flags);
        }
    }
}
function loadModel() {
    var xhr = new XMLHttpRequest();
    var file = 'preview/Footman.mdl';
    var isBinary = file.indexOf('.mdx') > -1;
    if (isBinary) {
        xhr.responseType = 'arraybuffer';
    }
    xhr.open('GET', file, true);
    xhr.onreadystatechange = function () {
        if (xhr.status === 200 && xhr.readyState === XMLHttpRequest.DONE) {
            model = parseModel(isBinary, xhr);
            processModelLoading();
            setSampleTextures();
        }
    };
    xhr.send();
}
function init() {
    canvas = document.getElementById('canvas');
    initControls();
    initCameraMove();
    initDragDrop();
    // loadModel();
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);
}
function initControls() {
    var inputColor = document.getElementById('color');
    inputColor.addEventListener('input', function () {
        var val = inputColor.value.slice(1);
        var arr = gl_matrix_1.vec3.fromValues(parseInt(val.slice(0, 2), 16) / 255, parseInt(val.slice(2, 4), 16) / 255, parseInt(val.slice(4, 6), 16) / 255);
        modelRenderer.setTeamColor(arr);
    });
    var select = document.getElementById('select');
    select.addEventListener('input', function () {
        modelRenderer.setSequence(parseInt(select.value, 10));
    });
    var inputZ = document.getElementById('targetZ');
    inputZ.addEventListener('input', function () {
        cameraTargetZ = parseInt(inputZ.value, 10);
    });
    var inputDistance = document.getElementById('distance');
    inputDistance.addEventListener('input', function () {
        cameraDistance = parseInt(inputDistance.value, 10);
    });
}
function initCameraMove() {
    var down = false;
    var downX, downY;
    function coords(event) {
        var list = (event.changedTouches && event.changedTouches.length ?
            event.changedTouches :
            event.touches) || [event];
        return [list[0].pageX, list[0].pageY];
    }
    function updateCameraDistance(distance) {
        cameraDistance = distance;
        if (cameraDistance > 1000) {
            cameraDistance = 1000;
        }
        if (cameraDistance < 100) {
            cameraDistance = 100;
        }
        document.getElementById('distance').value = String(cameraDistance);
    }
    function pointerDown(event) {
        if (event.target !== canvas) {
            return;
        }
        down = true;
        _a = coords(event), downX = _a[0], downY = _a[1];
        var _a;
    }
    function pointerMove(event) {
        if (!down) {
            return;
        }
        if (event.type === 'touchmove') {
            event.preventDefault();
        }
        if (event.changedTouches && event.changedTouches.length > 1 ||
            event.touches && event.touches.length > 1) {
            return;
        }
        var _a = coords(event), x = _a[0], y = _a[1];
        cameraPhi += -1 * (x - downX) * 0.01;
        cameraTheta += (y - downY) * 0.01;
        if (cameraTheta > Math.PI / 2 * 0.98) {
            cameraTheta = Math.PI / 2 * 0.98;
        }
        if (cameraTheta < 0) {
            cameraTheta = 0;
        }
        downX = x;
        downY = y;
    }
    function pointerUp() {
        down = false;
    }
    function wheel(event) {
        updateCameraDistance(cameraDistance * (1 - event.deltaY / 30));
    }
    var startCameraDistance;
    function gestureStart() {
        startCameraDistance = cameraDistance;
    }
    function gestureChange(event) {
        updateCameraDistance(startCameraDistance * (1 / event.scale));
    }
    document.addEventListener('mousedown', pointerDown);
    document.addEventListener('touchstart', pointerDown);
    document.addEventListener('mousemove', pointerMove);
    document.addEventListener('touchmove', pointerMove);
    document.addEventListener('mouseup', pointerUp);
    document.addEventListener('touchend', pointerUp);
    document.addEventListener('touchcancel', pointerUp);
    document.addEventListener('wheel', wheel);
    document.addEventListener('gesturestart', gestureStart);
    document.addEventListener('gesturechange', gestureChange);
}
function updateCanvasSize() {
    var width = canvas.parentElement.offsetWidth;
    var height = canvas.parentElement.offsetHeight;
    var dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
}
function encode(html) {
    return html.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function setAnimationList() {
    var list = model.Sequences.map(function (seq) { return seq.Name; });
    if (list.length === 0) {
        list = ['None'];
    }
    var select = document.getElementById('select');
    select.innerHTML = list.map(function (item, index) { return "<option value=\"" + index + "\">" + encode(item) + "</option>"; }).join('');
}
function setDragDropTextures() {
    var texturesContainer = document.querySelector('.drag-textures');
    texturesContainer.innerHTML = '';
    for (var _i = 0, _a = model.Textures; _i < _a.length; _i++) {
        var texture = _a[_i];
        if (texture.Image) {
            var row = document.createElement('div');
            row.className = 'drag';
            row.textContent = texture.Image;
            row.setAttribute('data-texture', texture.Image);
            row.setAttribute('data-texture-flags', String(texture.Flags));
            texturesContainer.appendChild(row);
        }
    }
}
function initDragDrop() {
    var container = document.querySelector('.container');
    var dropTarget;
    container.addEventListener('dragenter', function onDragEnter(event) {
        var target = event.target;
        if (dropTarget && dropTarget !== event.target && dropTarget.classList) {
            dropTarget.classList.remove('drag_hovered');
        }
        if (!target.classList) {
            target = target.parentElement;
        }
        dropTarget = target;
        if (target && target.classList && target.classList.contains('drag')) {
            target.classList.add('drag_hovered');
        }
        container.classList.add('container_drag');
        event.preventDefault();
    });
    container.addEventListener('dragleave', function onDragLeave(event) {
        if (event.target === dropTarget) {
            container.classList.remove('container_drag');
            if (dropTarget && dropTarget.classList) {
                dropTarget.classList.remove('drag_hovered');
            }
        }
    });
    container.addEventListener('dragover', function onDragLeave(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
    });
    var dropModel = function (file, textures) {
        var reader = new FileReader();
        var isMDX = file.name.indexOf('.mdx') > -1;
        reader.onload = function () {
            try {
                if (isMDX) {
                    model = parse_2.parse(reader.result);
                }
                else {
                    model = parse_1.parse(reader.result);
                }
            }
            catch (err) {
                console.error(err);
                // showError(err);
                return;
            }
            processModelLoading();
            setTextures(textures);
            setDragDropTextures();
        };
        if (isMDX) {
            reader.readAsArrayBuffer(file);
        }
        else {
            reader.readAsText(file);
        }
    };
    var dropTexture = function (file, textureName, textureFlags) {
        var reader = new FileReader();
        var isBLP = file.name.indexOf('.blp') > -1;
        reader.onload = function () {
            if (isBLP) {
                var blp_1 = decode_1.decode(reader.result);
                console.log(file.name, blp_1);
                modelRenderer.setTextureImageData(textureName, blp_1.mipmaps.map(function (mipmap, i) { return decode_1.getImageData(blp_1, i); }), textureFlags);
            }
            else {
                var img_1 = new Image();
                img_1.onload = function () {
                    console.log(file.name, img_1);
                    modelRenderer.setTextureImage(textureName, img_1, textureFlags);
                };
                img_1.src = reader.result;
            }
            handleLoadedTexture();
        };
        if (isBLP) {
            reader.readAsArrayBuffer(file);
        }
        else {
            reader.readAsDataURL(file);
        }
    };
    container.addEventListener('drop', function onDrop(event) {
        event.preventDefault();
        container.classList.remove('container_drag');
        container.classList.add('container_custom');
        if (!dropTarget) {
            return;
        }
        dropTarget.classList.remove('drag_hovered');
        var files = event.dataTransfer.files;
        if (!files || !files.length) {
            return;
        }
        if (dropTarget.getAttribute('data-texture')) {
            dropTexture(files[0], dropTarget.getAttribute('data-texture'), Number(dropTarget.getAttribute('data-texture-flags')));
        }
        else {
            var modelFile = void 0;
            for (var i = 0; i < files.length; ++i) {
                var file = files[i];
                if (file.name.indexOf('.mdl') > -1 || file.name.indexOf('.mdx') > -1) {
                    modelFile = file;
                    break;
                }
            }
            if (modelFile) {
                var textures = {};
                for (var i = 0; i < files.length; ++i) {
                    var file = files[i], name_1 = file.name.replace(cleanupNameRegexp, '$1');
                    if (file.name.indexOf('.mdl') > -1 || file.name.indexOf('.mdx') > -1) {
                        continue;
                    }
                    textures[name_1] = file;
                }
                dropModel(modelFile, textures);
            }
        }
    });
    function setTextures(textures) {
        for (var _i = 0, _a = model.Textures; _i < _a.length; _i++) {
            var texture = _a[_i];
            if (texture.Image) {
                ++totalTextures;
                var cleanupName = texture.Image.replace(cleanupNameRegexp, '$1');
                if (cleanupName in textures) {
                    dropTexture(textures[cleanupName], texture.Image, texture.Flags);
                }
                else {
                    loadTexture('preview/empty.png', texture.Image, 0);
                }
            }
        }
    }
}
document.addEventListener('DOMContentLoaded', init);
//# sourceMappingURL=preview.js.map
},{"../../blp/decode":2,"../../mdl/parse":5,"../../mdx/parse":6,"../../renderer/modelRenderer":20,"../../renderer/util":23,"../shim":4,"gl-matrix":8}],4:[function(require,module,exports){
if (!Float32Array.prototype.reverse) {
    Float32Array.prototype.reverse = Array.prototype.reverse;
}

},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = require("../model");
var State = (function () {
    function State(str) {
        this.str = str;
        this.pos = 0;
    }
    State.prototype.char = function () {
        return this.str[this.pos];
    };
    return State;
}());
function throwError(state, str) {
    if (str === void 0) { str = ''; }
    throw new Error("SyntaxError, near " + state.pos + (str ? ', ' + str : ''));
}
function parseComment(state) {
    if (state.char() === '/' && state.str[state.pos + 1] === '/') {
        state.pos += 2;
        while (state.pos < state.str.length && state.str[++state.pos] !== '\n')
            ;
        ++state.pos;
        return true;
    }
    return false;
}
var spaceRE = /\s/i;
function parseSpace(state) {
    while (spaceRE.test(state.char())) {
        ++state.pos;
    }
}
var keywordFirstCharRE = /[a-z]/i;
var keywordOtherCharRE = /[a-z0-9]/i;
function parseKeyword(state) {
    if (!keywordFirstCharRE.test(state.char())) {
        return null;
    }
    var keyword = state.char();
    ++state.pos;
    while (keywordOtherCharRE.test(state.char())) {
        keyword += state.str[state.pos++];
    }
    parseSpace(state);
    return keyword;
}
function parseSymbol(state, symbol) {
    if (state.char() === symbol) {
        ++state.pos;
        parseSpace(state);
    }
}
function strictParseSymbol(state, symbol) {
    if (state.char() !== symbol) {
        throwError(state, "extected " + symbol);
    }
    ++state.pos;
    parseSpace(state);
}
function parseString(state) {
    if (state.char() === '"') {
        var start = ++state.pos; // "
        while (state.char() !== '"') {
            ++state.pos;
        }
        ++state.pos; // "
        var res = state.str.substring(start, state.pos - 1);
        parseSpace(state);
        return res;
    }
    return null;
}
var numberFirstCharRE = /[-0-9]/;
var numberOtherCharRE = /[-+.0-9e]/i;
function parseNumber(state) {
    if (numberFirstCharRE.test(state.char())) {
        var start = state.pos;
        ++state.pos;
        while (numberOtherCharRE.test(state.char())) {
            ++state.pos;
        }
        var res = parseFloat(state.str.substring(start, state.pos));
        parseSpace(state);
        return res;
    }
    return null;
}
function parseArray(state, arr, pos) {
    if (state.char() !== '{') {
        return null;
    }
    if (!arr) {
        arr = [];
        pos = 0;
    }
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var num = parseNumber(state);
        if (num === null) {
            throwError(state, 'expected number');
        }
        arr[pos++] = num;
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    return arr;
}
function parseArrayOrSingleItem(state, arr) {
    if (state.char() !== '{') {
        arr[0] = parseNumber(state);
        return arr;
    }
    var pos = 0;
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var num = parseNumber(state);
        if (num === null) {
            throwError(state, 'expected number');
        }
        arr[pos++] = num;
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    return arr;
}
function parseObject(state) {
    var prefix = null;
    var obj = {};
    if (state.char() !== '{') {
        prefix = parseString(state);
        if (prefix === null) {
            prefix = parseNumber(state);
        }
        if (prefix === null) {
            throwError(state, 'expected string or number');
        }
    }
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'Interval') {
            var array = new Uint32Array(2);
            obj[keyword] = parseArray(state, array, 0);
        }
        else if (keyword === 'MinimumExtent' || keyword === 'MaximumExtent') {
            var array = new Float32Array(3);
            obj[keyword] = parseArray(state, array, 0);
        }
        else {
            obj[keyword] = parseArray(state) || parseString(state);
            if (obj[keyword] === null) {
                obj[keyword] = parseNumber(state);
            }
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    return [prefix, obj];
}
function parseVersion(state, model) {
    var _a = parseObject(state), unused = _a[0], obj = _a[1];
    if (obj.FormatVersion) {
        model.Version = obj.FormatVersion;
    }
}
function parseModelInfo(state, model) {
    var _a = parseObject(state), name = _a[0], obj = _a[1];
    model.Info = obj;
    model.Info.Name = name;
}
function parseSequences(state, model) {
    parseNumber(state); // count, not used
    strictParseSymbol(state, '{');
    var res = [];
    while (state.char() !== '}') {
        parseKeyword(state); // Anim
        var _a = parseObject(state), name_1 = _a[0], obj = _a[1];
        obj.Name = name_1;
        obj.NonLooping = 'NonLooping' in obj;
        res.push(obj);
    }
    strictParseSymbol(state, '}');
    model.Sequences = res;
}
function parseTextures(state, model) {
    var res = [];
    parseNumber(state); // count, not used
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        parseKeyword(state); // Bitmap
        var _a = parseObject(state), unused = _a[0], obj = _a[1];
        obj.Flags = 0;
        if ('WrapWidth' in obj) {
            obj.Flags += model_1.TextureFlags.WrapWidth;
            delete obj.WrapWidth;
        }
        if ('WrapHeight' in obj) {
            obj.Flags += model_1.TextureFlags.WrapHeight;
            delete obj.WrapHeight;
        }
        res.push(obj);
    }
    strictParseSymbol(state, '}');
    model.Textures = res;
}
var AnimVectorType;
(function (AnimVectorType) {
    AnimVectorType[AnimVectorType["INT1"] = 0] = "INT1";
    AnimVectorType[AnimVectorType["FLOAT1"] = 1] = "FLOAT1";
    AnimVectorType[AnimVectorType["FLOAT3"] = 2] = "FLOAT3";
    AnimVectorType[AnimVectorType["FLOAT4"] = 3] = "FLOAT4";
})(AnimVectorType || (AnimVectorType = {}));
var animVectorSize = (_a = {},
    _a[AnimVectorType.INT1] = 1,
    _a[AnimVectorType.FLOAT1] = 1,
    _a[AnimVectorType.FLOAT3] = 3,
    _a[AnimVectorType.FLOAT4] = 4,
    _a);
function parseAnimKeyframe(state, frame, type, lineType) {
    var res = {
        Frame: frame,
        Vector: null
    };
    var Vector = type === AnimVectorType.INT1 ? Int32Array : Float32Array;
    var itemCount = animVectorSize[type];
    res.Vector = parseArrayOrSingleItem(state, new Vector(itemCount));
    strictParseSymbol(state, ',');
    if (lineType === model_1.LineType.Hermite || lineType === model_1.LineType.Bezier) {
        parseKeyword(state); // InTan
        res.InTan = parseArrayOrSingleItem(state, new Vector(itemCount));
        strictParseSymbol(state, ',');
        parseKeyword(state); // OutTan
        res.OutTan = parseArrayOrSingleItem(state, new Vector(itemCount));
        strictParseSymbol(state, ',');
    }
    return res;
}
function parseAnimVector(state, type) {
    var animVector = {
        LineType: model_1.LineType.DontInterp,
        GlobalSeqId: null,
        Keys: []
    };
    parseNumber(state); // count, not used
    strictParseSymbol(state, '{');
    var lineType = parseKeyword(state);
    if (lineType === 'DontInterp' || lineType === 'Linear' || lineType === 'Hermite' || lineType === 'Bezier') {
        animVector.LineType = model_1.LineType[lineType];
    }
    strictParseSymbol(state, ',');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (keyword === 'GlobalSeqId') {
            animVector[keyword] = parseNumber(state);
            strictParseSymbol(state, ',');
        }
        else {
            var frame = parseNumber(state);
            if (frame === null) {
                throwError(state, 'expected frame number or GlobalSeqId');
            }
            strictParseSymbol(state, ':');
            animVector.Keys.push(parseAnimKeyframe(state, frame, type, animVector.LineType));
        }
    }
    strictParseSymbol(state, '}');
    return animVector;
}
function parseLayer(state) {
    var res = {
        Alpha: null,
        TVertexAnimId: null,
        Shading: 0,
        CoordId: 0
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        var isStatic = false;
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'static') {
            isStatic = true;
            keyword = parseKeyword(state);
        }
        if (!isStatic && keyword === 'TextureID') {
            res[keyword] = parseAnimVector(state, AnimVectorType.INT1);
        }
        else if (!isStatic && keyword === 'Alpha') {
            res[keyword] = parseAnimVector(state, AnimVectorType.FLOAT1);
        }
        else if (keyword === 'Unshaded' || keyword === 'SphereEnvMap' || keyword === 'TwoSided' ||
            keyword === 'Unfogged' || keyword === 'NoDepthTest' || keyword === 'NoDepthSet') {
            res.Shading |= model_1.LayerShading[keyword];
        }
        else if (keyword === 'FilterMode') {
            var val = parseKeyword(state);
            if (val === 'None' || val === 'Transparent' || val === 'Blend' || val === 'Additive' ||
                val === 'AddAlpha' || val === 'Modulate' || val === 'Modulate2x') {
                res.FilterMode = model_1.FilterMode[val];
            }
        }
        else if (keyword === 'TVertexAnimId') {
            res.TVertexAnimId = parseNumber(state);
        }
        else {
            var val = parseNumber(state);
            if (val === null) {
                val = parseKeyword(state);
            }
            res[keyword] = val;
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    return res;
}
function parseMaterials(state, model) {
    var res = [];
    parseNumber(state); // count, not used
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var obj = {
            RenderMode: 0,
            Layers: []
        };
        parseKeyword(state); // Material
        strictParseSymbol(state, '{');
        while (state.char() !== '}') {
            var keyword = parseKeyword(state);
            if (!keyword) {
                throwError(state);
            }
            if (keyword === 'Layer') {
                obj.Layers.push(parseLayer(state));
            }
            else if (keyword === 'PriorityPlane') {
                obj[keyword] = parseNumber(state);
            }
            else if (keyword === 'ConstantColor' || keyword === 'SortPrimsFarZ' || keyword === 'FullResolution') {
                obj.RenderMode |= model_1.MaterialRenderMode[keyword];
            }
            else {
                throw new Error('Unknown material property ' + keyword);
            }
            parseSymbol(state, ',');
        }
        strictParseSymbol(state, '}');
        res.push(obj);
    }
    strictParseSymbol(state, '}');
    model.Materials = res;
}
function parseGeoset(state, model) {
    var res = {
        Vertices: null,
        Normals: null,
        TVertices: [],
        VertexGroup: null,
        Faces: null,
        Groups: null,
        TotalGroupsCount: null,
        MinimumExtent: null,
        MaximumExtent: null,
        BoundsRadius: null,
        Anims: [],
        MaterialID: null,
        SelectionGroup: null,
        Unselectable: false
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'Vertices' || keyword === 'Normals' || keyword === 'TVertices') {
            var countPerObj = 3;
            if (keyword === 'TVertices') {
                countPerObj = 2;
            }
            var count = parseNumber(state);
            var arr = new Float32Array(count * countPerObj);
            strictParseSymbol(state, '{');
            for (var index = 0; index < count; ++index) {
                parseArray(state, arr, index * countPerObj);
                strictParseSymbol(state, ',');
            }
            strictParseSymbol(state, '}');
            if (keyword === 'TVertices') {
                res.TVertices.push(arr);
            }
            else {
                res[keyword] = arr;
            }
        }
        else if (keyword === 'VertexGroup') {
            res[keyword] = new Uint8Array(res.Vertices.length / 3);
            parseArray(state, res[keyword], 0);
        }
        else if (keyword === 'Faces') {
            parseNumber(state); // group count, always 1?
            var indexCount = parseNumber(state);
            res.Faces = new Uint16Array(indexCount);
            strictParseSymbol(state, '{');
            parseKeyword(state); // Triangles
            strictParseSymbol(state, '{');
            parseArray(state, res.Faces, 0);
            parseSymbol(state, ',');
            strictParseSymbol(state, '}');
            strictParseSymbol(state, '}');
        }
        else if (keyword === 'Groups') {
            var groups = [];
            parseNumber(state); // groups count, unused
            res.TotalGroupsCount = parseNumber(state); // summed in subarrays
            strictParseSymbol(state, '{');
            while (state.char() !== '}') {
                parseKeyword(state); // Matrices
                groups.push(parseArray(state));
                parseSymbol(state, ',');
            }
            strictParseSymbol(state, '}');
            res.Groups = groups;
        }
        else if (keyword === 'MinimumExtent' || keyword === 'MaximumExtent') {
            var arr = new Float32Array(3);
            res[keyword] = parseArray(state, arr, 0);
            strictParseSymbol(state, ',');
        }
        else if (keyword === 'BoundsRadius' || keyword === 'MaterialID' || keyword === 'SelectionGroup') {
            res[keyword] = parseNumber(state);
            strictParseSymbol(state, ',');
        }
        else if (keyword === 'Anim') {
            var _a = parseObject(state), unused = _a[0], obj = _a[1];
            if (obj.Alpha === undefined) {
                obj.Alpha = 1;
            }
            res.Anims.push(obj);
        }
        else if (keyword === 'Unselectable') {
            res.Unselectable = true;
            strictParseSymbol(state, ',');
        }
    }
    strictParseSymbol(state, '}');
    model.Geosets.push(res);
}
function parseGeosetAnim(state, model) {
    var res = {
        GeosetId: -1,
        Alpha: 1,
        Color: null,
        Flags: 0
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        var isStatic = false;
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'static') {
            isStatic = true;
            keyword = parseKeyword(state);
        }
        if (keyword === 'Alpha') {
            if (isStatic) {
                res.Alpha = parseNumber(state);
            }
            else {
                res.Alpha = parseAnimVector(state, AnimVectorType.FLOAT1);
            }
        }
        else if (keyword === 'Color') {
            if (isStatic) {
                var array = new Float32Array(3);
                res.Color = parseArray(state, array, 0);
                res.Color.reverse();
            }
            else {
                res.Color = parseAnimVector(state, AnimVectorType.FLOAT3);
                for (var _i = 0, _a = res.Color.Keys; _i < _a.length; _i++) {
                    var key = _a[_i];
                    key.Vector.reverse();
                    if (key.InTan) {
                        key.InTan.reverse();
                        key.OutTan.reverse();
                    }
                }
            }
        }
        else if (keyword === 'DropShadow') {
            res.Flags |= model_1.GeosetAnimFlags[keyword];
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.GeosetAnims.push(res);
}
function parseNode(state, type, model) {
    var name = parseString(state);
    var node = {
        Name: name,
        ObjectId: null,
        Parent: null,
        PivotPoint: null,
        Flags: model_1.NodeType[type]
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Visibility') {
            var vectorType = AnimVectorType.FLOAT3;
            if (keyword === 'Rotation') {
                vectorType = AnimVectorType.FLOAT4;
            }
            else if (keyword === 'Visibility') {
                vectorType = AnimVectorType.FLOAT1;
            }
            node[keyword] = parseAnimVector(state, vectorType);
        }
        else if (keyword === 'BillboardedLockZ' || keyword === 'BillboardedLockY' || keyword === 'BillboardedLockX' ||
            keyword === 'Billboarded' || keyword === 'CameraAnchored') {
            node.Flags |= model_1.NodeFlags[keyword];
        }
        else if (keyword === 'DontInherit') {
            strictParseSymbol(state, '{');
            var val = parseKeyword(state);
            if (val === 'Translation') {
                node.Flags |= model_1.NodeFlags.DontInheritTranslation;
            }
            else if (val === 'Rotation') {
                node.Flags |= model_1.NodeFlags.DontInheritRotation;
            }
            else if (val === 'Scaling') {
                node.Flags |= model_1.NodeFlags.DontInheritScaling;
            }
            strictParseSymbol(state, '}');
        }
        else if (keyword === 'Path') {
            node[keyword] = parseString(state);
        }
        else {
            var val = parseKeyword(state) || parseNumber(state);
            if (keyword === 'GeosetId' && val === 'Multiple' ||
                keyword === 'GeosetAnimId' && val === 'None') {
                val = null;
            }
            node[keyword] = val;
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.Nodes[node.ObjectId] = node;
    return node;
}
function parseBone(state, model) {
    var node = parseNode(state, 'Bone', model);
    model.Bones.push(node);
}
function parseHelper(state, model) {
    var node = parseNode(state, 'Helper', model);
    model.Helpers.push(node);
}
function parseAttachment(state, model) {
    var node = parseNode(state, 'Attachment', model);
    model.Attachments.push(node);
}
function parsePivotPoints(state, model) {
    var count = parseNumber(state);
    var res = [];
    strictParseSymbol(state, '{');
    for (var i = 0; i < count; ++i) {
        res.push(parseArray(state, new Float32Array(3), 0));
        strictParseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.PivotPoints = res;
}
function parseEventObject(state, model) {
    var name = parseString(state);
    var res = {
        Name: name,
        ObjectId: null,
        Parent: null,
        PivotPoint: null,
        EventTrack: null,
        Flags: model_1.NodeType.EventObject
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'EventTrack') {
            var count = parseNumber(state); // EventTrack count
            res.EventTrack = parseArray(state, new Uint32Array(count), 0);
        }
        else if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling') {
            var type = keyword === 'Rotation' ? AnimVectorType.FLOAT4 : AnimVectorType.FLOAT3;
            res[keyword] = parseAnimVector(state, type);
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.EventObjects.push(res);
    model.Nodes.push(res);
}
function parseCollisionShape(state, model) {
    var name = parseString(state);
    var res = {
        Name: name,
        ObjectId: null,
        Parent: null,
        PivotPoint: null,
        Shape: model_1.CollisionShapeType.Box,
        Vertices: null,
        Flags: model_1.NodeType.CollisionShape
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'Sphere') {
            res.Shape = model_1.CollisionShapeType.Sphere;
        }
        else if (keyword === 'Box') {
            res.Shape = model_1.CollisionShapeType.Box;
        }
        else if (keyword === 'Vertices') {
            var count = parseNumber(state);
            var vertices = new Float32Array(count * 3);
            strictParseSymbol(state, '{');
            for (var i = 0; i < count; ++i) {
                parseArray(state, vertices, i * 3);
                strictParseSymbol(state, ',');
            }
            strictParseSymbol(state, '}');
            res.Vertices = vertices;
        }
        else if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling') {
            var type = keyword === 'Rotation' ? AnimVectorType.FLOAT4 : AnimVectorType.FLOAT3;
            res[keyword] = parseAnimVector(state, type);
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.CollisionShapes.push(res);
    model.Nodes.push(res);
}
function parseGlobalSequences(state, model) {
    var res = [];
    var count = parseNumber(state);
    strictParseSymbol(state, '{');
    for (var i = 0; i < count; ++i) {
        var keyword = parseKeyword(state);
        if (keyword === 'Duration') {
            res.push(parseNumber(state));
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.GlobalSequences = res;
}
function parseUnknownBlock(state) {
    var opened;
    while (state.char() !== undefined && state.char() !== '{') {
        ++state.pos;
    }
    opened = 1;
    ++state.pos;
    while (state.char() !== undefined && opened > 0) {
        if (state.char() === '{') {
            ++opened;
        }
        else if (state.char() === '}') {
            --opened;
        }
        ++state.pos;
    }
    parseSpace(state);
}
function parseParticleEmitter(state, model) {
    var res = {
        ObjectId: null,
        Parent: null,
        Name: null,
        Flags: 0
    };
    res.Name = parseString(state);
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        var isStatic = false;
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'static') {
            isStatic = true;
            keyword = parseKeyword(state);
        }
        if (keyword === 'ObjectId' || keyword === 'Parent') {
            res[keyword] = parseNumber(state);
        }
        else if (keyword === 'EmitterUsesMDL' || keyword === 'EmitterUsesTGA') {
            res.Flags |= model_1.ParticleEmitterFlags[keyword];
        }
        else if (!isStatic && (keyword === 'Visibility' || keyword === 'Translation' || keyword === 'Rotation' ||
            keyword === 'Scaling' || keyword === 'EmissionRate' || keyword === 'Gravity' || keyword === 'Longitude' ||
            keyword === 'Latitude')) {
            var type = AnimVectorType.FLOAT3;
            if (keyword === 'Visibility' || keyword === 'EmissionRate' || keyword === 'Gravity' ||
                keyword === 'Longitude' || keyword === 'Latitude') {
                type = AnimVectorType.FLOAT1;
            }
            else if (keyword === 'Rotation') {
                type = AnimVectorType.FLOAT4;
            }
            res[keyword] = parseAnimVector(state, type);
        }
        else if (keyword === 'Particle') {
            strictParseSymbol(state, '{');
            while (state.char() !== '}') {
                var keyword2 = parseKeyword(state);
                var isStatic2 = false;
                if (keyword2 === 'static') {
                    isStatic2 = true;
                    keyword2 = parseKeyword(state);
                }
                if (!isStatic2 && (keyword2 === 'LifeSpan' || keyword2 === 'InitVelocity')) {
                    res[keyword2] = parseAnimVector(state, AnimVectorType.FLOAT1);
                }
                else if (keyword2 === 'LifeSpan' || keyword2 === 'InitVelocity') {
                    res[keyword2] = parseNumber(state);
                }
                else if (keyword2 === 'Path') {
                    res.Path = parseString(state);
                }
                parseSymbol(state, ',');
            }
            strictParseSymbol(state, '}');
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.ParticleEmitters.push(res);
}
function parseParticleEmitter2(state, model) {
    var name = parseString(state);
    var res = {
        Name: name,
        ObjectId: null,
        Parent: null,
        PivotPoint: null,
        Flags: model_1.NodeType.ParticleEmitter,
        FrameFlags: 0
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        var isStatic = false;
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'static') {
            isStatic = true;
            keyword = parseKeyword(state);
        }
        if (!isStatic && (keyword === 'Speed' || keyword === 'Latitude' || keyword === 'Visibility' ||
            keyword === 'EmissionRate' || keyword === 'Width' || keyword === 'Length' || keyword === 'Translation' ||
            keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Gravity' || keyword === 'Variation')) {
            var type = AnimVectorType.FLOAT3;
            switch (keyword) {
                case 'Rotation':
                    type = AnimVectorType.FLOAT4;
                    break;
                case 'Speed':
                case 'Latitude':
                case 'Visibility':
                case 'EmissionRate':
                case 'Width':
                case 'Length':
                case 'Gravity':
                case 'Variation':
                    type = AnimVectorType.FLOAT1;
                    break;
            }
            res[keyword] = parseAnimVector(state, type);
        }
        else if (keyword === 'Variation' || keyword === 'Gravity') {
            res[keyword] = parseNumber(state);
        }
        else if (keyword === 'SortPrimsFarZ' || keyword === 'Unshaded' || keyword === 'LineEmitter' ||
            keyword === 'Unfogged' || keyword === 'ModelSpace' || keyword === 'XYQuad') {
            res.Flags |= model_1.ParticleEmitter2Flags[keyword];
        }
        else if (keyword === 'Both') {
            res.FrameFlags |= model_1.ParticleEmitter2FramesFlags.Head | model_1.ParticleEmitter2FramesFlags.Tail;
        }
        else if (keyword === 'Head' || keyword === 'Tail') {
            res.FrameFlags |= model_1.ParticleEmitter2FramesFlags[keyword];
        }
        else if (keyword === 'Squirt') {
            res[keyword] = true;
        }
        else if (keyword === 'DontInherit') {
            strictParseSymbol(state, '{');
            var val = parseKeyword(state);
            if (val === 'Translation') {
                res.Flags |= model_1.NodeFlags.DontInheritTranslation;
            }
            else if (val === 'Rotation') {
                res.Flags |= model_1.NodeFlags.DontInheritRotation;
            }
            else if (val === 'Scaling') {
                res.Flags |= model_1.NodeFlags.DontInheritScaling;
            }
            strictParseSymbol(state, '}');
        }
        else if (keyword === 'SegmentColor') {
            var colors = [];
            strictParseSymbol(state, '{');
            while (state.char() !== '}') {
                parseKeyword(state); // Color
                var colorArr = new Float32Array(3);
                parseArray(state, colorArr, 0);
                // bgr order, inverse from mdx
                var temp = colorArr[0];
                colorArr[0] = colorArr[2];
                colorArr[2] = temp;
                colors.push(colorArr);
                parseSymbol(state, ',');
            }
            strictParseSymbol(state, '}');
            res.SegmentColor = colors;
        }
        else if (keyword === 'Alpha') {
            res.Alpha = new Uint8Array(3);
            parseArray(state, res.Alpha, 0);
        }
        else if (keyword === 'ParticleScaling') {
            res[keyword] = new Float32Array(3);
            parseArray(state, res[keyword], 0);
        }
        else if (keyword === 'LifeSpanUVAnim' || keyword === 'DecayUVAnim' || keyword === 'TailUVAnim' ||
            keyword === 'TailDecayUVAnim') {
            res[keyword] = new Uint32Array(3);
            parseArray(state, res[keyword], 0);
        }
        else if (keyword === 'Transparent' || keyword === 'Blend' || keyword === 'Additive' ||
            keyword === 'AlphaKey' || keyword === 'Modulate' || keyword === 'Modulate2x') {
            res.FilterMode = model_1.ParticleEmitter2FilterMode[keyword];
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.ParticleEmitters2.push(res);
    model.Nodes.push(res);
}
function parseCamera(state, model) {
    var res = {
        Name: null,
        Position: null,
        FieldOfView: 0,
        NearClip: 0,
        FarClip: 0,
        TargetPosition: null
    };
    res.Name = parseString(state);
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'Position') {
            res.Position = new Float32Array(3);
            parseArray(state, res.Position, 0);
        }
        else if (keyword === 'FieldOfView' || keyword === 'NearClip' || keyword === 'FarClip') {
            res[keyword] = parseNumber(state);
        }
        else if (keyword === 'Target') {
            strictParseSymbol(state, '{');
            while (state.char() !== '}') {
                var keyword2 = parseKeyword(state);
                if (keyword2 === 'Position') {
                    res.TargetPosition = new Float32Array(3);
                    parseArray(state, res.TargetPosition, 0);
                }
                else if (keyword2 === 'Translation') {
                    res.TargetTranslation = parseAnimVector(state, AnimVectorType.FLOAT3);
                }
                parseSymbol(state, ',');
            }
            strictParseSymbol(state, '}');
        }
        else if (keyword === 'Translation' || keyword === 'Rotation') {
            res[keyword] = parseAnimVector(state, keyword === 'Rotation' ?
                AnimVectorType.FLOAT1 :
                AnimVectorType.FLOAT3);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.Cameras.push(res);
}
function parseLight(state, model) {
    var name = parseString(state);
    var res = {
        Name: name,
        ObjectId: null,
        Parent: null,
        PivotPoint: null,
        Flags: model_1.NodeType.Light,
        LightType: 0
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        var isStatic = false;
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'static') {
            isStatic = true;
            keyword = parseKeyword(state);
        }
        if (!isStatic && (keyword === 'Visibility' || keyword === 'Color' || keyword === 'Intensity' ||
            keyword === 'AmbIntensity' || keyword === 'AmbColor' || keyword === 'Translation' ||
            keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'AttenuationStart' ||
            keyword === 'AttenuationEnd')) {
            var type = AnimVectorType.FLOAT3;
            switch (keyword) {
                case 'Rotation':
                    type = AnimVectorType.FLOAT4;
                    break;
                case 'Visibility':
                case 'Intensity':
                case 'AmbIntensity':
                case 'AttenuationStart':
                case 'AttenuationEnd':
                    type = AnimVectorType.FLOAT1;
                    break;
            }
            res[keyword] = parseAnimVector(state, type);
            if (keyword === 'Color' || keyword === 'AmbColor') {
                for (var _i = 0, _a = res[keyword].Keys; _i < _a.length; _i++) {
                    var key = _a[_i];
                    key.Vector.reverse();
                    if (key.InTan) {
                        key.InTan.reverse();
                        key.OutTan.reverse();
                    }
                }
            }
        }
        else if (keyword === 'Omnidirectional' || keyword === 'Directional' || keyword === 'Ambient') {
            res.LightType = model_1.LightType[keyword];
        }
        else if (keyword === 'Color' || keyword === 'AmbColor') {
            var color = new Float32Array(3);
            parseArray(state, color, 0);
            // bgr order, inverse from mdx
            var temp = color[0];
            color[0] = color[2];
            color[2] = temp;
            res[keyword] = color;
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.Lights.push(res);
    model.Nodes.push(res);
}
function parseTextureAnims(state, model) {
    var res = [];
    parseNumber(state); // count, not used
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var obj = {};
        parseKeyword(state); // TVertexAnim
        strictParseSymbol(state, '{');
        while (state.char() !== '}') {
            var keyword = parseKeyword(state);
            if (!keyword) {
                throwError(state);
            }
            if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling') {
                var type = keyword === 'Rotation' ? AnimVectorType.FLOAT4 : AnimVectorType.FLOAT3;
                obj[keyword] = parseAnimVector(state, type);
            }
            else {
                throw new Error('Unknown texture anim property ' + keyword);
            }
            parseSymbol(state, ',');
        }
        strictParseSymbol(state, '}');
        res.push(obj);
    }
    strictParseSymbol(state, '}');
    model.TextureAnims = res;
}
function parseRibbonEmitter(state, model) {
    var name = parseString(state);
    var res = {
        Name: name,
        ObjectId: null,
        Parent: null,
        PivotPoint: null,
        Flags: model_1.NodeType.RibbonEmitter,
        HeightAbove: null,
        HeightBelow: null,
        Alpha: null,
        Color: null,
        LifeSpan: null,
        TextureSlot: null,
        EmissionRate: null,
        Rows: null,
        Columns: null,
        MaterialID: null,
        Gravity: null,
        Visibility: null
    };
    strictParseSymbol(state, '{');
    while (state.char() !== '}') {
        var keyword = parseKeyword(state);
        var isStatic = false;
        if (!keyword) {
            throwError(state);
        }
        if (keyword === 'static') {
            isStatic = true;
            keyword = parseKeyword(state);
        }
        if (!isStatic && (keyword === 'Visibility' || keyword === 'HeightAbove' || keyword === 'HeightBelow' ||
            keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Alpha' ||
            keyword === 'TextureSlot')) {
            var type = AnimVectorType.FLOAT3;
            switch (keyword) {
                case 'Rotation':
                    type = AnimVectorType.FLOAT4;
                    break;
                case 'Visibility':
                case 'HeightAbove':
                case 'HeightBelow':
                case 'Alpha':
                    type = AnimVectorType.FLOAT1;
                    break;
                case 'TextureSlot':
                    type = AnimVectorType.INT1;
                    break;
            }
            res[keyword] = parseAnimVector(state, type);
        }
        else if (keyword === 'Color') {
            var color = new Float32Array(3);
            parseArray(state, color, 0);
            // bgr order, inverse from mdx
            var temp = color[0];
            color[0] = color[2];
            color[2] = temp;
            res[keyword] = color;
        }
        else {
            res[keyword] = parseNumber(state);
        }
        parseSymbol(state, ',');
    }
    strictParseSymbol(state, '}');
    model.RibbonEmitters.push(res);
    model.Nodes.push(res);
}
var parsers = {
    Version: parseVersion,
    Model: parseModelInfo,
    Sequences: parseSequences,
    Textures: parseTextures,
    Materials: parseMaterials,
    Geoset: parseGeoset,
    GeosetAnim: parseGeosetAnim,
    Bone: parseBone,
    Helper: parseHelper,
    Attachment: parseAttachment,
    PivotPoints: parsePivotPoints,
    EventObject: parseEventObject,
    CollisionShape: parseCollisionShape,
    GlobalSequences: parseGlobalSequences,
    ParticleEmitter: parseParticleEmitter,
    ParticleEmitter2: parseParticleEmitter2,
    Camera: parseCamera,
    Light: parseLight,
    TextureAnims: parseTextureAnims,
    RibbonEmitter: parseRibbonEmitter
};
function parse(str) {
    var state = new State(str);
    var model = {
        // default
        Version: 800,
        Info: {
            Name: '',
            MinimumExtent: null,
            MaximumExtent: null,
            BoundsRadius: 0,
            BlendTime: 150
        },
        Sequences: [],
        GlobalSequences: [],
        Textures: [],
        Materials: [],
        TextureAnims: [],
        Geosets: [],
        GeosetAnims: [],
        Bones: [],
        Helpers: [],
        Attachments: [],
        EventObjects: [],
        ParticleEmitters: [],
        ParticleEmitters2: [],
        Cameras: [],
        Lights: [],
        RibbonEmitters: [],
        CollisionShapes: [],
        PivotPoints: [],
        Nodes: []
    };
    while (state.pos < state.str.length) {
        while (parseComment(state))
            ;
        var keyword = parseKeyword(state);
        if (keyword) {
            if (keyword in parsers) {
                parsers[keyword](state, model);
            }
            else {
                parseUnknownBlock(state);
            }
        }
        else {
            break;
        }
    }
    for (var i = 0; i < model.Nodes.length; ++i) {
        if (model.PivotPoints[i]) {
            model.Nodes[i].PivotPoint = model.PivotPoints[i];
        }
    }
    return model;
}
exports.parse = parse;
var _a;
//# sourceMappingURL=parse.js.map
},{"../model":7}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = require("../model");
var BIG_ENDIAN = true;
var NONE = -1;
var AnimVectorType;
(function (AnimVectorType) {
    AnimVectorType[AnimVectorType["INT1"] = 0] = "INT1";
    AnimVectorType[AnimVectorType["FLOAT1"] = 1] = "FLOAT1";
    AnimVectorType[AnimVectorType["FLOAT3"] = 2] = "FLOAT3";
    AnimVectorType[AnimVectorType["FLOAT4"] = 3] = "FLOAT4";
})(AnimVectorType || (AnimVectorType = {}));
var animVectorSize = (_a = {},
    _a[AnimVectorType.INT1] = 1,
    _a[AnimVectorType.FLOAT1] = 1,
    _a[AnimVectorType.FLOAT3] = 3,
    _a[AnimVectorType.FLOAT4] = 4,
    _a);
var State = (function () {
    function State(arrayBuffer) {
        this.ab = arrayBuffer;
        this.pos = 0;
        this.length = arrayBuffer.byteLength;
        this.view = new DataView(this.ab);
        this.uint = new Uint8Array(this.ab);
    }
    State.prototype.keyword = function () {
        var res = String.fromCharCode(this.uint[this.pos], this.uint[this.pos + 1], this.uint[this.pos + 2], this.uint[this.pos + 3]);
        this.pos += 4;
        return res;
    };
    State.prototype.expectKeyword = function (keyword, errorText) {
        if (this.keyword() !== keyword) {
            throw new Error(errorText);
        }
    };
    State.prototype.uint8 = function () {
        return this.view.getUint8(this.pos++);
    };
    State.prototype.uint16 = function () {
        var res = this.view.getUint16(this.pos, BIG_ENDIAN);
        this.pos += 2;
        return res;
    };
    State.prototype.int32 = function () {
        var res = this.view.getInt32(this.pos, BIG_ENDIAN);
        this.pos += 4;
        return res;
    };
    State.prototype.float32 = function () {
        var res = this.view.getFloat32(this.pos, BIG_ENDIAN);
        this.pos += 4;
        return res;
    };
    State.prototype.str = function (length) {
        // actual string length
        // data may consist of ['a', 'b', 'c', 0, 0, 0]
        var stringLength = length;
        while (this.uint[this.pos + stringLength - 1] === 0 && stringLength > 0) {
            --stringLength;
        }
        // ??
        // TS2461:Type 'Uint8Array' is not an array type.
        // let res = String.fromCharCode(...this.uint.slice(this.pos, this.pos + length));
        var res = String.fromCharCode.apply(String, this.uint.slice(this.pos, this.pos + stringLength));
        this.pos += length;
        return res;
    };
    State.prototype.animVector = function (type) {
        var res = {
            Keys: []
        };
        var isInt = type === AnimVectorType.INT1;
        var vectorSize = animVectorSize[type];
        var keysCount = this.int32();
        res.LineType = this.int32();
        res.GlobalSeqId = this.int32();
        if (res.GlobalSeqId === NONE) {
            res.GlobalSeqId = null;
        }
        for (var i = 0; i < keysCount; ++i) {
            var animKeyFrame = {};
            animKeyFrame.Frame = this.int32();
            if (isInt) {
                animKeyFrame.Vector = new Int32Array(vectorSize);
            }
            else {
                animKeyFrame.Vector = new Float32Array(vectorSize);
            }
            for (var j = 0; j < vectorSize; ++j) {
                if (isInt) {
                    animKeyFrame.Vector[j] = this.int32();
                }
                else {
                    animKeyFrame.Vector[j] = this.float32();
                }
            }
            if (res.LineType === model_1.LineType.Hermite || res.LineType === model_1.LineType.Bezier) {
                for (var _i = 0, _a = ['InTan', 'OutTan']; _i < _a.length; _i++) {
                    var part = _a[_i];
                    animKeyFrame[part] = new Float32Array(vectorSize);
                    for (var j = 0; j < vectorSize; ++j) {
                        if (isInt) {
                            animKeyFrame[part][j] = this.int32();
                        }
                        else {
                            animKeyFrame[part][j] = this.float32();
                        }
                    }
                }
            }
            res.Keys.push(animKeyFrame);
        }
        return res;
    };
    return State;
}());
function parseExtent(obj, state) {
    obj.BoundsRadius = state.float32();
    for (var _i = 0, _a = ['MinimumExtent', 'MaximumExtent']; _i < _a.length; _i++) {
        var key = _a[_i];
        obj[key] = new Float32Array(3);
        for (var i = 0; i < 3; ++i) {
            obj[key][i] = state.float32();
        }
    }
}
function parseVersion(model, state) {
    model.Version = state.int32();
}
var MODEL_NAME_LENGTH = 0x150;
function parseModelInfo(model, state) {
    model.Info.Name = state.str(MODEL_NAME_LENGTH);
    state.int32(); // unknown 4-byte sequence
    parseExtent(model.Info, state);
    model.Info.BlendTime = state.int32();
}
var MODEL_SEQUENCE_NAME_LENGTH = 0x50;
function parseSequences(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var name_1 = state.str(MODEL_SEQUENCE_NAME_LENGTH);
        var sequence = {};
        sequence.Name = name_1;
        var interval = new Uint32Array(2);
        interval[0] = state.int32();
        interval[1] = state.int32();
        sequence.Interval = interval;
        sequence.MoveSpeed = state.float32();
        sequence.NonLooping = state.int32() > 0;
        sequence.Rarity = state.float32();
        state.int32(); // unknown 4-byte sequence (syncPoint?)
        parseExtent(sequence, state);
        model.Sequences.push(sequence);
    }
}
function parseMaterials(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        state.int32(); // material size inclusive
        var material = {
            Layers: []
        };
        material.PriorityPlane = state.int32();
        material.RenderMode = state.int32();
        state.expectKeyword('LAYS', 'Incorrect materials format');
        var layersCount = state.int32();
        for (var i = 0; i < layersCount; ++i) {
            var startPos2 = state.pos;
            var size2 = state.int32();
            var layer = {};
            layer.FilterMode = state.int32();
            layer.Shading = state.int32();
            layer.TextureID = state.int32();
            layer.TVertexAnimId = state.int32();
            if (layer.TVertexAnimId === NONE) {
                layer.TVertexAnimId = null;
            }
            layer.CoordId = state.int32();
            layer.Alpha = state.float32();
            while (state.pos < startPos2 + size2) {
                var keyword = state.keyword();
                if (keyword === 'KMTA') {
                    layer.Alpha = state.animVector(AnimVectorType.FLOAT1);
                }
                else if (keyword === 'KMTF') {
                    layer.TextureID = state.animVector(AnimVectorType.INT1);
                }
                else {
                    throw new Error('Unknown layer chunk data ' + keyword);
                }
            }
            material.Layers.push(layer);
        }
        model.Materials.push(material);
    }
}
var MODEL_TEXTURE_PATH_LENGTH = 0x100;
function parseTextures(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var texture = {};
        texture.ReplaceableId = state.int32();
        texture.Image = state.str(MODEL_TEXTURE_PATH_LENGTH);
        state.int32(); // unknown 4-byte sequence
        texture.Flags = state.int32();
        model.Textures.push(texture);
    }
}
function parseGeosets(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var geoset = {};
        state.int32(); // geoset size, not used
        state.expectKeyword('VRTX', 'Incorrect geosets format');
        var verticesCount = state.int32();
        geoset.Vertices = new Float32Array(verticesCount * 3);
        for (var i = 0; i < verticesCount * 3; ++i) {
            geoset.Vertices[i] = state.float32();
        }
        state.expectKeyword('NRMS', 'Incorrect geosets format');
        var normalsCount = state.int32();
        geoset.Normals = new Float32Array(normalsCount * 3);
        for (var i = 0; i < normalsCount * 3; ++i) {
            geoset.Normals[i] = state.float32();
        }
        state.expectKeyword('PTYP', 'Incorrect geosets format');
        var primitiveCount = state.int32();
        for (var i = 0; i < primitiveCount; ++i) {
            if (state.int32() !== 4) {
                throw new Error('Incorrect geosets format');
            }
        }
        state.expectKeyword('PCNT', 'Incorrect geosets format');
        var faceGroupCount = state.int32();
        for (var i = 0; i < faceGroupCount; ++i) {
            state.int32();
        }
        state.expectKeyword('PVTX', 'Incorrect geosets format');
        var indicesCount = state.int32();
        geoset.Faces = new Uint16Array(indicesCount);
        for (var i = 0; i < indicesCount; ++i) {
            geoset.Faces[i] = state.uint16();
        }
        state.expectKeyword('GNDX', 'Incorrect geosets format');
        var verticesGroupCount = state.int32();
        geoset.VertexGroup = new Uint8Array(verticesGroupCount);
        for (var i = 0; i < verticesGroupCount; ++i) {
            geoset.VertexGroup[i] = state.uint8();
        }
        state.expectKeyword('MTGC', 'Incorrect geosets format');
        var groupsCount = state.int32();
        geoset.Groups = [];
        for (var i = 0; i < groupsCount; ++i) {
            // new Array(array length)
            geoset.Groups[i] = new Array(state.int32());
        }
        state.expectKeyword('MATS', 'Incorrect geosets format');
        geoset.TotalGroupsCount = state.int32();
        var groupIndex = 0;
        var groupCounter = 0;
        for (var i = 0; i < geoset.TotalGroupsCount; ++i) {
            if (groupIndex >= geoset.Groups[groupCounter].length) {
                groupIndex = 0;
                groupCounter++;
            }
            geoset.Groups[groupCounter][groupIndex++] = state.int32();
        }
        geoset.MaterialID = state.int32();
        geoset.SelectionGroup = state.int32();
        geoset.Unselectable = state.int32() > 0;
        parseExtent(geoset, state);
        var geosetAnimCount = state.int32();
        geoset.Anims = [];
        for (var i = 0; i < geosetAnimCount; ++i) {
            var geosetAnim = {};
            parseExtent(geosetAnim, state);
            geoset.Anims.push(geosetAnim);
        }
        state.expectKeyword('UVAS', 'Incorrect geosets format');
        var textureChunkCount = state.int32();
        geoset.TVertices = [];
        for (var i = 0; i < textureChunkCount; ++i) {
            state.expectKeyword('UVBS', 'Incorrect geosets format');
            var textureCoordsCount = state.int32();
            var tvertices = new Float32Array(textureCoordsCount * 2);
            for (var j = 0; j < textureCoordsCount * 2; ++j) {
                tvertices[j] = state.float32();
            }
            geoset.TVertices.push(tvertices);
        }
        model.Geosets.push(geoset);
    }
}
function parseGeosetAnims(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var animStartPos = state.pos;
        var animSize = state.int32();
        var geosetAnim = {};
        geosetAnim.Alpha = state.float32();
        geosetAnim.Flags = state.int32();
        geosetAnim.Color = new Float32Array(3);
        for (var i = 0; i < 3; ++i) {
            geosetAnim.Color[i] = state.float32();
        }
        geosetAnim.GeosetId = state.int32();
        if (geosetAnim.GeosetId === NONE) {
            geosetAnim.GeosetId = null;
        }
        while (state.pos < animStartPos + animSize) {
            var keyword = state.keyword();
            if (keyword === 'KGAO') {
                geosetAnim.Alpha = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KGAC') {
                geosetAnim.Color = state.animVector(AnimVectorType.FLOAT3);
            }
            else {
                throw new Error('Incorrect GeosetAnim chunk data ' + keyword);
            }
        }
        model.GeosetAnims.push(geosetAnim);
    }
}
var MODEL_NODE_NAME_LENGTH = 0x50;
function parseNode(model, node, state) {
    var startPos = state.pos;
    var size = state.int32();
    node.Name = state.str(MODEL_NODE_NAME_LENGTH);
    node.ObjectId = state.int32();
    if (node.ObjectId === NONE) {
        node.ObjectId = null;
    }
    node.Parent = state.int32();
    if (node.Parent === NONE) {
        node.Parent = null;
    }
    node.Flags = state.int32();
    while (state.pos < startPos + size) {
        var keyword = state.keyword();
        if (keyword === 'KGTR') {
            node.Translation = state.animVector(AnimVectorType.FLOAT3);
        }
        else if (keyword === 'KGRT') {
            node.Rotation = state.animVector(AnimVectorType.FLOAT4);
        }
        else if (keyword === 'KGSC') {
            node.Scaling = state.animVector(AnimVectorType.FLOAT3);
        }
        else {
            throw new Error('Incorrect node chunk data ' + keyword);
        }
    }
    model.Nodes[node.ObjectId] = node;
}
function parseBones(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var bone = {};
        parseNode(model, bone, state);
        bone.GeosetId = state.int32();
        if (bone.GeosetId === NONE) {
            bone.GeosetId = null;
        }
        bone.GeosetAnimId = state.int32();
        if (bone.GeosetAnimId === NONE) {
            bone.GeosetAnimId = null;
        }
        model.Bones.push(bone);
    }
}
function parseHelpers(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var helper = {};
        parseNode(model, helper, state);
        model.Helpers.push(helper);
    }
}
var MODEL_ATTACHMENT_PATH_LENGTH = 0x100;
function parseAttachments(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var attachmentStart = state.pos;
        var attachmentSize = state.int32();
        var attachment = {};
        parseNode(model, attachment, state);
        attachment.Path = state.str(MODEL_ATTACHMENT_PATH_LENGTH);
        state.int32(); // unknown 4-byte
        attachment.AttachmentID = state.int32();
        if (state.pos < attachmentStart + attachmentSize) {
            state.expectKeyword('KATV', 'Incorrect attachment chunk data');
            attachment.Visibility = state.animVector(AnimVectorType.FLOAT1);
        }
        model.Attachments.push(attachment);
    }
}
function parsePivotPoints(model, state, size) {
    var pointsCount = size / (4 * 3);
    for (var i = 0; i < pointsCount; ++i) {
        model.PivotPoints[i] = new Float32Array(3);
        model.PivotPoints[i][0] = state.float32();
        model.PivotPoints[i][1] = state.float32();
        model.PivotPoints[i][2] = state.float32();
    }
}
function parseEventObjects(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var eventObject = {};
        parseNode(model, eventObject, state);
        state.expectKeyword('KEVT', 'Incorrect EventObject chunk data');
        var eventTrackCount = state.int32();
        eventObject.EventTrack = new Uint32Array(eventTrackCount);
        state.int32(); // unused 4-byte?
        for (var i = 0; i < eventTrackCount; ++i) {
            eventObject.EventTrack[i] = state.int32();
        }
        model.EventObjects.push(eventObject);
    }
}
function parseCollisionShapes(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var collisionShape = {};
        parseNode(model, collisionShape, state);
        collisionShape.Shape = state.int32();
        if (collisionShape.Shape === model_1.CollisionShapeType.Box) {
            collisionShape.Vertices = new Float32Array(6);
        }
        else {
            collisionShape.Vertices = new Float32Array(3);
        }
        for (var i = 0; i < collisionShape.Vertices.length; ++i) {
            collisionShape.Vertices[i] = state.float32();
        }
        if (collisionShape.Shape === model_1.CollisionShapeType.Sphere) {
            collisionShape.BoundsRadius = state.float32();
        }
        model.CollisionShapes.push(collisionShape);
    }
}
function parseGlobalSequences(model, state, size) {
    var startPos = state.pos;
    model.GlobalSequences = [];
    while (state.pos < startPos + size) {
        model.GlobalSequences.push(state.int32());
    }
}
var MODEL_PARTICLE_EMITTER_PATH_LENGTH = 0x100;
function parseParticleEmitters(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var emitterStart = state.pos;
        var emitterSize = state.int32();
        var emitter = {};
        parseNode(model, emitter, state);
        emitter.EmissionRate = state.float32();
        emitter.Gravity = state.float32();
        emitter.Longitude = state.float32();
        emitter.Latitude = state.float32();
        emitter.Path = state.str(MODEL_PARTICLE_EMITTER_PATH_LENGTH);
        state.int32();
        emitter.LifeSpan = state.float32();
        emitter.InitVelocity = state.float32();
        while (state.pos < emitterStart + emitterSize) {
            var keyword = state.keyword();
            if (keyword === 'KPEV') {
                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KPEE') {
                emitter.EmissionRate = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KPEG') {
                emitter.Gravity = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KPLN') {
                emitter.Longitude = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KPLT') {
                emitter.Latitude = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KPEL') {
                emitter.LifeSpan = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KPES') {
                emitter.InitVelocity = state.animVector(AnimVectorType.FLOAT1);
            }
            else {
                throw new Error('Incorrect particle emitter chunk data ' + keyword);
            }
        }
        model.ParticleEmitters.push(emitter);
    }
}
function parseParticleEmitters2(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var emitterStart = state.pos;
        var emitterSize = state.int32();
        var emitter = {};
        parseNode(model, emitter, state);
        emitter.Speed = state.float32();
        emitter.Variation = state.float32();
        emitter.Latitude = state.float32();
        emitter.Gravity = state.float32();
        emitter.LifeSpan = state.float32();
        emitter.EmissionRate = state.float32();
        emitter.Width = state.float32();
        emitter.Length = state.float32();
        emitter.FilterMode = state.int32();
        emitter.Rows = state.int32();
        emitter.Columns = state.int32();
        var frameFlags = state.int32();
        emitter.FrameFlags = 0;
        if (frameFlags === 0 || frameFlags === 2) {
            emitter.FrameFlags |= model_1.ParticleEmitter2FramesFlags.Head;
        }
        if (frameFlags === 1 || frameFlags === 2) {
            emitter.FrameFlags |= model_1.ParticleEmitter2FramesFlags.Tail;
        }
        emitter.TailLength = state.float32();
        emitter.Time = state.float32();
        emitter.SegmentColor = [];
        // always 3 segments
        for (var i = 0; i < 3; ++i) {
            emitter.SegmentColor[i] = new Float32Array(3);
            //  rgb order, inverse from mdl
            for (var j = 0; j < 3; ++j) {
                emitter.SegmentColor[i][j] = state.float32();
            }
        }
        emitter.Alpha = new Uint8Array(3);
        for (var i = 0; i < 3; ++i) {
            emitter.Alpha[i] = state.uint8();
        }
        emitter.ParticleScaling = new Float32Array(3);
        for (var i = 0; i < 3; ++i) {
            emitter.ParticleScaling[i] = state.float32();
        }
        for (var _i = 0, _a = ['LifeSpanUVAnim', 'DecayUVAnim', 'TailUVAnim', 'TailDecayUVAnim']; _i < _a.length; _i++) {
            var part = _a[_i];
            emitter[part] = new Uint32Array(3);
            for (var i = 0; i < 3; ++i) {
                emitter[part][i] = state.int32();
            }
        }
        emitter.TextureID = state.int32();
        if (emitter.TextureID === NONE) {
            emitter.TextureID = null;
        }
        emitter.Squirt = state.int32() > 0;
        emitter.PriorityPlane = state.int32();
        emitter.ReplaceableId = state.int32();
        while (state.pos < emitterStart + emitterSize) {
            var keyword = state.keyword();
            if (keyword === 'KP2V') {
                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2E') {
                emitter.EmissionRate = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2W') {
                emitter.Width = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2N') {
                emitter.Length = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2S') {
                emitter.Speed = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2L') {
                emitter.Latitude = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2G') {
                emitter.Gravity = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KP2R') {
                emitter.Variation = state.animVector(AnimVectorType.FLOAT1);
            }
            else {
                throw new Error('Incorrect particle emitter2 chunk data ' + keyword);
            }
        }
        model.ParticleEmitters2.push(emitter);
    }
}
var MODEL_CAMERA_NAME_LENGTH = 0x50;
function parseCameras(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var cameraStart = state.pos;
        var cameraSize = state.int32();
        var camera = {};
        camera.Name = state.str(MODEL_CAMERA_NAME_LENGTH);
        camera.Position = new Float32Array(3);
        camera.Position[0] = state.float32();
        camera.Position[1] = state.float32();
        camera.Position[2] = state.float32();
        camera.FieldOfView = state.float32();
        camera.FarClip = state.float32();
        camera.NearClip = state.float32();
        camera.TargetPosition = new Float32Array(3);
        camera.TargetPosition[0] = state.float32();
        camera.TargetPosition[1] = state.float32();
        camera.TargetPosition[2] = state.float32();
        while (state.pos < cameraStart + cameraSize) {
            var keyword = state.keyword();
            if (keyword === 'KCTR') {
                camera.Translation = state.animVector(AnimVectorType.FLOAT3);
            }
            else if (keyword === 'KTTR') {
                camera.TargetTranslation = state.animVector(AnimVectorType.FLOAT3);
            }
            else if (keyword === 'KCRL') {
                camera.Rotation = state.animVector(AnimVectorType.FLOAT1);
            }
            else {
                throw new Error('Incorrect camera chunk data ' + keyword);
            }
        }
        model.Cameras.push(camera);
    }
}
function parseLights(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var lightStart = state.pos;
        var lightSize = state.int32();
        var light = {};
        parseNode(model, light, state);
        light.LightType = state.int32();
        light.AttenuationStart = state.float32();
        light.AttenuationEnd = state.float32();
        light.Color = new Float32Array(3);
        //  rgb order, inverse from mdl
        for (var j = 0; j < 3; ++j) {
            light.Color[j] = state.float32();
        }
        light.Intensity = state.float32();
        light.AmbColor = new Float32Array(3);
        //  rgb order, inverse from mdl
        for (var j = 0; j < 3; ++j) {
            light.AmbColor[j] = state.float32();
        }
        light.AmbIntensity = state.float32();
        while (state.pos < lightStart + lightSize) {
            var keyword = state.keyword();
            if (keyword === 'KLAV') {
                light.Visibility = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KLAC') {
                light.Color = state.animVector(AnimVectorType.FLOAT3);
            }
            else if (keyword === 'KLAI') {
                light.Intensity = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KLBC') {
                light.AmbColor = state.animVector(AnimVectorType.FLOAT3);
            }
            else if (keyword === 'KLBI') {
                light.AmbIntensity = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KLAS') {
                light.AttenuationStart = state.animVector(AnimVectorType.INT1);
            }
            else if (keyword === 'KLAE') {
                light.AttenuationEnd = state.animVector(AnimVectorType.INT1);
            }
            else {
                throw new Error('Incorrect light chunk data ' + keyword);
            }
        }
        model.Lights.push(light);
    }
}
function parseTextureAnims(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var animStart = state.pos;
        var animSize = state.int32();
        var anim = {};
        while (state.pos < animStart + animSize) {
            var keyword = state.keyword();
            if (keyword === 'KTAT') {
                anim.Translation = state.animVector(AnimVectorType.FLOAT3);
            }
            else if (keyword === 'KTAR') {
                anim.Rotation = state.animVector(AnimVectorType.FLOAT4);
            }
            else if (keyword === 'KTAS') {
                anim.Scaling = state.animVector(AnimVectorType.FLOAT3);
            }
            else {
                throw new Error('Incorrect light chunk data ' + keyword);
            }
        }
        model.TextureAnims.push(anim);
    }
}
function parseRibbonEmitters(model, state, size) {
    var startPos = state.pos;
    while (state.pos < startPos + size) {
        var emitterStart = state.pos;
        var emitterSize = state.int32();
        var emitter = {};
        parseNode(model, emitter, state);
        emitter.HeightAbove = state.float32();
        emitter.HeightBelow = state.float32();
        emitter.Alpha = state.float32();
        emitter.Color = new Float32Array(3);
        //  rgb order, inverse from mdl
        for (var j = 0; j < 3; ++j) {
            emitter.Color[j] = state.float32();
        }
        emitter.LifeSpan = state.float32();
        emitter.TextureSlot = state.int32();
        emitter.EmissionRate = state.int32();
        emitter.Rows = state.int32();
        emitter.Columns = state.int32();
        emitter.MaterialID = state.int32();
        emitter.Gravity = state.float32();
        while (state.pos < emitterStart + emitterSize) {
            var keyword = state.keyword();
            if (keyword === 'KRVS') {
                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KRHA') {
                emitter.HeightAbove = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KRHB') {
                emitter.HeightBelow = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KRAL') {
                emitter.Alpha = state.animVector(AnimVectorType.FLOAT1);
            }
            else if (keyword === 'KRTX') {
                emitter.TextureSlot = state.animVector(AnimVectorType.INT1);
            }
            else {
                throw new Error('Incorrect ribbon emitter chunk data ' + keyword);
            }
        }
        model.RibbonEmitters.push(emitter);
    }
}
var parsers = {
    VERS: parseVersion,
    MODL: parseModelInfo,
    SEQS: parseSequences,
    MTLS: parseMaterials,
    TEXS: parseTextures,
    GEOS: parseGeosets,
    GEOA: parseGeosetAnims,
    BONE: parseBones,
    HELP: parseHelpers,
    ATCH: parseAttachments,
    PIVT: parsePivotPoints,
    EVTS: parseEventObjects,
    CLID: parseCollisionShapes,
    GLBS: parseGlobalSequences,
    PREM: parseParticleEmitters,
    PRE2: parseParticleEmitters2,
    CAMS: parseCameras,
    LITE: parseLights,
    TXAN: parseTextureAnims,
    RIBB: parseRibbonEmitters
};
function parse(arrayBuffer) {
    var state = new State(arrayBuffer);
    if (state.keyword() !== 'MDLX') {
        throw new Error('Not a mdx model');
    }
    var model = {
        // default
        Version: 800,
        Info: {
            Name: '',
            MinimumExtent: null,
            MaximumExtent: null,
            BoundsRadius: 0,
            BlendTime: 150
        },
        Sequences: [],
        GlobalSequences: [],
        Textures: [],
        Materials: [],
        TextureAnims: [],
        Geosets: [],
        GeosetAnims: [],
        Bones: [],
        Helpers: [],
        Attachments: [],
        EventObjects: [],
        ParticleEmitters: [],
        ParticleEmitters2: [],
        Cameras: [],
        Lights: [],
        RibbonEmitters: [],
        CollisionShapes: [],
        PivotPoints: [],
        Nodes: []
    };
    while (state.pos < state.length) {
        var keyword = state.keyword();
        var size = state.int32();
        if (keyword in parsers) {
            parsers[keyword](model, state, size);
        }
        else {
            throw new Error('Unknown group ' + keyword);
        }
    }
    for (var i = 0; i < model.Nodes.length; ++i) {
        if (model.Nodes[i] && model.PivotPoints[i]) {
            model.Nodes[i].PivotPoint = model.PivotPoints[i];
        }
    }
    return model;
}
exports.parse = parse;
var _a;
//# sourceMappingURL=parse.js.map
},{"../model":7}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureFlags;
(function (TextureFlags) {
    TextureFlags[TextureFlags["WrapWidth"] = 1] = "WrapWidth";
    TextureFlags[TextureFlags["WrapHeight"] = 2] = "WrapHeight";
})(TextureFlags = exports.TextureFlags || (exports.TextureFlags = {}));
var FilterMode;
(function (FilterMode) {
    FilterMode[FilterMode["None"] = 0] = "None";
    FilterMode[FilterMode["Transparent"] = 1] = "Transparent";
    FilterMode[FilterMode["Blend"] = 2] = "Blend";
    FilterMode[FilterMode["Additive"] = 3] = "Additive";
    FilterMode[FilterMode["AddAlpha"] = 4] = "AddAlpha";
    FilterMode[FilterMode["Modulate"] = 5] = "Modulate";
    FilterMode[FilterMode["Modulate2x"] = 6] = "Modulate2x";
})(FilterMode = exports.FilterMode || (exports.FilterMode = {}));
var LineType;
(function (LineType) {
    LineType[LineType["DontInterp"] = 0] = "DontInterp";
    LineType[LineType["Linear"] = 1] = "Linear";
    LineType[LineType["Hermite"] = 2] = "Hermite";
    LineType[LineType["Bezier"] = 3] = "Bezier";
})(LineType = exports.LineType || (exports.LineType = {}));
var LayerShading;
(function (LayerShading) {
    LayerShading[LayerShading["Unshaded"] = 1] = "Unshaded";
    LayerShading[LayerShading["SphereEnvMap"] = 2] = "SphereEnvMap";
    LayerShading[LayerShading["TwoSided"] = 16] = "TwoSided";
    LayerShading[LayerShading["Unfogged"] = 32] = "Unfogged";
    LayerShading[LayerShading["NoDepthTest"] = 64] = "NoDepthTest";
    LayerShading[LayerShading["NoDepthSet"] = 128] = "NoDepthSet";
})(LayerShading = exports.LayerShading || (exports.LayerShading = {}));
var MaterialRenderMode;
(function (MaterialRenderMode) {
    MaterialRenderMode[MaterialRenderMode["ConstantColor"] = 1] = "ConstantColor";
    MaterialRenderMode[MaterialRenderMode["SortPrimsFarZ"] = 16] = "SortPrimsFarZ";
    MaterialRenderMode[MaterialRenderMode["FullResolution"] = 32] = "FullResolution";
})(MaterialRenderMode = exports.MaterialRenderMode || (exports.MaterialRenderMode = {}));
var GeosetAnimFlags;
(function (GeosetAnimFlags) {
    GeosetAnimFlags[GeosetAnimFlags["DropShadow"] = 1] = "DropShadow";
    GeosetAnimFlags[GeosetAnimFlags["Color"] = 2] = "Color";
})(GeosetAnimFlags = exports.GeosetAnimFlags || (exports.GeosetAnimFlags = {}));
var NodeFlags;
(function (NodeFlags) {
    NodeFlags[NodeFlags["DontInheritTranslation"] = 1] = "DontInheritTranslation";
    NodeFlags[NodeFlags["DontInheritRotation"] = 2] = "DontInheritRotation";
    NodeFlags[NodeFlags["DontInheritScaling"] = 4] = "DontInheritScaling";
    NodeFlags[NodeFlags["Billboarded"] = 8] = "Billboarded";
    NodeFlags[NodeFlags["BillboardedLockX"] = 16] = "BillboardedLockX";
    NodeFlags[NodeFlags["BillboardedLockY"] = 32] = "BillboardedLockY";
    NodeFlags[NodeFlags["BillboardedLockZ"] = 64] = "BillboardedLockZ";
    NodeFlags[NodeFlags["CameraAnchored"] = 128] = "CameraAnchored";
})(NodeFlags = exports.NodeFlags || (exports.NodeFlags = {}));
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Helper"] = 0] = "Helper";
    NodeType[NodeType["Bone"] = 256] = "Bone";
    NodeType[NodeType["Light"] = 512] = "Light";
    NodeType[NodeType["EventObject"] = 1024] = "EventObject";
    NodeType[NodeType["Attachment"] = 2048] = "Attachment";
    NodeType[NodeType["ParticleEmitter"] = 4096] = "ParticleEmitter";
    NodeType[NodeType["CollisionShape"] = 8192] = "CollisionShape";
    NodeType[NodeType["RibbonEmitter"] = 16384] = "RibbonEmitter";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
var CollisionShapeType;
(function (CollisionShapeType) {
    CollisionShapeType[CollisionShapeType["Box"] = 0] = "Box";
    CollisionShapeType[CollisionShapeType["Sphere"] = 2] = "Sphere";
})(CollisionShapeType = exports.CollisionShapeType || (exports.CollisionShapeType = {}));
var ParticleEmitterFlags;
(function (ParticleEmitterFlags) {
    ParticleEmitterFlags[ParticleEmitterFlags["EmitterUsesMDL"] = 32768] = "EmitterUsesMDL";
    ParticleEmitterFlags[ParticleEmitterFlags["EmitterUsesTGA"] = 65536] = "EmitterUsesTGA";
})(ParticleEmitterFlags = exports.ParticleEmitterFlags || (exports.ParticleEmitterFlags = {}));
var ParticleEmitter2Flags;
(function (ParticleEmitter2Flags) {
    ParticleEmitter2Flags[ParticleEmitter2Flags["Unshaded"] = 32768] = "Unshaded";
    ParticleEmitter2Flags[ParticleEmitter2Flags["SortPrimsFarZ"] = 65536] = "SortPrimsFarZ";
    ParticleEmitter2Flags[ParticleEmitter2Flags["LineEmitter"] = 131072] = "LineEmitter";
    ParticleEmitter2Flags[ParticleEmitter2Flags["Unfogged"] = 262144] = "Unfogged";
    ParticleEmitter2Flags[ParticleEmitter2Flags["ModelSpace"] = 524288] = "ModelSpace";
    ParticleEmitter2Flags[ParticleEmitter2Flags["XYQuad"] = 1048576] = "XYQuad";
})(ParticleEmitter2Flags = exports.ParticleEmitter2Flags || (exports.ParticleEmitter2Flags = {}));
var ParticleEmitter2FilterMode;
(function (ParticleEmitter2FilterMode) {
    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode["Blend"] = 0] = "Blend";
    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode["Additive"] = 1] = "Additive";
    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode["Modulate"] = 2] = "Modulate";
    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode["Modulate2x"] = 3] = "Modulate2x";
    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode["AlphaKey"] = 4] = "AlphaKey";
})(ParticleEmitter2FilterMode = exports.ParticleEmitter2FilterMode || (exports.ParticleEmitter2FilterMode = {}));
// Not actually mapped to mdx flags (0: Head, 1: Tail, 2: Both)
var ParticleEmitter2FramesFlags;
(function (ParticleEmitter2FramesFlags) {
    ParticleEmitter2FramesFlags[ParticleEmitter2FramesFlags["Head"] = 1] = "Head";
    ParticleEmitter2FramesFlags[ParticleEmitter2FramesFlags["Tail"] = 2] = "Tail";
})(ParticleEmitter2FramesFlags = exports.ParticleEmitter2FramesFlags || (exports.ParticleEmitter2FramesFlags = {}));
var LightType;
(function (LightType) {
    LightType[LightType["Omnidirectional"] = 0] = "Omnidirectional";
    LightType[LightType["Directional"] = 1] = "Directional";
    LightType[LightType["Ambient"] = 2] = "Ambient";
})(LightType = exports.LightType || (exports.LightType = {}));
//# sourceMappingURL=model.js.map
},{}],8:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":9,"./gl-matrix/mat2.js":10,"./gl-matrix/mat2d.js":11,"./gl-matrix/mat3.js":12,"./gl-matrix/mat4.js":13,"./gl-matrix/quat.js":14,"./gl-matrix/vec2.js":15,"./gl-matrix/vec3.js":16,"./gl-matrix/vec4.js":17}],9:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;

},{}],10:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;

},{"./common.js":9}],11:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;

},{"./common.js":9}],12:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;

},{"./common.js":9}],13:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;

},{"./common.js":9}],14:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;

},{"./common.js":9,"./mat3.js":12,"./vec3.js":16,"./vec4.js":17}],15:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;

},{"./common.js":9}],16:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;

},{"./common.js":9}],17:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;

},{"./common.js":9}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = require("../model");
var gl_matrix_1 = require("gl-matrix");
var findKeyframesRes = {
    frame: 0,
    left: null,
    right: null
};
function lerp(left, right, t) {
    return left * (1 - t) + right * t;
}
exports.lerp = lerp;
function bezier(left, outTan, inTan, right, t) {
    var inverseFactor = 1 - t, inverseFactorTimesTwo = inverseFactor * inverseFactor, factorTimes2 = t * t, factor1 = inverseFactorTimesTwo * inverseFactor, factor2 = 3 * t * inverseFactorTimesTwo, factor3 = 3 * factorTimes2 * inverseFactor, factor4 = factorTimes2 * t;
    return left * factor1 + outTan * factor2 + inTan * factor3 + right * factor4;
}
function hermite(left, outTan, inTan, right, t) {
    var factorTimes2 = t * t, factor1 = factorTimes2 * (2 * t - 3) + 1, factor2 = factorTimes2 * (t - 2) + t, factor3 = factorTimes2 * (t - 1), factor4 = factorTimes2 * (3 - 2 * t);
    return left * factor1 + outTan * factor2 + inTan * factor3 + right * factor4;
}
function findKeyframes(animVector, frame, from, to) {
    if (!animVector) {
        return null;
    }
    var array = animVector.Keys;
    var first = 0;
    var count = array.length;
    if (count === 0) {
        return null;
    }
    if (array[0].Frame > to) {
        return null;
    }
    else if (array[count - 1].Frame < from) {
        return null;
    }
    while (count > 0) {
        var step = count >> 1;
        if (array[first + step].Frame <= frame) {
            first = first + step + 1;
            count -= step + 1;
        }
        else {
            count = step;
        }
    }
    if (first === array.length || array[first].Frame > to) {
        if (first > 0 && array[first - 1].Frame >= from) {
            findKeyframesRes.frame = frame;
            findKeyframesRes.left = array[first - 1];
            findKeyframesRes.right = array[first - 1];
            return findKeyframesRes;
        }
        else {
            return null;
        }
    }
    if (first === 0 || array[first - 1].Frame < from) {
        if (array[first].Frame <= to) {
            findKeyframesRes.frame = frame;
            findKeyframesRes.left = array[first];
            findKeyframesRes.right = array[first];
            return findKeyframesRes;
        }
        else {
            return null;
        }
    }
    findKeyframesRes.frame = frame;
    findKeyframesRes.left = array[first - 1];
    findKeyframesRes.right = array[first];
    return findKeyframesRes;
}
exports.findKeyframes = findKeyframes;
function interpNum(frame, left, right, lineType) {
    if (left.Frame === right.Frame) {
        return left.Vector[0];
    }
    var t = (frame - left.Frame) / (right.Frame - left.Frame);
    if (lineType === model_1.LineType.DontInterp) {
        return left.Vector[0];
    }
    else if (lineType === model_1.LineType.Bezier) {
        return bezier(left.Vector[0], left.OutTan[0], right.InTan[0], right.Vector[0], t);
    }
    else if (lineType === model_1.LineType.Hermite) {
        return hermite(left.Vector[0], left.OutTan[0], right.InTan[0], right.Vector[0], t);
    }
    else {
        // Linear
        return lerp(left.Vector[0], right.Vector[0], t);
    }
}
exports.interpNum = interpNum;
function interpVec3(out, frame, left, right, lineType) {
    if (left.Frame === right.Frame) {
        return left.Vector;
    }
    var t = (frame - left.Frame) / (right.Frame - left.Frame);
    if (lineType === model_1.LineType.DontInterp) {
        return left.Vector;
    }
    else if (lineType === model_1.LineType.Bezier) {
        return gl_matrix_1.vec3.bezier(out, left.Vector, left.OutTan, right.InTan, right.Vector, t);
    }
    else if (lineType === model_1.LineType.Hermite) {
        return gl_matrix_1.vec3.hermite(out, left.Vector, left.OutTan, right.InTan, right.Vector, t);
    }
    else {
        return gl_matrix_1.vec3.lerp(out, left.Vector, right.Vector, t);
    }
}
exports.interpVec3 = interpVec3;
function interpQuat(out, frame, left, right, lineType) {
    if (left.Frame === right.Frame) {
        return left.Vector;
    }
    var t = (frame - left.Frame) / (right.Frame - left.Frame);
    if (lineType === model_1.LineType.DontInterp) {
        return left.Vector;
    }
    else if (lineType === model_1.LineType.Hermite || lineType === model_1.LineType.Bezier) {
        return gl_matrix_1.quat.sqlerp(out, left.Vector, left.OutTan, right.InTan, right.Vector, t);
    }
    else {
        return gl_matrix_1.quat.slerp(out, left.Vector, right.Vector, t);
    }
}
exports.interpQuat = interpQuat;
//# sourceMappingURL=interp.js.map
},{"../model":7,"gl-matrix":8}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interp_1 = require("./interp");
var findLocalFrameRes = {
    frame: 0,
    from: 0,
    to: 0
};
var ModelInterp = (function () {
    function ModelInterp(rendererData) {
        this.rendererData = rendererData;
    }
    ModelInterp.maxAnimVectorVal = function (vector) {
        if (typeof vector === 'number') {
            return vector;
        }
        var max = vector.Keys[0].Vector[0];
        for (var i = 1; i < vector.Keys.length; ++i) {
            if (vector.Keys[i].Vector[0] > max) {
                max = vector.Keys[i].Vector[0];
            }
        }
        return max;
    };
    ModelInterp.prototype.num = function (animVector) {
        var res = this.findKeyframes(animVector);
        if (!res) {
            return null;
        }
        return interp_1.interpNum(res.frame, res.left, res.right, animVector.LineType);
    };
    ModelInterp.prototype.vec3 = function (out, animVector) {
        var res = this.findKeyframes(animVector);
        if (!res) {
            return null;
        }
        return interp_1.interpVec3(out, res.frame, res.left, res.right, animVector.LineType);
    };
    ModelInterp.prototype.quat = function (out, animVector) {
        var res = this.findKeyframes(animVector);
        if (!res) {
            return null;
        }
        return interp_1.interpQuat(out, res.frame, res.left, res.right, animVector.LineType);
    };
    ModelInterp.prototype.animVectorVal = function (vector, defaultVal) {
        var res;
        if (typeof vector === 'number') {
            res = vector;
        }
        else {
            res = this.num(vector);
            if (res === null) {
                res = defaultVal;
            }
        }
        return res;
    };
    ModelInterp.prototype.findKeyframes = function (animVector) {
        if (!animVector) {
            return null;
        }
        var _a = this.findLocalFrame(animVector), frame = _a.frame, from = _a.from, to = _a.to;
        return interp_1.findKeyframes(animVector, frame, from, to);
    };
    ModelInterp.prototype.findLocalFrame = function (animVector) {
        if (typeof animVector.GlobalSeqId === 'number') {
            findLocalFrameRes.frame = this.rendererData.globalSequencesFrames[animVector.GlobalSeqId];
            findLocalFrameRes.from = 0;
            findLocalFrameRes.to = this.rendererData.model.GlobalSequences[animVector.GlobalSeqId];
        }
        else {
            findLocalFrameRes.frame = this.rendererData.frame;
            findLocalFrameRes.from = this.rendererData.animationInfo.Interval[0];
            findLocalFrameRes.to = this.rendererData.animationInfo.Interval[1];
        }
        return findLocalFrameRes;
    };
    return ModelInterp;
}());
exports.ModelInterp = ModelInterp;
//# sourceMappingURL=modelInterp.js.map
},{"./interp":18}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = require("../model");
var gl_matrix_1 = require("gl-matrix");
var util_1 = require("./util");
var modelInterp_1 = require("./modelInterp");
var particles_1 = require("./particles");
var ribbons_1 = require("./ribbons");
var MAX_NODES = 128;
var gl;
var shaderProgram;
var shaderProgramLocations = {};
var anisotropicExt;
var vertexShaderHardwareSkinning = "\n    attribute vec3 aVertexPosition;\n    attribute vec2 aTextureCoord;\n    attribute vec4 aGroup;\n\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    uniform mat4 uNodesMatrices[" + MAX_NODES + "];\n\n    varying vec2 vTextureCoord;\n\n    void main(void) {\n        vec4 position = vec4(aVertexPosition, 1.0);\n        int count = 1;\n        vec4 sum = uNodesMatrices[int(aGroup[0])] * position;\n\n        if (aGroup[1] < " + MAX_NODES + ".) {\n            sum += uNodesMatrices[int(aGroup[1])] * position;\n            count += 1;\n        }\n        if (aGroup[2] < " + MAX_NODES + ".) {\n            sum += uNodesMatrices[int(aGroup[2])] * position;\n            count += 1;\n        }\n        if (aGroup[3] < " + MAX_NODES + ".) {\n            sum += uNodesMatrices[int(aGroup[3])] * position;\n            count += 1;\n        }\n        sum.xyz /= float(count);\n        sum.w = 1.;\n        position = sum;\n\n        gl_Position = uPMatrix * uMVMatrix * position;\n        vTextureCoord = aTextureCoord;\n    }\n";
var vertexShaderSoftwareSkinning = "\n    attribute vec3 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n\n    varying vec2 vTextureCoord;\n\n    void main(void) {\n        vec4 position = vec4(aVertexPosition, 1.0);\n        gl_Position = uPMatrix * uMVMatrix * position;\n        vTextureCoord = aTextureCoord;\n    }\n";
var fragmentShader = "\n    precision mediump float;\n\n    varying vec2 vTextureCoord;\n\n    uniform sampler2D uSampler;\n    uniform vec3 uReplaceableColor;\n    uniform float uReplaceableType;\n    uniform float uDiscardAlphaLevel;\n    uniform mat3 uTVextexAnim;\n\n    float hypot (vec2 z) {\n        float t;\n        float x = abs(z.x);\n        float y = abs(z.y);\n        t = min(x, y);\n        x = max(x, y);\n        t = t / x;\n        return (z.x == 0.0 && z.y == 0.0) ? 0.0 : x * sqrt(1.0 + t * t);\n    }\n\n    void main(void) {\n        vec2 texCoord = (uTVextexAnim * vec3(vTextureCoord.s, vTextureCoord.t, 1.)).st;\n\n        if (uReplaceableType == 0.) {\n            gl_FragColor = texture2D(uSampler, texCoord);\n        } else if (uReplaceableType == 1.) {\n            gl_FragColor = vec4(uReplaceableColor, 1.0);\n        } else if (uReplaceableType == 2.) {\n            float dist = hypot(texCoord - vec2(0.5, 0.5)) * 2.;\n            float truncateDist = clamp(1. - dist * 1.4, 0., 1.);\n            float alpha = sin(truncateDist);\n            gl_FragColor = vec4(uReplaceableColor * alpha, 1.0);\n        }\n\n        // hand-made alpha-test\n        if (gl_FragColor[3] < uDiscardAlphaLevel) {\n            discard;\n        }\n    }\n";
var translation = gl_matrix_1.vec3.create();
var rotation = gl_matrix_1.quat.create();
var scaling = gl_matrix_1.vec3.create();
var defaultTranslation = gl_matrix_1.vec3.fromValues(0, 0, 0);
var defaultRotation = gl_matrix_1.quat.fromValues(0, 0, 0, 1);
var defaultScaling = gl_matrix_1.vec3.fromValues(1, 1, 1);
var tempParentRotationQuat = gl_matrix_1.quat.create();
var tempParentRotationMat = gl_matrix_1.mat4.create();
var tempCameraMat = gl_matrix_1.mat4.create();
var tempTransformedPivotPoint = gl_matrix_1.vec3.create();
var tempAxis = gl_matrix_1.vec3.create();
var tempLockQuat = gl_matrix_1.quat.create();
var tempLockMat = gl_matrix_1.mat4.create();
var tempXAxis = gl_matrix_1.vec3.create();
var tempCameraVec = gl_matrix_1.vec3.create();
var tempCross0 = gl_matrix_1.vec3.create();
var tempCross1 = gl_matrix_1.vec3.create();
var tempPos = gl_matrix_1.vec3.create();
var tempSum = gl_matrix_1.vec3.create();
var tempVec3 = gl_matrix_1.vec3.create();
var identifyMat3 = gl_matrix_1.mat3.create();
var texCoordMat4 = gl_matrix_1.mat4.create();
var texCoordMat3 = gl_matrix_1.mat3.create();
var ModelRenderer = (function () {
    function ModelRenderer(model) {
        this.vertexBuffer = [];
        this.vertices = []; // Array per geoset for software skinning
        this.texCoordBuffer = [];
        this.indexBuffer = [];
        this.groupBuffer = [];
        this.model = model;
        this.rendererData = {
            model: model,
            frame: 0,
            animation: null,
            animationInfo: null,
            globalSequencesFrames: [],
            rootNode: null,
            nodes: [],
            geosetAnims: [],
            geosetAlpha: [],
            materialLayerTextureID: [],
            teamColor: null,
            cameraPos: null,
            cameraQuat: null,
            textures: {}
        };
        this.rendererData.teamColor = gl_matrix_1.vec3.fromValues(1., 0., 0.);
        this.rendererData.cameraPos = gl_matrix_1.vec3.create();
        this.rendererData.cameraQuat = gl_matrix_1.quat.create();
        this.setSequence(0);
        this.rendererData.rootNode = {
            // todo
            node: {},
            matrix: gl_matrix_1.mat4.create(),
            childs: []
        };
        for (var _i = 0, _a = model.Nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            this.rendererData.nodes[node.ObjectId] = {
                node: node,
                matrix: gl_matrix_1.mat4.create(),
                childs: []
            };
        }
        for (var _b = 0, _c = model.Nodes; _b < _c.length; _b++) {
            var node = _c[_b];
            if (!node.Parent) {
                this.rendererData.rootNode.childs.push(this.rendererData.nodes[node.ObjectId]);
            }
            else {
                this.rendererData.nodes[node.Parent].childs.push(this.rendererData.nodes[node.ObjectId]);
            }
        }
        if (model.GlobalSequences) {
            for (var i = 0; i < model.GlobalSequences.length; ++i) {
                this.rendererData.globalSequencesFrames[i] = 0;
            }
        }
        for (var i = 0; i < model.GeosetAnims.length; ++i) {
            this.rendererData.geosetAnims[model.GeosetAnims[i].GeosetId] = model.GeosetAnims[i];
        }
        for (var i = 0; i < model.Materials.length; ++i) {
            this.rendererData.materialLayerTextureID[i] = new Array(model.Materials[i].Layers.length);
        }
        this.interp = new modelInterp_1.ModelInterp(this.rendererData);
        this.particlesController = new particles_1.ParticlesController(this.interp, this.rendererData);
        this.ribbonsController = new ribbons_1.RibbonsController(this.interp, this.rendererData);
    }
    ModelRenderer.prototype.initGL = function (glContext) {
        gl = glContext;
        // Max bones + MV + P
        this.softwareSkinning = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS) < 4 * (MAX_NODES + 2);
        anisotropicExt = (gl.getExtension('EXT_texture_filter_anisotropic') ||
            gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
            gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic'));
        this.initShaders();
        this.initBuffers();
        particles_1.ParticlesController.initGL(glContext);
        ribbons_1.RibbonsController.initGL(glContext);
    };
    ModelRenderer.prototype.setTextureImage = function (path, img, flags) {
        this.rendererData.textures[path] = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.rendererData.textures[path]);
        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        this.setTextureParameters(flags);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    ModelRenderer.prototype.setTextureImageData = function (path, imageData, flags) {
        this.rendererData.textures[path] = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.rendererData.textures[path]);
        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        for (var i = 0; i < imageData.length; ++i) {
            gl.texImage2D(gl.TEXTURE_2D, i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData[i]);
        }
        this.setTextureParameters(flags);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    ModelRenderer.prototype.setCamera = function (cameraPos, cameraQuat) {
        gl_matrix_1.vec3.copy(this.rendererData.cameraPos, cameraPos);
        gl_matrix_1.quat.copy(this.rendererData.cameraQuat, cameraQuat);
    };
    ModelRenderer.prototype.setSequence = function (index) {
        this.rendererData.animation = index;
        this.rendererData.animationInfo = this.model.Sequences[this.rendererData.animation];
        this.rendererData.frame = this.rendererData.animationInfo.Interval[0];
    };
    ModelRenderer.prototype.setTeamColor = function (color) {
        gl_matrix_1.vec3.copy(this.rendererData.teamColor, color);
    };
    ModelRenderer.prototype.update = function (delta) {
        this.rendererData.frame += delta;
        if (this.rendererData.frame > this.rendererData.animationInfo.Interval[1]) {
            this.rendererData.frame = this.rendererData.animationInfo.Interval[0];
        }
        this.updateGlobalSequences(delta);
        this.updateNode(this.rendererData.rootNode);
        this.particlesController.update(delta);
        this.ribbonsController.update(delta);
        for (var i = 0; i < this.model.Geosets.length; ++i) {
            this.rendererData.geosetAlpha[i] = this.findAlpha(i);
        }
        for (var i = 0; i < this.rendererData.materialLayerTextureID.length; ++i) {
            for (var j = 0; j < this.rendererData.materialLayerTextureID[i].length; ++j) {
                this.updateLayerTextureId(i, j);
            }
        }
    };
    ModelRenderer.prototype.render = function (mvMatrix, pMatrix) {
        gl.useProgram(shaderProgram);
        gl.uniformMatrix4fv(shaderProgramLocations.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgramLocations.mvMatrixUniform, false, mvMatrix);
        gl.enableVertexAttribArray(shaderProgramLocations.vertexPositionAttribute);
        gl.enableVertexAttribArray(shaderProgramLocations.textureCoordAttribute);
        if (!this.softwareSkinning) {
            gl.enableVertexAttribArray(shaderProgramLocations.groupAttribute);
        }
        if (!this.softwareSkinning) {
            for (var j = 0; j < MAX_NODES; ++j) {
                if (this.rendererData.nodes[j]) {
                    gl.uniformMatrix4fv(shaderProgramLocations.nodesMatricesAttributes[j], false, this.rendererData.nodes[j].matrix);
                }
            }
        }
        for (var i = 0; i < this.model.Geosets.length; ++i) {
            if (this.rendererData.geosetAlpha[i] < 1e-6) {
                continue;
            }
            if (this.softwareSkinning) {
                this.generateGeosetVertices(i);
            }
            var materialID = this.model.Geosets[i].MaterialID;
            var material = this.model.Materials[materialID];
            for (var j = 0; j < material.Layers.length; ++j) {
                this.setLayerProps(material.Layers[j], this.rendererData.materialLayerTextureID[materialID][j]);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer[i]);
                gl.vertexAttribPointer(shaderProgramLocations.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer[i]);
                gl.vertexAttribPointer(shaderProgramLocations.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
                if (!this.softwareSkinning) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.groupBuffer[i]);
                    gl.vertexAttribPointer(shaderProgramLocations.groupAttribute, 4, gl.UNSIGNED_BYTE, false, 0, 0);
                }
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer[i]);
                gl.drawElements(gl.TRIANGLES, this.model.Geosets[i].Faces.length, gl.UNSIGNED_SHORT, 0);
            }
        }
        gl.disableVertexAttribArray(shaderProgramLocations.vertexPositionAttribute);
        gl.disableVertexAttribArray(shaderProgramLocations.textureCoordAttribute);
        if (!this.softwareSkinning) {
            gl.disableVertexAttribArray(shaderProgramLocations.groupAttribute);
        }
        this.particlesController.render(mvMatrix, pMatrix);
        this.ribbonsController.render(mvMatrix, pMatrix);
    };
    ModelRenderer.prototype.generateGeosetVertices = function (geosetIndex) {
        var geoset = this.model.Geosets[geosetIndex];
        var buffer = this.vertices[geosetIndex];
        for (var i = 0; i < buffer.length; i += 3) {
            var index = i / 3;
            var group = geoset.Groups[geoset.VertexGroup[index]];
            gl_matrix_1.vec3.set(tempPos, geoset.Vertices[i], geoset.Vertices[i + 1], geoset.Vertices[i + 2]);
            gl_matrix_1.vec3.set(tempSum, 0, 0, 0);
            for (var j = 0; j < group.length; ++j) {
                gl_matrix_1.vec3.add(tempSum, tempSum, gl_matrix_1.vec3.transformMat4(tempVec3, tempPos, this.rendererData.nodes[group[j]].matrix));
            }
            gl_matrix_1.vec3.scale(tempPos, tempSum, 1 / group.length);
            buffer[i] = tempPos[0];
            buffer[i + 1] = tempPos[1];
            buffer[i + 2] = tempPos[2];
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer[geosetIndex]);
        gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.DYNAMIC_DRAW);
    };
    ModelRenderer.prototype.setTextureParameters = function (flags) {
        if (flags & model_1.TextureFlags.WrapWidth) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        }
        if (flags & model_1.TextureFlags.WrapHeight) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        if (anisotropicExt) {
            var max = gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            gl.texParameterf(gl.TEXTURE_2D, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, max);
        }
    };
    ModelRenderer.prototype.updateLayerTextureId = function (materialId, layerId) {
        var TextureID = this.model.Materials[materialId].Layers[layerId].TextureID;
        if (typeof TextureID === 'number') {
            this.rendererData.materialLayerTextureID[materialId][layerId] = TextureID;
        }
        else {
            this.rendererData.materialLayerTextureID[materialId][layerId] = this.interp.num(TextureID);
        }
    };
    ModelRenderer.prototype.initShaders = function () {
        if (shaderProgram) {
            return;
        }
        var vertex = util_1.getShader(gl, this.softwareSkinning ? vertexShaderSoftwareSkinning : vertexShaderHardwareSkinning, gl.VERTEX_SHADER);
        var fragment = util_1.getShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertex);
        gl.attachShader(shaderProgram, fragment);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Could not initialise shaders');
        }
        gl.useProgram(shaderProgram);
        shaderProgramLocations.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
        shaderProgramLocations.textureCoordAttribute = gl.getAttribLocation(shaderProgram, 'aTextureCoord');
        if (!this.softwareSkinning) {
            shaderProgramLocations.groupAttribute = gl.getAttribLocation(shaderProgram, 'aGroup');
        }
        shaderProgramLocations.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
        shaderProgramLocations.mvMatrixUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
        shaderProgramLocations.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
        shaderProgramLocations.replaceableColorUniform = gl.getUniformLocation(shaderProgram, 'uReplaceableColor');
        shaderProgramLocations.replaceableTypeUniform = gl.getUniformLocation(shaderProgram, 'uReplaceableType');
        shaderProgramLocations.discardAlphaLevelUniform = gl.getUniformLocation(shaderProgram, 'uDiscardAlphaLevel');
        shaderProgramLocations.tVertexAnimUniform = gl.getUniformLocation(shaderProgram, 'uTVextexAnim');
        if (!this.softwareSkinning) {
            shaderProgramLocations.nodesMatricesAttributes = [];
            for (var i = 0; i < MAX_NODES; ++i) {
                shaderProgramLocations.nodesMatricesAttributes[i] =
                    gl.getUniformLocation(shaderProgram, "uNodesMatrices[" + i + "]");
            }
        }
    };
    ModelRenderer.prototype.initBuffers = function () {
        for (var i = 0; i < this.model.Geosets.length; ++i) {
            this.vertexBuffer[i] = gl.createBuffer();
            if (this.softwareSkinning) {
                this.vertices[i] = new Float32Array(this.model.Geosets[i].Vertices.length);
            }
            else {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer[i]);
                gl.bufferData(gl.ARRAY_BUFFER, this.model.Geosets[i].Vertices, gl.STATIC_DRAW);
            }
            this.texCoordBuffer[i] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer[i]);
            gl.bufferData(gl.ARRAY_BUFFER, this.model.Geosets[i].TVertices[0], gl.STATIC_DRAW);
            if (!this.softwareSkinning) {
                this.groupBuffer[i] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.groupBuffer[i]);
                var buffer = new Uint8Array(this.model.Geosets[i].VertexGroup.length * 4);
                for (var j = 0; j < buffer.length; j += 4) {
                    var index = j / 4;
                    var group = this.model.Geosets[i].Groups[this.model.Geosets[i].VertexGroup[index]];
                    buffer[j] = group[0];
                    buffer[j + 1] = group.length > 1 ? group[1] : MAX_NODES;
                    buffer[j + 2] = group.length > 2 ? group[2] : MAX_NODES;
                    buffer[j + 3] = group.length > 3 ? group[3] : MAX_NODES;
                }
                gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
            }
            this.indexBuffer[i] = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer[i]);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.model.Geosets[i].Faces, gl.STATIC_DRAW);
        }
    };
    /*private resetGlobalSequences (): void {
        for (let i = 0; i < this.rendererData.globalSequencesFrames.length; ++i) {
            this.rendererData.globalSequencesFrames[i] = 0;
        }
    }*/
    ModelRenderer.prototype.updateGlobalSequences = function (delta) {
        for (var i = 0; i < this.rendererData.globalSequencesFrames.length; ++i) {
            this.rendererData.globalSequencesFrames[i] += delta;
            if (this.rendererData.globalSequencesFrames[i] > this.model.GlobalSequences[i]) {
                this.rendererData.globalSequencesFrames[i] = 0;
            }
        }
    };
    ModelRenderer.prototype.updateNode = function (node) {
        var translationRes = this.interp.vec3(translation, node.node.Translation);
        var rotationRes = this.interp.quat(rotation, node.node.Rotation);
        var scalingRes = this.interp.vec3(scaling, node.node.Scaling);
        if (!translationRes && !rotationRes && !scalingRes) {
            gl_matrix_1.mat4.identity(node.matrix);
        }
        else if (translationRes && !rotationRes && !scalingRes) {
            gl_matrix_1.mat4.fromTranslation(node.matrix, translationRes);
        }
        else if (!translationRes && rotationRes && !scalingRes) {
            util_1.mat4fromRotationOrigin(node.matrix, rotationRes, node.node.PivotPoint);
        }
        else {
            gl_matrix_1.mat4.fromRotationTranslationScaleOrigin(node.matrix, rotationRes || defaultRotation, translationRes || defaultTranslation, scalingRes || defaultScaling, node.node.PivotPoint);
        }
        if (node.node.Parent) {
            gl_matrix_1.mat4.mul(node.matrix, this.rendererData.nodes[node.node.Parent].matrix, node.matrix);
        }
        var billboardedLock = node.node.Flags & model_1.NodeFlags.BillboardedLockX ||
            node.node.Flags & model_1.NodeFlags.BillboardedLockY ||
            node.node.Flags & model_1.NodeFlags.BillboardedLockZ;
        if (node.node.Flags & model_1.NodeFlags.Billboarded) {
            gl_matrix_1.vec3.transformMat4(tempTransformedPivotPoint, node.node.PivotPoint, node.matrix);
            if (node.node.Parent) {
                // cancel parent rotation from PivotPoint
                gl_matrix_1.mat4.getRotation(tempParentRotationQuat, this.rendererData.nodes[node.node.Parent].matrix);
                gl_matrix_1.quat.invert(tempParentRotationQuat, tempParentRotationQuat);
                util_1.mat4fromRotationOrigin(tempParentRotationMat, tempParentRotationQuat, tempTransformedPivotPoint);
                gl_matrix_1.mat4.mul(node.matrix, tempParentRotationMat, node.matrix);
            }
            // rotate to camera
            util_1.mat4fromRotationOrigin(tempCameraMat, this.rendererData.cameraQuat, tempTransformedPivotPoint);
            gl_matrix_1.mat4.mul(node.matrix, tempCameraMat, node.matrix);
        }
        else if (billboardedLock) {
            gl_matrix_1.vec3.transformMat4(tempTransformedPivotPoint, node.node.PivotPoint, node.matrix);
            gl_matrix_1.vec3.copy(tempAxis, node.node.PivotPoint);
            // todo BillboardedLockX ?
            if (node.node.Flags & model_1.NodeFlags.BillboardedLockX) {
                tempAxis[0] += 1;
            }
            else if (node.node.Flags & model_1.NodeFlags.BillboardedLockY) {
                tempAxis[1] += 1;
            }
            else if (node.node.Flags & model_1.NodeFlags.BillboardedLockZ) {
                tempAxis[2] += 1;
            }
            gl_matrix_1.vec3.transformMat4(tempAxis, tempAxis, node.matrix);
            gl_matrix_1.vec3.sub(tempAxis, tempAxis, tempTransformedPivotPoint);
            gl_matrix_1.vec3.set(tempXAxis, 1, 0, 0);
            gl_matrix_1.vec3.add(tempXAxis, tempXAxis, node.node.PivotPoint);
            gl_matrix_1.vec3.transformMat4(tempXAxis, tempXAxis, node.matrix);
            gl_matrix_1.vec3.sub(tempXAxis, tempXAxis, tempTransformedPivotPoint);
            gl_matrix_1.vec3.set(tempCameraVec, -1, 0, 0);
            gl_matrix_1.vec3.transformQuat(tempCameraVec, tempCameraVec, this.rendererData.cameraQuat);
            gl_matrix_1.vec3.cross(tempCross0, tempAxis, tempCameraVec);
            gl_matrix_1.vec3.cross(tempCross1, tempAxis, tempCross0);
            gl_matrix_1.vec3.normalize(tempCross1, tempCross1);
            gl_matrix_1.quat.rotationTo(tempLockQuat, tempXAxis, tempCross1);
            util_1.mat4fromRotationOrigin(tempLockMat, tempLockQuat, tempTransformedPivotPoint);
            gl_matrix_1.mat4.mul(node.matrix, tempLockMat, node.matrix);
        }
        for (var _i = 0, _a = node.childs; _i < _a.length; _i++) {
            var child = _a[_i];
            this.updateNode(child);
        }
    };
    ModelRenderer.prototype.findAlpha = function (geosetId) {
        var geosetAnim = this.rendererData.geosetAnims[geosetId];
        if (!geosetAnim || geosetAnim.Alpha === undefined) {
            return 1;
        }
        if (typeof geosetAnim.Alpha === 'number') {
            return geosetAnim.Alpha;
        }
        var interpRes = this.interp.num(geosetAnim.Alpha);
        if (interpRes === null) {
            return 1;
        }
        return interpRes;
    };
    ModelRenderer.prototype.setLayerProps = function (layer, textureID) {
        var texture = this.model.Textures[textureID];
        if (layer.Shading & model_1.LayerShading.TwoSided) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
        }
        if (layer.FilterMode === model_1.FilterMode.Transparent) {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, 0.75);
        }
        else {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, 0.);
        }
        if (layer.FilterMode === model_1.FilterMode.None) {
            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(true);
        }
        else if (layer.FilterMode === model_1.FilterMode.Transparent) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(true);
        }
        else if (layer.FilterMode === model_1.FilterMode.Blend) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.Additive) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_COLOR, gl.ONE);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.AddAlpha) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.Modulate) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.ONE);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.Modulate2x) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.DST_COLOR, gl.SRC_COLOR, gl.ZERO, gl.ONE);
            gl.depthMask(false);
        }
        if (texture.Image) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.rendererData.textures[texture.Image]);
            gl.uniform1i(shaderProgramLocations.samplerUniform, 0);
            gl.uniform1f(shaderProgramLocations.replaceableTypeUniform, 0);
        }
        else if (texture.ReplaceableId === 1 || texture.ReplaceableId === 2) {
            gl.uniform3fv(shaderProgramLocations.replaceableColorUniform, this.rendererData.teamColor);
            gl.uniform1f(shaderProgramLocations.replaceableTypeUniform, texture.ReplaceableId);
        }
        if (layer.Shading & model_1.LayerShading.NoDepthTest) {
            gl.disable(gl.DEPTH_TEST);
        }
        if (layer.Shading & model_1.LayerShading.NoDepthSet) {
            gl.depthMask(false);
        }
        if (typeof layer.TVertexAnimId === 'number') {
            var anim = this.rendererData.model.TextureAnims[layer.TVertexAnimId];
            var translationRes = this.interp.vec3(translation, anim.Translation);
            var rotationRes = this.interp.quat(rotation, anim.Rotation);
            var scalingRes = this.interp.vec3(scaling, anim.Scaling);
            gl_matrix_1.mat4.fromRotationTranslationScale(texCoordMat4, rotationRes || defaultRotation, translationRes || defaultTranslation, scalingRes || defaultScaling);
            gl_matrix_1.mat3.set(texCoordMat3, texCoordMat4[0], texCoordMat4[1], 0, texCoordMat4[4], texCoordMat4[5], 0, texCoordMat4[12], texCoordMat4[13], 0);
            gl.uniformMatrix3fv(shaderProgramLocations.tVertexAnimUniform, false, texCoordMat3);
        }
        else {
            gl.uniformMatrix3fv(shaderProgramLocations.tVertexAnimUniform, false, identifyMat3);
        }
    };
    return ModelRenderer;
}());
exports.ModelRenderer = ModelRenderer;
//# sourceMappingURL=modelRenderer.js.map
},{"../model":7,"./modelInterp":19,"./particles":21,"./ribbons":22,"./util":23,"gl-matrix":8}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = require("../model");
var gl_matrix_1 = require("gl-matrix");
var modelInterp_1 = require("./modelInterp");
var util_1 = require("./util");
var interp_1 = require("./interp");
var gl;
var shaderProgram;
var shaderProgramLocations = {};
var particleStorage = [];
var rotateCenter = gl_matrix_1.vec3.fromValues(0, 0, 0);
var firstColor = gl_matrix_1.vec4.create();
var secondColor = gl_matrix_1.vec4.create();
var color = gl_matrix_1.vec4.create();
var tailPos = gl_matrix_1.vec3.create();
var tailCross = gl_matrix_1.vec3.create();
var vertexShader = "\n    attribute vec3 aVertexPosition;\n    attribute vec2 aTextureCoord;\n    attribute vec4 aColor;\n\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n\n    varying vec2 vTextureCoord;\n    varying vec4 vColor;\n\n    void main(void) {\n        vec4 position = vec4(aVertexPosition, 1.0);\n        gl_Position = uPMatrix * uMVMatrix * position;\n        vTextureCoord = aTextureCoord;\n        vColor = aColor;\n    }\n";
var fragmentShader = "\n    precision mediump float;\n\n    varying vec2 vTextureCoord;\n    varying vec4 vColor;\n\n    uniform sampler2D uSampler;\n    uniform vec3 uReplaceableColor;\n    uniform float uReplaceableType;\n    uniform float uDiscardAlphaLevel;\n\n    float hypot (vec2 z) {\n        float t;\n        float x = abs(z.x);\n        float y = abs(z.y);\n        t = min(x, y);\n        x = max(x, y);\n        t = t / x;\n        return (z.x == 0.0 && z.y == 0.0) ? 0.0 : x * sqrt(1.0 + t * t);\n    }\n\n    void main(void) {\n        vec2 coords = vec2(vTextureCoord.s, vTextureCoord.t);\n        if (uReplaceableType == 0.) {\n            gl_FragColor = texture2D(uSampler, coords);\n        } else if (uReplaceableType == 1.) {\n            gl_FragColor = vec4(uReplaceableColor, 1.0);\n        } else if (uReplaceableType == 2.) {\n            float dist = hypot(coords - vec2(0.5, 0.5)) * 2.;\n            float truncateDist = clamp(1. - dist * 1.4, 0., 1.);\n            float alpha = sin(truncateDist);\n            gl_FragColor = vec4(uReplaceableColor * alpha, 1.0);\n        }\n        gl_FragColor *= vColor;\n        \n        if (gl_FragColor[3] < uDiscardAlphaLevel) {\n            discard;\n        }\n    }\n";
var DISCARD_ALPHA_KEY_LEVEL = 0.83;
var DISCARD_MODULATE_LEVEL = 0.01;
var ParticlesController = (function () {
    function ParticlesController(interp, rendererData) {
        this.interp = interp;
        this.rendererData = rendererData;
        this.emitters = [];
        if (rendererData.model.ParticleEmitters2.length) {
            this.particleBaseVectors = [
                gl_matrix_1.vec3.create(),
                gl_matrix_1.vec3.create(),
                gl_matrix_1.vec3.create(),
                gl_matrix_1.vec3.create()
            ];
            for (var _i = 0, _a = rendererData.model.ParticleEmitters2; _i < _a.length; _i++) {
                var particleEmitter = _a[_i];
                var emitter = {
                    emission: 0,
                    squirtFrame: 0,
                    particles: [],
                    props: particleEmitter,
                    capacity: 0,
                    baseCapacity: 0,
                    type: particleEmitter.FrameFlags,
                    tailVertices: null,
                    tailVertexBuffer: null,
                    headVertices: null,
                    headVertexBuffer: null,
                    tailTexCoords: null,
                    tailTexCoordBuffer: null,
                    headTexCoords: null,
                    headTexCoordBuffer: null,
                    colors: null,
                    colorBuffer: null,
                    indices: null,
                    indexBuffer: null
                };
                emitter.baseCapacity = Math.ceil(modelInterp_1.ModelInterp.maxAnimVectorVal(emitter.props.EmissionRate) * emitter.props.LifeSpan);
                this.emitters.push(emitter);
            }
        }
    }
    ParticlesController.initGL = function (glContext) {
        gl = glContext;
        ParticlesController.initShaders();
    };
    ParticlesController.initShaders = function () {
        var vertex = util_1.getShader(gl, vertexShader, gl.VERTEX_SHADER);
        var fragment = util_1.getShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertex);
        gl.attachShader(shaderProgram, fragment);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Could not initialise shaders');
        }
        gl.useProgram(shaderProgram);
        shaderProgramLocations.vertexPositionAttribute =
            gl.getAttribLocation(shaderProgram, 'aVertexPosition');
        shaderProgramLocations.textureCoordAttribute =
            gl.getAttribLocation(shaderProgram, 'aTextureCoord');
        shaderProgramLocations.colorAttribute =
            gl.getAttribLocation(shaderProgram, 'aColor');
        shaderProgramLocations.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
        shaderProgramLocations.mvMatrixUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
        shaderProgramLocations.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
        shaderProgramLocations.replaceableColorUniform =
            gl.getUniformLocation(shaderProgram, 'uReplaceableColor');
        shaderProgramLocations.replaceableTypeUniform =
            gl.getUniformLocation(shaderProgram, 'uReplaceableType');
        shaderProgramLocations.discardAlphaLevelUniform =
            gl.getUniformLocation(shaderProgram, 'uDiscardAlphaLevel');
    };
    ParticlesController.updateParticle = function (particle, delta) {
        delta /= 1000;
        particle.lifeSpan -= delta;
        if (particle.lifeSpan <= 0) {
            return;
        }
        particle.speed[2] -= particle.gravity * delta;
        particle.pos[0] += particle.speed[0] * delta;
        particle.pos[1] += particle.speed[1] * delta;
        particle.pos[2] += particle.speed[2] * delta;
    };
    ParticlesController.resizeEmitterBuffers = function (emitter, size) {
        if (size <= emitter.capacity) {
            return;
        }
        size = Math.max(size, emitter.baseCapacity);
        var tailVertices;
        var headVertices;
        var tailTexCoords;
        var headTexCoords;
        if (emitter.type & model_1.ParticleEmitter2FramesFlags.Tail) {
            tailVertices = new Float32Array(size * 4 * 3); // 4 vertices * xyz
            tailTexCoords = new Float32Array(size * 4 * 2); // 4 vertices * xy
        }
        if (emitter.type & model_1.ParticleEmitter2FramesFlags.Head) {
            headVertices = new Float32Array(size * 4 * 3); // 4 vertices * xyz
            headTexCoords = new Float32Array(size * 4 * 2); // 4 vertices * xy
        }
        var colors = new Float32Array(size * 4 * 4); // 4 vertices * rgba
        var indices = new Uint16Array(size * 6); // 4 vertices * 2 triangles
        if (emitter.capacity) {
            indices.set(emitter.indices);
        }
        for (var i = emitter.capacity; i < size; ++i) {
            indices[i * 6] = i * 4;
            indices[i * 6 + 1] = i * 4 + 1;
            indices[i * 6 + 2] = i * 4 + 2;
            indices[i * 6 + 3] = i * 4 + 2;
            indices[i * 6 + 4] = i * 4 + 1;
            indices[i * 6 + 5] = i * 4 + 3;
        }
        if (tailVertices) {
            emitter.tailVertices = tailVertices;
            emitter.tailTexCoords = tailTexCoords;
        }
        if (headVertices) {
            emitter.headVertices = headVertices;
            emitter.headTexCoords = headTexCoords;
        }
        emitter.colors = colors;
        emitter.indices = indices;
        emitter.capacity = size;
        if (!emitter.indexBuffer) {
            if (emitter.type & model_1.ParticleEmitter2FramesFlags.Tail) {
                emitter.tailVertexBuffer = gl.createBuffer();
                emitter.tailTexCoordBuffer = gl.createBuffer();
            }
            if (emitter.type & model_1.ParticleEmitter2FramesFlags.Head) {
                emitter.headVertexBuffer = gl.createBuffer();
                emitter.headTexCoordBuffer = gl.createBuffer();
            }
            emitter.colorBuffer = gl.createBuffer();
            emitter.indexBuffer = gl.createBuffer();
        }
    };
    ParticlesController.prototype.update = function (delta) {
        for (var _i = 0, _a = this.emitters; _i < _a.length; _i++) {
            var emitter = _a[_i];
            this.updateEmitter(emitter, delta);
        }
    };
    ParticlesController.prototype.render = function (mvMatrix, pMatrix) {
        gl.enable(gl.CULL_FACE);
        gl.useProgram(shaderProgram);
        gl.uniformMatrix4fv(shaderProgramLocations.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgramLocations.mvMatrixUniform, false, mvMatrix);
        gl.enableVertexAttribArray(shaderProgramLocations.vertexPositionAttribute);
        gl.enableVertexAttribArray(shaderProgramLocations.textureCoordAttribute);
        gl.enableVertexAttribArray(shaderProgramLocations.colorAttribute);
        for (var _i = 0, _a = this.emitters; _i < _a.length; _i++) {
            var emitter = _a[_i];
            if (!emitter.particles.length) {
                continue;
            }
            this.setLayerProps(emitter);
            this.setGeneralBuffers(emitter);
            if (emitter.type & model_1.ParticleEmitter2FramesFlags.Tail) {
                this.renderEmitterType(emitter, model_1.ParticleEmitter2FramesFlags.Tail);
            }
            if (emitter.type & model_1.ParticleEmitter2FramesFlags.Head) {
                this.renderEmitterType(emitter, model_1.ParticleEmitter2FramesFlags.Head);
            }
        }
        gl.disableVertexAttribArray(shaderProgramLocations.vertexPositionAttribute);
        gl.disableVertexAttribArray(shaderProgramLocations.textureCoordAttribute);
        gl.disableVertexAttribArray(shaderProgramLocations.colorAttribute);
    };
    ParticlesController.prototype.updateEmitter = function (emitter, delta) {
        var visibility = this.interp.animVectorVal(emitter.props.Visibility, 1);
        if (visibility > 0) {
            if (emitter.props.Squirt && typeof emitter.props.EmissionRate !== 'number') {
                var interp = this.interp.findKeyframes(emitter.props.EmissionRate);
                if (interp && interp.left && interp.left.Frame !== emitter.squirtFrame) {
                    emitter.squirtFrame = interp.left.Frame;
                    if (interp.left.Vector[0] > 0) {
                        emitter.emission += interp.left.Vector[0] * 1000;
                    }
                }
            }
            else {
                var emissionRate = this.interp.animVectorVal(emitter.props.EmissionRate, 0);
                emitter.emission += emissionRate * delta;
            }
            while (emitter.emission >= 1000) {
                emitter.emission -= 1000;
                emitter.particles.push(this.createParticle(emitter, this.rendererData.nodes[emitter.props.ObjectId].matrix));
            }
        }
        if (emitter.particles.length) {
            var updatedParticles = [];
            for (var _i = 0, _a = emitter.particles; _i < _a.length; _i++) {
                var particle = _a[_i];
                ParticlesController.updateParticle(particle, delta);
                if (particle.lifeSpan > 0) {
                    updatedParticles.push(particle);
                }
                else {
                    particleStorage.push(particle);
                }
            }
            emitter.particles = updatedParticles;
            if (emitter.type & model_1.ParticleEmitter2FramesFlags.Head) {
                if (emitter.props.Flags & model_1.ParticleEmitter2Flags.XYQuad) {
                    gl_matrix_1.vec3.set(this.particleBaseVectors[0], -1, 1, 0);
                    gl_matrix_1.vec3.set(this.particleBaseVectors[1], -1, -1, 0);
                    gl_matrix_1.vec3.set(this.particleBaseVectors[2], 1, 1, 0);
                    gl_matrix_1.vec3.set(this.particleBaseVectors[3], 1, -1, 0);
                }
                else {
                    gl_matrix_1.vec3.set(this.particleBaseVectors[0], 0, -1, 1);
                    gl_matrix_1.vec3.set(this.particleBaseVectors[1], 0, -1, -1);
                    gl_matrix_1.vec3.set(this.particleBaseVectors[2], 0, 1, 1);
                    gl_matrix_1.vec3.set(this.particleBaseVectors[3], 0, 1, -1);
                    for (var i = 0; i < 4; ++i) {
                        gl_matrix_1.vec3.transformQuat(this.particleBaseVectors[i], this.particleBaseVectors[i], this.rendererData.cameraQuat);
                    }
                }
            }
            ParticlesController.resizeEmitterBuffers(emitter, emitter.particles.length);
            for (var i = 0; i < emitter.particles.length; ++i) {
                this.updateParticleBuffers(emitter.particles[i], i, emitter);
            }
        }
    };
    ParticlesController.prototype.createParticle = function (emitter, emitterMatrix) {
        var particle;
        if (particleStorage.length) {
            particle = particleStorage.pop();
        }
        else {
            particle = {
                emitter: null,
                pos: gl_matrix_1.vec3.create(),
                angle: 0,
                speed: gl_matrix_1.vec3.create(),
                gravity: null,
                lifeSpan: null
            };
        }
        var width = this.interp.animVectorVal(emitter.props.Width, 0);
        var length = this.interp.animVectorVal(emitter.props.Length, 0);
        var speedScale = this.interp.animVectorVal(emitter.props.Speed, 0);
        var variation = this.interp.animVectorVal(emitter.props.Variation, 0);
        var latitude = util_1.degToRad(this.interp.animVectorVal(emitter.props.Latitude, 0));
        particle.emitter = emitter;
        particle.pos[0] = emitter.props.PivotPoint[0] + util_1.rand(-width, width);
        particle.pos[1] = emitter.props.PivotPoint[1] + util_1.rand(-length, length);
        particle.pos[2] = emitter.props.PivotPoint[2];
        gl_matrix_1.vec3.transformMat4(particle.pos, particle.pos, emitterMatrix);
        if (variation > 0) {
            speedScale *= 1 + util_1.rand(-variation, variation);
        }
        gl_matrix_1.vec3.set(particle.speed, 0, 0, speedScale);
        particle.angle = util_1.rand(0, Math.PI * 2);
        gl_matrix_1.vec3.rotateY(particle.speed, particle.speed, rotateCenter, util_1.rand(0, latitude));
        gl_matrix_1.vec3.rotateZ(particle.speed, particle.speed, rotateCenter, particle.angle);
        if (emitter.props.Flags & model_1.ParticleEmitter2Flags.LineEmitter) {
            particle.speed[0] = 0;
        }
        gl_matrix_1.vec3.transformMat4(particle.speed, particle.speed, emitterMatrix);
        // minus translation of emitterMatrix
        particle.speed[0] -= emitterMatrix[12];
        particle.speed[1] -= emitterMatrix[13];
        particle.speed[2] -= emitterMatrix[14];
        particle.gravity = this.interp.animVectorVal(emitter.props.Gravity, 0);
        particle.lifeSpan = emitter.props.LifeSpan;
        return particle;
    };
    ParticlesController.prototype.updateParticleBuffers = function (particle, index, emitter) {
        var globalT = 1 - particle.lifeSpan / emitter.props.LifeSpan;
        var firstHalf = globalT < emitter.props.Time;
        var t;
        if (firstHalf) {
            t = globalT / emitter.props.Time;
        }
        else {
            t = (globalT - emitter.props.Time) / (1 - emitter.props.Time);
        }
        this.updateParticleVertices(particle, index, emitter, firstHalf, t);
        this.updateParticleTexCoords(index, emitter, firstHalf, t);
        this.updateParticleColor(index, emitter, firstHalf, t);
    };
    ParticlesController.prototype.updateParticleVertices = function (particle, index, emitter, firstHalf, t) {
        var firstScale;
        var secondScale;
        var scale;
        if (firstHalf) {
            firstScale = emitter.props.ParticleScaling[0];
            secondScale = emitter.props.ParticleScaling[1];
        }
        else {
            firstScale = emitter.props.ParticleScaling[1];
            secondScale = emitter.props.ParticleScaling[2];
        }
        scale = interp_1.lerp(firstScale, secondScale, t);
        if (emitter.type & model_1.ParticleEmitter2FramesFlags.Head) {
            for (var i = 0; i < 4; ++i) {
                emitter.headVertices[index * 12 + i * 3] = this.particleBaseVectors[i][0] * scale;
                emitter.headVertices[index * 12 + i * 3 + 1] = this.particleBaseVectors[i][1] * scale;
                emitter.headVertices[index * 12 + i * 3 + 2] = this.particleBaseVectors[i][2] * scale;
                if (emitter.props.Flags & model_1.ParticleEmitter2Flags.XYQuad) {
                    var x = emitter.headVertices[index * 12 + i * 3];
                    var y = emitter.headVertices[index * 12 + i * 3 + 1];
                    emitter.headVertices[index * 12 + i * 3] = x * Math.cos(particle.angle) -
                        y * Math.sin(particle.angle);
                    emitter.headVertices[index * 12 + i * 3 + 1] = x * Math.sin(particle.angle) +
                        y * Math.cos(particle.angle);
                }
            }
        }
        if (emitter.type & model_1.ParticleEmitter2FramesFlags.Tail) {
            tailPos[0] = -particle.speed[0] * emitter.props.TailLength;
            tailPos[1] = -particle.speed[1] * emitter.props.TailLength;
            tailPos[2] = -particle.speed[2] * emitter.props.TailLength;
            gl_matrix_1.vec3.cross(tailCross, particle.speed, this.rendererData.cameraPos);
            gl_matrix_1.vec3.normalize(tailCross, tailCross);
            gl_matrix_1.vec3.scale(tailCross, tailCross, scale);
            emitter.tailVertices[index * 12] = tailCross[0];
            emitter.tailVertices[index * 12 + 1] = tailCross[1];
            emitter.tailVertices[index * 12 + 2] = tailCross[2];
            emitter.tailVertices[index * 12 + 3] = -tailCross[0];
            emitter.tailVertices[index * 12 + 3 + 1] = -tailCross[1];
            emitter.tailVertices[index * 12 + 3 + 2] = -tailCross[2];
            emitter.tailVertices[index * 12 + 2 * 3] = tailCross[0] + tailPos[0];
            emitter.tailVertices[index * 12 + 2 * 3 + 1] = tailCross[1] + tailPos[1];
            emitter.tailVertices[index * 12 + 2 * 3 + 2] = tailCross[2] + tailPos[2];
            emitter.tailVertices[index * 12 + 3 * 3] = -tailCross[0] + tailPos[0];
            emitter.tailVertices[index * 12 + 3 * 3 + 1] = -tailCross[1] + tailPos[1];
            emitter.tailVertices[index * 12 + 3 * 3 + 2] = -tailCross[2] + tailPos[2];
        }
        for (var i = 0; i < 4; ++i) {
            if (emitter.headVertices) {
                emitter.headVertices[index * 12 + i * 3] += particle.pos[0];
                emitter.headVertices[index * 12 + i * 3 + 1] += particle.pos[1];
                emitter.headVertices[index * 12 + i * 3 + 2] += particle.pos[2];
            }
            if (emitter.tailVertices) {
                emitter.tailVertices[index * 12 + i * 3] += particle.pos[0];
                emitter.tailVertices[index * 12 + i * 3 + 1] += particle.pos[1];
                emitter.tailVertices[index * 12 + i * 3 + 2] += particle.pos[2];
            }
        }
    };
    ParticlesController.prototype.updateParticleTexCoords = function (index, emitter, firstHalf, t) {
        if (emitter.type & model_1.ParticleEmitter2FramesFlags.Head) {
            this.updateParticleTexCoordsByType(index, emitter, firstHalf, t, model_1.ParticleEmitter2FramesFlags.Head);
        }
        if (emitter.type & model_1.ParticleEmitter2FramesFlags.Tail) {
            this.updateParticleTexCoordsByType(index, emitter, firstHalf, t, model_1.ParticleEmitter2FramesFlags.Tail);
        }
    };
    ParticlesController.prototype.updateParticleTexCoordsByType = function (index, emitter, firstHalf, t, type) {
        var uvAnim;
        var texCoords;
        if (type === model_1.ParticleEmitter2FramesFlags.Tail) {
            uvAnim = firstHalf ? emitter.props.TailUVAnim : emitter.props.TailDecayUVAnim;
            texCoords = emitter.tailTexCoords;
        }
        else {
            uvAnim = firstHalf ? emitter.props.LifeSpanUVAnim : emitter.props.DecayUVAnim;
            texCoords = emitter.headTexCoords;
        }
        var firstFrame = uvAnim[0];
        var secondFrame = uvAnim[1];
        var frame = Math.round(interp_1.lerp(firstFrame, secondFrame, t));
        var texCoordX = frame % emitter.props.Columns;
        var texCoordY = Math.floor(frame / emitter.props.Rows);
        var cellWidth = 1 / emitter.props.Columns;
        var cellHeight = 1 / emitter.props.Rows;
        texCoords[index * 8] = texCoordX * cellWidth;
        texCoords[index * 8 + 1] = texCoordY * cellHeight;
        texCoords[index * 8 + 2] = texCoordX * cellWidth;
        texCoords[index * 8 + 3] = (1 + texCoordY) * cellHeight;
        texCoords[index * 8 + 4] = (1 + texCoordX) * cellWidth;
        texCoords[index * 8 + 5] = texCoordY * cellHeight;
        texCoords[index * 8 + 6] = (1 + texCoordX) * cellWidth;
        texCoords[index * 8 + 7] = (1 + texCoordY) * cellHeight;
    };
    ParticlesController.prototype.updateParticleColor = function (index, emitter, firstHalf, t) {
        if (firstHalf) {
            firstColor[0] = emitter.props.SegmentColor[0][0];
            firstColor[1] = emitter.props.SegmentColor[0][1];
            firstColor[2] = emitter.props.SegmentColor[0][2];
            firstColor[3] = emitter.props.Alpha[0] / 255;
            secondColor[0] = emitter.props.SegmentColor[1][0];
            secondColor[1] = emitter.props.SegmentColor[1][1];
            secondColor[2] = emitter.props.SegmentColor[1][2];
            secondColor[3] = emitter.props.Alpha[1] / 255;
        }
        else {
            firstColor[0] = emitter.props.SegmentColor[1][0];
            firstColor[1] = emitter.props.SegmentColor[1][1];
            firstColor[2] = emitter.props.SegmentColor[1][2];
            firstColor[3] = emitter.props.Alpha[1] / 255;
            secondColor[0] = emitter.props.SegmentColor[2][0];
            secondColor[1] = emitter.props.SegmentColor[2][1];
            secondColor[2] = emitter.props.SegmentColor[2][2];
            secondColor[3] = emitter.props.Alpha[2] / 255;
        }
        gl_matrix_1.vec4.lerp(color, firstColor, secondColor, t);
        for (var i = 0; i < 4; ++i) {
            emitter.colors[index * 16 + i * 4] = color[0];
            emitter.colors[index * 16 + i * 4 + 1] = color[1];
            emitter.colors[index * 16 + i * 4 + 2] = color[2];
            emitter.colors[index * 16 + i * 4 + 3] = color[3];
        }
    };
    ParticlesController.prototype.setLayerProps = function (emitter) {
        if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.AlphaKey) {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, DISCARD_ALPHA_KEY_LEVEL);
        }
        else if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.Modulate ||
            emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.Modulate2x) {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, DISCARD_MODULATE_LEVEL);
        }
        else {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, 0.);
        }
        if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.Blend) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(false);
        }
        else if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.Additive) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.depthMask(false);
        }
        else if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.AlphaKey) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.depthMask(false);
        }
        else if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.Modulate) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.ONE);
            gl.depthMask(false);
        }
        else if (emitter.props.FilterMode === model_1.ParticleEmitter2FilterMode.Modulate2x) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.DST_COLOR, gl.SRC_COLOR, gl.ZERO, gl.ONE);
            gl.depthMask(false);
        }
        var texture = this.rendererData.model.Textures[emitter.props.TextureID];
        if (texture.Image) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.rendererData.textures[texture.Image]);
            gl.uniform1i(shaderProgramLocations.samplerUniform, 0);
            gl.uniform1f(shaderProgramLocations.replaceableTypeUniform, 0);
        }
        else if (texture.ReplaceableId === 1 || texture.ReplaceableId === 2) {
            gl.uniform3fv(shaderProgramLocations.replaceableColorUniform, this.rendererData.teamColor);
            gl.uniform1f(shaderProgramLocations.replaceableTypeUniform, texture.ReplaceableId);
        }
    };
    ParticlesController.prototype.setGeneralBuffers = function (emitter) {
        gl.bindBuffer(gl.ARRAY_BUFFER, emitter.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, emitter.colors, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(shaderProgramLocations.colorAttribute, 4, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, emitter.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, emitter.indices, gl.DYNAMIC_DRAW);
    };
    ParticlesController.prototype.renderEmitterType = function (emitter, type) {
        if (type === model_1.ParticleEmitter2FramesFlags.Tail) {
            gl.bindBuffer(gl.ARRAY_BUFFER, emitter.tailTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, emitter.tailTexCoords, gl.DYNAMIC_DRAW);
        }
        else {
            gl.bindBuffer(gl.ARRAY_BUFFER, emitter.headTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, emitter.headTexCoords, gl.DYNAMIC_DRAW);
        }
        gl.vertexAttribPointer(shaderProgramLocations.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
        if (type === model_1.ParticleEmitter2FramesFlags.Tail) {
            gl.bindBuffer(gl.ARRAY_BUFFER, emitter.tailVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, emitter.tailVertices, gl.DYNAMIC_DRAW);
        }
        else {
            gl.bindBuffer(gl.ARRAY_BUFFER, emitter.headVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, emitter.headVertices, gl.DYNAMIC_DRAW);
        }
        gl.vertexAttribPointer(shaderProgramLocations.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
        gl.drawElements(gl.TRIANGLES, emitter.particles.length * 6, gl.UNSIGNED_SHORT, 0);
    };
    return ParticlesController;
}());
exports.ParticlesController = ParticlesController;
//# sourceMappingURL=particles.js.map
},{"../model":7,"./interp":18,"./modelInterp":19,"./util":23,"gl-matrix":8}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var modelInterp_1 = require("./modelInterp");
var model_1 = require("../model");
var gl_matrix_1 = require("gl-matrix");
var gl;
var shaderProgram;
var shaderProgramLocations = {};
var vertexShader = "\n    attribute vec3 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n\n    varying vec2 vTextureCoord;\n\n    void main(void) {\n        vec4 position = vec4(aVertexPosition, 1.0);\n        gl_Position = uPMatrix * uMVMatrix * position;\n        vTextureCoord = aTextureCoord;\n    }\n";
var fragmentShader = "\n    precision mediump float;\n\n    varying vec2 vTextureCoord;\n\n    uniform sampler2D uSampler;\n    uniform vec3 uReplaceableColor;\n    uniform float uReplaceableType;\n    uniform float uDiscardAlphaLevel;\n    uniform vec4 uColor;\n\n    float hypot (vec2 z) {\n        float t;\n        float x = abs(z.x);\n        float y = abs(z.y);\n        t = min(x, y);\n        x = max(x, y);\n        t = t / x;\n        return (z.x == 0.0 && z.y == 0.0) ? 0.0 : x * sqrt(1.0 + t * t);\n    }\n\n    void main(void) {\n        vec2 coords = vec2(vTextureCoord.s, vTextureCoord.t);\n        if (uReplaceableType == 0.) {\n            gl_FragColor = texture2D(uSampler, coords);\n        } else if (uReplaceableType == 1.) {\n            gl_FragColor = vec4(uReplaceableColor, 1.0);\n        } else if (uReplaceableType == 2.) {\n            float dist = hypot(coords - vec2(0.5, 0.5)) * 2.;\n            float truncateDist = clamp(1. - dist * 1.4, 0., 1.);\n            float alpha = sin(truncateDist);\n            gl_FragColor = vec4(uReplaceableColor * alpha, 1.0);\n        }\n        gl_FragColor *= uColor;\n        \n        if (gl_FragColor[3] < uDiscardAlphaLevel) {\n            discard;\n        }\n    }\n";
var RibbonsController = (function () {
    function RibbonsController(interp, rendererData) {
        this.interp = interp;
        this.rendererData = rendererData;
        this.emitters = [];
        if (rendererData.model.RibbonEmitters.length) {
            for (var _i = 0, _a = rendererData.model.RibbonEmitters; _i < _a.length; _i++) {
                var ribbonEmitter = _a[_i];
                var emitter = {
                    emission: 0,
                    props: ribbonEmitter,
                    capacity: 0,
                    baseCapacity: 0,
                    creationTimes: [],
                    vertices: null,
                    vertexBuffer: null,
                    texCoords: null,
                    texCoordBuffer: null
                };
                emitter.baseCapacity = Math.ceil(modelInterp_1.ModelInterp.maxAnimVectorVal(emitter.props.EmissionRate) * emitter.props.LifeSpan) + 1; // extra points
                this.emitters.push(emitter);
            }
        }
    }
    RibbonsController.initGL = function (glContext) {
        gl = glContext;
        RibbonsController.initShaders();
    };
    RibbonsController.initShaders = function () {
        var vertex = util_1.getShader(gl, vertexShader, gl.VERTEX_SHADER);
        var fragment = util_1.getShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertex);
        gl.attachShader(shaderProgram, fragment);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Could not initialise shaders');
        }
        gl.useProgram(shaderProgram);
        shaderProgramLocations.vertexPositionAttribute =
            gl.getAttribLocation(shaderProgram, 'aVertexPosition');
        shaderProgramLocations.textureCoordAttribute =
            gl.getAttribLocation(shaderProgram, 'aTextureCoord');
        shaderProgramLocations.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
        shaderProgramLocations.mvMatrixUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
        shaderProgramLocations.samplerUniform = gl.getUniformLocation(shaderProgram, 'uSampler');
        shaderProgramLocations.replaceableColorUniform =
            gl.getUniformLocation(shaderProgram, 'uReplaceableColor');
        shaderProgramLocations.replaceableTypeUniform =
            gl.getUniformLocation(shaderProgram, 'uReplaceableType');
        shaderProgramLocations.discardAlphaLevelUniform =
            gl.getUniformLocation(shaderProgram, 'uDiscardAlphaLevel');
        shaderProgramLocations.colorUniform =
            gl.getUniformLocation(shaderProgram, 'uColor');
    };
    RibbonsController.resizeEmitterBuffers = function (emitter, size) {
        if (size <= emitter.capacity) {
            return;
        }
        size = Math.min(size, emitter.baseCapacity);
        var vertices = new Float32Array(size * 2 * 3); // 2 vertices * xyz
        var texCoords = new Float32Array(size * 2 * 2); // 2 vertices * xy
        if (emitter.vertices) {
            vertices.set(emitter.vertices);
        }
        emitter.vertices = vertices;
        emitter.texCoords = texCoords;
        emitter.capacity = size;
        if (!emitter.vertexBuffer) {
            emitter.vertexBuffer = gl.createBuffer();
            emitter.texCoordBuffer = gl.createBuffer();
        }
    };
    RibbonsController.prototype.update = function (delta) {
        for (var _i = 0, _a = this.emitters; _i < _a.length; _i++) {
            var emitter = _a[_i];
            this.updateEmitter(emitter, delta);
        }
    };
    RibbonsController.prototype.render = function (mvMatrix, pMatrix) {
        gl.useProgram(shaderProgram);
        gl.uniformMatrix4fv(shaderProgramLocations.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgramLocations.mvMatrixUniform, false, mvMatrix);
        gl.enableVertexAttribArray(shaderProgramLocations.vertexPositionAttribute);
        gl.enableVertexAttribArray(shaderProgramLocations.textureCoordAttribute);
        for (var _i = 0, _a = this.emitters; _i < _a.length; _i++) {
            var emitter = _a[_i];
            if (emitter.creationTimes.length < 2) {
                continue;
            }
            gl.uniform4f(shaderProgramLocations.colorUniform, emitter.props.Color[0], emitter.props.Color[1], emitter.props.Color[2], this.interp.animVectorVal(emitter.props.Alpha, 1));
            this.setGeneralBuffers(emitter);
            var materialID = emitter.props.MaterialID;
            var material = this.rendererData.model.Materials[materialID];
            for (var j = 0; j < material.Layers.length; ++j) {
                this.setLayerProps(material.Layers[j], this.rendererData.materialLayerTextureID[materialID][j]);
                this.renderEmitter(emitter);
            }
        }
        gl.disableVertexAttribArray(shaderProgramLocations.vertexPositionAttribute);
        gl.disableVertexAttribArray(shaderProgramLocations.textureCoordAttribute);
    };
    RibbonsController.prototype.updateEmitter = function (emitter, delta) {
        var now = Date.now();
        var visibility = this.interp.animVectorVal(emitter.props.Visibility, 1);
        if (visibility > 0) {
            var emissionRate = emitter.props.EmissionRate;
            emitter.emission += emissionRate * delta;
            if (emitter.emission >= 1000) {
                // only once per tick
                emitter.emission = emitter.emission % 1000;
                if (emitter.creationTimes.length + 1 > emitter.capacity) {
                    RibbonsController.resizeEmitterBuffers(emitter, emitter.creationTimes.length + 1);
                }
                this.appendVertices(emitter);
                emitter.creationTimes.push(now);
            }
        }
        if (emitter.creationTimes.length) {
            while (emitter.creationTimes[0] + emitter.props.LifeSpan * 1000 < now) {
                emitter.creationTimes.shift();
                for (var i = 0; i + 6 + 5 < emitter.vertices.length; i += 6) {
                    emitter.vertices[i] = emitter.vertices[i + 6];
                    emitter.vertices[i + 1] = emitter.vertices[i + 7];
                    emitter.vertices[i + 2] = emitter.vertices[i + 8];
                    emitter.vertices[i + 3] = emitter.vertices[i + 9];
                    emitter.vertices[i + 4] = emitter.vertices[i + 10];
                    emitter.vertices[i + 5] = emitter.vertices[i + 11];
                }
            }
        }
        // still exists
        if (emitter.creationTimes.length) {
            this.updateEmitterTexCoords(emitter, now);
        }
    };
    RibbonsController.prototype.appendVertices = function (emitter) {
        var first = gl_matrix_1.vec3.clone(emitter.props.PivotPoint);
        var second = gl_matrix_1.vec3.clone(emitter.props.PivotPoint);
        first[1] -= this.interp.animVectorVal(emitter.props.HeightBelow, 0);
        second[1] += this.interp.animVectorVal(emitter.props.HeightAbove, 0);
        var emitterMatrix = this.rendererData.nodes[emitter.props.ObjectId].matrix;
        gl_matrix_1.vec3.transformMat4(first, first, emitterMatrix);
        gl_matrix_1.vec3.transformMat4(second, second, emitterMatrix);
        var currentSize = emitter.creationTimes.length;
        emitter.vertices[currentSize * 6] = first[0];
        emitter.vertices[currentSize * 6 + 1] = first[1];
        emitter.vertices[currentSize * 6 + 2] = first[2];
        emitter.vertices[currentSize * 6 + 3] = second[0];
        emitter.vertices[currentSize * 6 + 4] = second[1];
        emitter.vertices[currentSize * 6 + 5] = second[2];
    };
    RibbonsController.prototype.updateEmitterTexCoords = function (emitter, now) {
        for (var i = 0; i < emitter.creationTimes.length; ++i) {
            var relativePos = (now - emitter.creationTimes[i]) / (emitter.props.LifeSpan * 1000);
            var textureSlot = this.interp.animVectorVal(emitter.props.TextureSlot, 0);
            var texCoordX = textureSlot % emitter.props.Columns;
            var texCoordY = Math.floor(textureSlot / emitter.props.Rows);
            var cellWidth = 1 / emitter.props.Columns;
            var cellHeight = 1 / emitter.props.Rows;
            relativePos = texCoordX * cellWidth + relativePos * cellWidth;
            emitter.texCoords[i * 2 * 2] = relativePos;
            emitter.texCoords[i * 2 * 2 + 1] = texCoordY * cellHeight;
            emitter.texCoords[i * 2 * 2 + 2] = relativePos;
            emitter.texCoords[i * 2 * 2 + 3] = (1 + texCoordY) * cellHeight;
        }
    };
    RibbonsController.prototype.setLayerProps = function (layer, textureID) {
        var texture = this.rendererData.model.Textures[textureID];
        if (layer.Shading & model_1.LayerShading.TwoSided) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
        }
        if (layer.FilterMode === model_1.FilterMode.Transparent) {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, 0.75);
        }
        else {
            gl.uniform1f(shaderProgramLocations.discardAlphaLevelUniform, 0.);
        }
        if (layer.FilterMode === model_1.FilterMode.None) {
            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(true);
        }
        else if (layer.FilterMode === model_1.FilterMode.Transparent) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(true);
        }
        else if (layer.FilterMode === model_1.FilterMode.Blend) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.Additive) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_COLOR, gl.ONE);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.AddAlpha) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.Modulate) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.ONE);
            gl.depthMask(false);
        }
        else if (layer.FilterMode === model_1.FilterMode.Modulate2x) {
            gl.enable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFuncSeparate(gl.DST_COLOR, gl.SRC_COLOR, gl.ZERO, gl.ONE);
            gl.depthMask(false);
        }
        if (texture.Image) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.rendererData.textures[texture.Image]);
            gl.uniform1i(shaderProgramLocations.samplerUniform, 0);
            gl.uniform1f(shaderProgramLocations.replaceableTypeUniform, 0);
        }
        else if (texture.ReplaceableId === 1 || texture.ReplaceableId === 2) {
            gl.uniform3fv(shaderProgramLocations.replaceableColorUniform, this.rendererData.teamColor);
            gl.uniform1f(shaderProgramLocations.replaceableTypeUniform, texture.ReplaceableId);
        }
        if (layer.Shading & model_1.LayerShading.NoDepthTest) {
            gl.disable(gl.DEPTH_TEST);
        }
        if (layer.Shading & model_1.LayerShading.NoDepthSet) {
            gl.depthMask(false);
        }
        /*if (typeof layer.TVertexAnimId === 'number') {
            let anim: TVertexAnim = this.rendererData.model.TextureAnims[layer.TVertexAnimId];
            let translationRes = this.interp.vec3(translation, anim.Translation);
            let rotationRes = this.interp.quat(rotation, anim.Rotation);
            let scalingRes = this.interp.vec3(scaling, anim.Scaling);
            mat4.fromRotationTranslationScale(
                texCoordMat4,
                rotationRes || defaultRotation,
                translationRes || defaultTranslation,
                scalingRes || defaultScaling
            );
            mat3.set(
                texCoordMat3,
                texCoordMat4[0], texCoordMat4[1], 0,
                texCoordMat4[4], texCoordMat4[5], 0,
                texCoordMat4[12], texCoordMat4[13], 0
            );

            gl.uniformMatrix3fv(shaderProgramLocations.tVertexAnimUniform, false, texCoordMat3);
        } else {
            gl.uniformMatrix3fv(shaderProgramLocations.tVertexAnimUniform, false, identifyMat3);
        }*/
    };
    RibbonsController.prototype.setGeneralBuffers = function (emitter) {
        gl.bindBuffer(gl.ARRAY_BUFFER, emitter.texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, emitter.texCoords, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(shaderProgramLocations.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, emitter.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, emitter.vertices, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(shaderProgramLocations.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    };
    RibbonsController.prototype.renderEmitter = function (emitter) {
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, emitter.creationTimes.length * 2);
    };
    return RibbonsController;
}());
exports.RibbonsController = RibbonsController;
//# sourceMappingURL=ribbons.js.map
},{"../model":7,"./modelInterp":19,"./util":23,"gl-matrix":8}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function mat4fromRotationOrigin(out, rotation, origin) {
    var x = rotation[0], y = rotation[1], z = rotation[2], w = rotation[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, ox = origin[0], oy = origin[1], oz = origin[2];
    out[0] = (1 - (yy + zz));
    out[1] = (xy + wz);
    out[2] = (xz - wy);
    out[3] = 0;
    out[4] = (xy - wz);
    out[5] = (1 - (xx + zz));
    out[6] = (yz + wx);
    out[7] = 0;
    out[8] = (xz + wy);
    out[9] = (yz - wx);
    out[10] = (1 - (xx + yy));
    out[11] = 0;
    out[12] = ox - (out[0] * ox + out[4] * oy + out[8] * oz);
    out[13] = oy - (out[1] * ox + out[5] * oy + out[9] * oz);
    out[14] = oz - (out[2] * ox + out[6] * oy + out[10] * oz);
    out[15] = 1;
    return out;
}
exports.mat4fromRotationOrigin = mat4fromRotationOrigin;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3RotateZ(out, a, c) {
    out[0] = a[0] * Math.cos(c) - a[1] * Math.sin(c);
    out[1] = a[0] * Math.sin(c) + a[1] * Math.cos(c);
    out[2] = a[2];
    return out;
}
exports.vec3RotateZ = vec3RotateZ;
function rand(from, to) {
    return from + Math.random() * (to - from);
}
exports.rand = rand;
function degToRad(angle) {
    return angle * Math.PI / 180;
}
exports.degToRad = degToRad;
function getShader(gl, source, type) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}
exports.getShader = getShader;
//# sourceMappingURL=util.js.map
},{}],24:[function(require,module,exports){
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

// NOTE: This file was edited to match the crude usage of the JPG format by Blizzard for their BLP1 format.

var JpegImage = (function jpegImage() {
    "use strict";
    var dctZigZag = new Int32Array([
        0,
        1,  8,
        16,  9,  2,
        3, 10, 17, 24,
        32, 25, 18, 11, 4,
        5, 12, 19, 26, 33, 40,
        48, 41, 34, 27, 20, 13,  6,
        7, 14, 21, 28, 35, 42, 49, 56,
        57, 50, 43, 36, 29, 22, 15,
        23, 30, 37, 44, 51, 58,
        59, 52, 45, 38, 31,
        39, 46, 53, 60,
        61, 54, 47,
        55, 62,
        63
    ]);

    var dctCos1  =  4017   // cos(pi/16)
    var dctSin1  =   799   // sin(pi/16)
    var dctCos3  =  3406   // cos(3*pi/16)
    var dctSin3  =  2276   // sin(3*pi/16)
    var dctCos6  =  1567   // cos(6*pi/16)
    var dctSin6  =  3784   // sin(6*pi/16)
    var dctSqrt2 =  5793   // sqrt(2)
    var dctSqrt1d2 = 2896  // sqrt(2) / 2

    function constructor() {
    }

    function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
            length--;
        code.push({children: [], index: 0});
        var p = code[0], q;
        for (i = 0; i < length; i++) {
            for (j = 0; j < codeLengths[i]; j++) {
                p = code.pop();
                p.children[p.index] = values[k];
                while (p.index > 0) {
                    p = code.pop();
                }
                p.index++;
                code.push(p);
                while (code.length <= i) {
                    code.push(q = {children: [], index: 0});
                    p.children[p.index] = q.children;
                    p = q;
                }
                k++;
            }
            if (i + 1 < length) {
                // p here points to last code
                code.push(q = {children: [], index: 0});
                p.children[p.index] = q.children;
                p = q;
            }
        }
        return code[0].children;
    }

    function getBlockBufferOffset(component, row, col) {
        return 64 * ((component.blocksPerLine + 1) * row + col);
    }

    function decodeScan(data, offset,
                        frame, components, resetInterval,
                        spectralStart, spectralEnd,
                        successivePrev, successive) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;

        var startOffset = offset, bitsData = 0, bitsCount = 0;

        function readBit() {
            if (bitsCount > 0) {
                bitsCount--;
                return (bitsData >> bitsCount) & 1;
            }
            bitsData = data[offset++];
            if (bitsData == 0xFF) {
                var nextByte = data[offset++];
                if (nextByte) {
                    throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
                }
                // unstuff 0
            }
            bitsCount = 7;
            return bitsData >>> 7;
        }

        function decodeHuffman(tree) {
            var node = tree;
            var bit;
            while ((bit = readBit()) !== null) {
                node = node[bit];
                if (typeof node === 'number')
                    return node;
                if (typeof node !== 'object')
                    throw "invalid huffman sequence";
            }
            return null;
        }

        function receive(length) {
            var n = 0;
            while (length > 0) {
                var bit = readBit();
                if (bit === null) return;
                n = (n << 1) | bit;
                length--;
            }
            return n;
        }

        function receiveAndExtend(length) {
            var n = receive(length);
            if (n >= 1 << (length - 1))
                return n;
            return n + (-1 << length) + 1;
        }

        function decodeBaseline(component, offset) {
            var t = decodeHuffman(component.huffmanTableDC);
            var diff = t === 0 ? 0 : receiveAndExtend(t);
            component.blockData[offset] = (component.pred += diff);
            var k = 1;
            while (k < 64) {
                var rs = decodeHuffman(component.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                    if (r < 15)
                        break;
                    k += 16;
                    continue;
                }
                k += r;
                var z = dctZigZag[k];
                component.blockData[offset + z] = receiveAndExtend(s);
                k++;
            }
        }

        function decodeDCFirst(component, offset) {
            var t = decodeHuffman(component.huffmanTableDC);
            var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
            component.blockData[offset] = (component.pred += diff);
        }

        function decodeDCSuccessive(component, offset) {
            component.blockData[offset] |= readBit() << successive;
        }

        var eobrun = 0;
        function decodeACFirst(component, offset) {
            if (eobrun > 0) {
                eobrun--;
                return;
            }
            var k = spectralStart, e = spectralEnd;
            while (k <= e) {
                var rs = decodeHuffman(component.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                    if (r < 15) {
                        eobrun = receive(r) + (1 << r) - 1;
                        break;
                    }
                    k += 16;
                    continue;
                }
                k += r;
                var z = dctZigZag[k];
                component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
                k++;
            }
        }

        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component, offset) {
            var k = spectralStart, e = spectralEnd, r = 0;
            while (k <= e) {
                var z = dctZigZag[k];
                switch (successiveACState) {
                    case 0: // initial state
                        var rs = decodeHuffman(component.huffmanTableAC);
                        var s = rs & 15, r = rs >> 4;
                        if (s === 0) {
                            if (r < 15) {
                                eobrun = receive(r) + (1 << r);
                                successiveACState = 4;
                            } else {
                                r = 16;
                                successiveACState = 1;
                            }
                        } else {
                            if (s !== 1)
                                throw "invalid ACn encoding";
                            successiveACNextValue = receiveAndExtend(s);
                            successiveACState = r ? 2 : 3;
                        }
                        continue;
                    case 1: // skipping r zero items
                    case 2:
                        if (component.blockData[offset + z]) {
                            component.blockData[offset + z] += (readBit() << successive);
                        } else {
                            r--;
                            if (r === 0)
                                successiveACState = successiveACState == 2 ? 3 : 0;
                        }
                        break;
                    case 3: // set value for a zero item
                        if (component.blockData[offset + z]) {
                            component.blockData[offset + z] += (readBit() << successive);
                        } else {
                            component.blockData[offset + z] = successiveACNextValue << successive;
                            successiveACState = 0;
                        }
                        break;
                    case 4: // eob
                        if (component.blockData[offset + z]) {
                            component.blockData[offset + z] += (readBit() << successive);
                        }
                        break;
                }
                k++;
            }
            if (successiveACState === 4) {
                eobrun--;
                if (eobrun === 0)
                    successiveACState = 0;
            }
        }

        function decodeMcu(component, decode, mcu, row, col) {
            var mcuRow = (mcu / mcusPerLine) | 0;
            var mcuCol = mcu % mcusPerLine;
            var blockRow = mcuRow * component.v + row;
            var blockCol = mcuCol * component.h + col;
            var offset = getBlockBufferOffset(component, blockRow, blockCol);
            decode(component, offset);
        }

        function decodeBlock(component, decode, mcu) {
            var blockRow = (mcu / component.blocksPerLine) | 0;
            var blockCol = mcu % component.blocksPerLine;
            var offset = getBlockBufferOffset(component, blockRow, blockCol);
            decode(component, offset);
        }

        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
            if (spectralStart === 0)
                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
            else
                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
            decodeFn = decodeBaseline;
        }

        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
            mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval) {
            resetInterval = mcuExpected;
        }

        var h, v;
        while (mcu < mcuExpected) {
            // reset interval stuff
            for (i = 0; i < componentsLength; i++) {
                components[i].pred = 0;
            }
            eobrun = 0;

            if (componentsLength == 1) {
                component = components[0];
                for (n = 0; n < resetInterval; n++) {
                    decodeBlock(component, decodeFn, mcu);
                    mcu++;
                }
            } else {
                for (n = 0; n < resetInterval; n++) {
                    for (i = 0; i < componentsLength; i++) {
                        component = components[i];
                        h = component.h;
                        v = component.v;
                        for (j = 0; j < v; j++) {
                            for (k = 0; k < h; k++) {
                                decodeMcu(component, decodeFn, mcu, j, k);
                            }
                        }
                    }
                    mcu++;
                }
            }

            // find marker
            bitsCount = 0;
            marker = (data[offset] << 8) | data[offset + 1];
            if (marker <= 0xFF00) {
                throw "marker was not found";
            }

            if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
                offset += 2;
            } else {
                break;
            }
        }

        return offset - startOffset;
    }

    // A port of poppler's IDCT method which in turn is taken from:
    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
    //   988-991.
    function quantizeAndInverse(component, blockBufferOffset, p) {
        var qt = component.quantizationTable;
        var v0, v1, v2, v3, v4, v5, v6, v7, t;
        var i;

        // dequant
        for (i = 0; i < 64; i++) {
            p[i] = component.blockData[blockBufferOffset + i] * qt[i];
        }

        // inverse DCT on rows
        for (i = 0; i < 8; ++i) {
            var row = 8 * i;

            // check for all-zero AC coefficients
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
                p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
                p[7 + row] == 0) {
                t = (dctSqrt2 * p[0 + row] + 512) >> 10;
                p[0 + row] = t;
                p[1 + row] = t;
                p[2 + row] = t;
                p[3 + row] = t;
                p[4 + row] = t;
                p[5 + row] = t;
                p[6 + row] = t;
                p[7 + row] = t;
                continue;
            }

            // stage 4
            v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
            v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
            v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;

            // stage 3
            t = (v0 - v1+ 1) >> 1;
            v0 = (v0 + v1 + 1) >> 1;
            v1 = t;
            t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
            v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
            v3 = t;
            t = (v4 - v6 + 1) >> 1;
            v4 = (v4 + v6 + 1) >> 1;
            v6 = t;
            t = (v7 + v5 + 1) >> 1;
            v5 = (v7 - v5 + 1) >> 1;
            v7 = t;

            // stage 2
            t = (v0 - v3 + 1) >> 1;
            v0 = (v0 + v3 + 1) >> 1;
            v3 = t;
            t = (v1 - v2 + 1) >> 1;
            v1 = (v1 + v2 + 1) >> 1;
            v2 = t;
            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
            v7 = t;
            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
            v6 = t;

            // stage 1
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
        }

        // inverse DCT on columns
        for (i = 0; i < 8; ++i) {
            var col = i;

            // check for all-zero AC coefficients
            if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
                p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
                p[7*8 + col] == 0) {
                t = (dctSqrt2 * p[i+0] + 8192) >> 14;
                p[0*8 + col] = t;
                p[1*8 + col] = t;
                p[2*8 + col] = t;
                p[3*8 + col] = t;
                p[4*8 + col] = t;
                p[5*8 + col] = t;
                p[6*8 + col] = t;
                p[7*8 + col] = t;
                continue;
            }

            // stage 4
            v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
            v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
            v2 = p[2*8 + col];
            v3 = p[6*8 + col];
            v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
            v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
            v5 = p[3*8 + col];
            v6 = p[5*8 + col];

            // stage 3
            t = (v0 - v1 + 1) >> 1;
            v0 = (v0 + v1 + 1) >> 1;
            v1 = t;
            t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
            v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
            v3 = t;
            t = (v4 - v6 + 1) >> 1;
            v4 = (v4 + v6 + 1) >> 1;
            v6 = t;
            t = (v7 + v5 + 1) >> 1;
            v5 = (v7 - v5 + 1) >> 1;
            v7 = t;

            // stage 2
            t = (v0 - v3 + 1) >> 1;
            v0 = (v0 + v3 + 1) >> 1;
            v3 = t;
            t = (v1 - v2 + 1) >> 1;
            v1 = (v1 + v2 + 1) >> 1;
            v2 = t;
            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
            v7 = t;
            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
            v6 = t;

            // stage 1
            p[0*8 + col] = v0 + v7;
            p[7*8 + col] = v0 - v7;
            p[1*8 + col] = v1 + v6;
            p[6*8 + col] = v1 - v6;
            p[2*8 + col] = v2 + v5;
            p[5*8 + col] = v2 - v5;
            p[3*8 + col] = v3 + v4;
            p[4*8 + col] = v3 - v4;
        }

        // convert to 8-bit integers
        for (i = 0; i < 64; ++i) {
            var index = blockBufferOffset + i;
            var q = p[i];
            q = (q <= -2056) ? 0 : (q >= 2024) ? 255 : (q + 2056) >> 4;
            component.blockData[index] = q;
        }
    }

    function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var computationBuffer = new Int32Array(64);

        var i, j, ll = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                var offset = getBlockBufferOffset(component, blockRow, blockCol)
                quantizeAndInverse(component, offset, computationBuffer);
            }
        }
        return component.blockData;
    }

    function clampToUint8(a) {
        return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;
    }

    constructor.prototype = {
        load: function load(path) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", path, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = (function() {
                // TODO catch parse error
                var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                this.parse(data);
                if (this.onload)
                    this.onload();
            }).bind(this);
            xhr.send(null);
        },

        loadFromBuffer: function loadFromBuffer(arrayBuffer) {
            this.parse(arrayBuffer);
            if (this.onload)
                this.onload();
        },

        parse: function parse(data) {

            function readUint16() {
                var value = (data[offset] << 8) | data[offset + 1];
                offset += 2;
                return value;
            }

            function readDataBlock() {
                var length = readUint16();
                var array = data.subarray(offset, offset + length - 2);
                offset += array.length;
                return array;
            }

            function prepareComponents(frame) {
                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
                var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
                for (var i = 0; i < frame.components.length; i++) {
                    component = frame.components[i];
                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
                    var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / frame.maxV);
                    var blocksPerLineForMcu = mcusPerLine * component.h;
                    var blocksPerColumnForMcu = mcusPerColumn * component.v;

                    var blocksBufferSize = 64 * blocksPerColumnForMcu
                        * (blocksPerLineForMcu + 1);
                    component.blockData = new Int16Array(blocksBufferSize);
                    component.blocksPerLine = blocksPerLine;
                    component.blocksPerColumn = blocksPerColumn;
                }
                frame.mcusPerLine = mcusPerLine;
                frame.mcusPerColumn = mcusPerColumn;
            }

            var offset = 0, length = data.length;
            var jfif = null;
            var adobe = null;
            var pixels = null;
            var frame, resetInterval;
            var quantizationTables = [];
            var huffmanTablesAC = [], huffmanTablesDC = [];
            var fileMarker = readUint16();
            if (fileMarker != 0xFFD8) { // SOI (Start of Image)
                throw "SOI not found";
            }

            fileMarker = readUint16();
            while (fileMarker != 0xFFD9) { // EOI (End of image)
                var i, j, l;
                switch(fileMarker) {
                    case 0xFFE0: // APP0 (Application Specific)
                    case 0xFFE1: // APP1
                    case 0xFFE2: // APP2
                    case 0xFFE3: // APP3
                    case 0xFFE4: // APP4
                    case 0xFFE5: // APP5
                    case 0xFFE6: // APP6
                    case 0xFFE7: // APP7
                    case 0xFFE8: // APP8
                    case 0xFFE9: // APP9
                    case 0xFFEA: // APP10
                    case 0xFFEB: // APP11
                    case 0xFFEC: // APP12
                    case 0xFFED: // APP13
                    case 0xFFEE: // APP14
                    case 0xFFEF: // APP15
                    case 0xFFFE: // COM (Comment)
                        var appData = readDataBlock();

                        if (fileMarker === 0xFFE0) {
                            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                                jfif = {
                                    version: { major: appData[5], minor: appData[6] },
                                    densityUnits: appData[7],
                                    xDensity: (appData[8] << 8) | appData[9],
                                    yDensity: (appData[10] << 8) | appData[11],
                                    thumbWidth: appData[12],
                                    thumbHeight: appData[13],
                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                                };
                            }
                        }
                        // TODO APP1 - Exif
                        if (fileMarker === 0xFFEE) {
                            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                                adobe = {
                                    version: appData[6],
                                    flags0: (appData[7] << 8) | appData[8],
                                    flags1: (appData[9] << 8) | appData[10],
                                    transformCode: appData[11]
                                };
                            }
                        }
                        break;

                    case 0xFFDB: // DQT (Define Quantization Tables)
                        var quantizationTablesLength = readUint16();
                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                        while (offset < quantizationTablesEnd) {
                            var quantizationTableSpec = data[offset++];
                            var tableData = new Int32Array(64);
                            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                                for (j = 0; j < 64; j++) {
                                    var z = dctZigZag[j];
                                    tableData[z] = data[offset++];
                                }
                            } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                                for (j = 0; j < 64; j++) {
                                    var z = dctZigZag[j];
                                    tableData[z] = readUint16();
                                }
                            } else
                                throw "DQT: invalid table spec";
                            quantizationTables[quantizationTableSpec & 15] = tableData;
                        }
                        break;

                    case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
                    case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
                    case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
                        if (frame) {
                            throw "Only single frame JPEGs supported";
                        }
                        readUint16(); // skip data length
                        frame = {};
                        frame.extended = (fileMarker === 0xFFC1);
                        frame.progressive = (fileMarker === 0xFFC2);
                        frame.precision = data[offset++];
                        frame.scanLines = readUint16();
                        frame.samplesPerLine = readUint16();
                        frame.components = [];
                        frame.componentIds = {};
                        var componentsCount = data[offset++], componentId;
                        var maxH = 0, maxV = 0;
                        for (i = 0; i < componentsCount; i++) {
                            componentId = data[offset];
                            var h = data[offset + 1] >> 4;
                            var v = data[offset + 1] & 15;
                            if (maxH < h) maxH = h;
                            if (maxV < v) maxV = v;
                            var qId = data[offset + 2];
                            var l = frame.components.push({
                                h: h,
                                v: v,
                                quantizationTable: quantizationTables[qId]
                            });
                            frame.componentIds[componentId] = l - 1;
                            offset += 3;
                        }
                        frame.maxH = maxH;
                        frame.maxV = maxV;
                        prepareComponents(frame);
                        break;

                    case 0xFFC4: // DHT (Define Huffman Tables)
                        var huffmanLength = readUint16();
                        for (i = 2; i < huffmanLength;) {
                            var huffmanTableSpec = data[offset++];
                            var codeLengths = new Uint8Array(16);
                            var codeLengthSum = 0;
                            for (j = 0; j < 16; j++, offset++)
                                codeLengthSum += (codeLengths[j] = data[offset]);
                            var huffmanValues = new Uint8Array(codeLengthSum);
                            for (j = 0; j < codeLengthSum; j++, offset++)
                                huffmanValues[j] = data[offset];
                            i += 17 + codeLengthSum;

                            ((huffmanTableSpec >> 4) === 0 ?
                                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                                buildHuffmanTable(codeLengths, huffmanValues);
                        }
                        break;

                    case 0xFFDD: // DRI (Define Restart Interval)
                        readUint16(); // skip data length
                        resetInterval = readUint16();
                        break;

                    case 0xFFDA: // SOS (Start of Scan)
                        var scanLength = readUint16();
                        var selectorsCount = data[offset++];
                        var components = [], component;
                        for (i = 0; i < selectorsCount; i++) {
                            var componentIndex = frame.componentIds[data[offset++]];
                            component = frame.components[componentIndex];
                            var tableSpec = data[offset++];
                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                            components.push(component);
                        }
                        var spectralStart = data[offset++];
                        var spectralEnd = data[offset++];
                        var successiveApproximation = data[offset++];
                        var processed = decodeScan(data, offset,
                            frame, components, resetInterval,
                            spectralStart, spectralEnd,
                            successiveApproximation >> 4, successiveApproximation & 15);
                        offset += processed;
                        break;
                    default:
                        if (data[offset - 3] == 0xFF &&
                            data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
                            // could be incorrect encoding -- last 0xFF byte of the previous
                            // block was eaten by the encoder
                            offset -= 3;
                            break;
                        }
                        throw "unknown JPEG marker " + fileMarker.toString(16);
                }
                fileMarker = readUint16();
            }

            this.width = frame.samplesPerLine;
            this.height = frame.scanLines;
            this.jfif = jfif;
            this.adobe = adobe;
            this.components = [];
            for (var i = 0; i < frame.components.length; i++) {
                var component = frame.components[i];
                this.components.push({
                    output: buildComponentData(frame, component),
                    scaleX: component.h / frame.maxH,
                    scaleY: component.v / frame.maxV,
                    blocksPerLine: component.blocksPerLine,
                    blocksPerColumn: component.blocksPerColumn
                });
            }
        },

        getData: function getData(imageData, width, height) {
            var scaleX = this.width / width, scaleY = this.height / height;

            var component, componentScaleX, componentScaleY;
            var x, y, i;
            var offset = 0;
            var Y, Cb, Cr, K, C, M, Ye, R, G, B;
            var colorTransform;
            var numComponents = this.components.length;
            var dataLength = width * height * numComponents;
            //var data = new Uint8Array(dataLength);
            var data = imageData.data;
            var componentLine;

            // lineData is reused for all components. Assume first component is
            // the biggest
            var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *
                this.components[0].blocksPerColumn * 8);

            // First construct image data ...
            for (i = 0; i < numComponents; i++) {
                component = this.components[i < 3 ? 2 - i : i];
                var blocksPerLine = component.blocksPerLine;
                var blocksPerColumn = component.blocksPerColumn;
                var samplesPerLine = blocksPerLine << 3;

                var j, k, ll = 0;
                var lineOffset = 0;
                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                    var scanLine = blockRow << 3;
                    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                        var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
                        var offset = 0, sample = blockCol << 3;
                        for (j = 0; j < 8; j++) {
                            var lineOffset = (scanLine + j) * samplesPerLine;
                            for (k = 0; k < 8; k++) {
                                lineData[lineOffset + sample + k] =
                                    component.output[bufferOffset + offset++];
                            }
                        }
                    }
                }

                componentScaleX = component.scaleX * scaleX;
                componentScaleY = component.scaleY * scaleY;
                offset = i;

                var cx, cy;
                var index;
                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        cy = 0 | (y * componentScaleY);
                        cx = 0 | (x * componentScaleX);
                        index = cy * samplesPerLine + cx;
                        data[offset] = lineData[index];
                        offset += numComponents;
                    }
                }
            }

          /*
           // ... then transform colors, if necessary
           switch (numComponents) {
           case 1: case 2: break;
           // no color conversion for one or two compoenents

           case 3:
           // The default transform for three components is true
           colorTransform = true;
           // The adobe transform marker overrides any previous setting
           if (this.adobe && this.adobe.transformCode)
           colorTransform = true;
           else if (typeof this.colorTransform !== 'undefined')
           colorTransform = !!this.colorTransform;

           if (colorTransform) {
           for (i = 0; i < dataLength; i += numComponents) {
           Y  = data[i    ];
           Cb = data[i + 1];
           Cr = data[i + 2];

           R = clampToUint8(Y - 179.456 + 1.402 * Cr);
           G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
           B = clampToUint8(Y - 226.816 + 1.772 * Cb);

           data[i    ] = R;
           data[i + 1] = G;
           data[i + 2] = B;
           }
           }
           break;
           case 4:
           console.log(this.colorTransform);
           if (!this.adobe)
           throw 'Unsupported color mode (4 components)';
           // The default transform for four components is false
           colorTransform = false;
           // The adobe transform marker overrides any previous setting
           if (this.adobe && this.adobe.transformCode)
           colorTransform = true;
           else if (typeof this.colorTransform !== 'undefined')
           colorTransform = !!this.colorTransform;

           if (colorTransform) {
           for (i = 0; i < dataLength; i += numComponents) {
           Y  = data[i];
           Cb = data[i + 1];
           Cr = data[i + 2];

           C = clampToUint8(434.456 - Y - 1.402 * Cr);
           M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
           Y = clampToUint8(481.816 - Y - 1.772 * Cb);

           data[i    ] = C;
           data[i + 1] = M;
           data[i + 2] = Y;
           // K is unchanged
           }
           }
           break;
           default:
           throw 'Unsupported color mode';
           }
           */
            return data;
        },
        copyToImageData: function copyToImageData(imageData) {
            var width = imageData.width, height = imageData.height;
            var imageDataBytes = width * height * 4;
            var imageDataArray = imageData.data;
            var data = this.getData(width, height);
            var i = 0, j = 0, k0, k1;
            var Y, K, C, M, R, G, B;
            switch (this.components.length) {
                case 1:
                    while (j < imageDataBytes) {
                        Y = data[i++];

                        imageDataArray[j++] = Y;
                        imageDataArray[j++] = Y;
                        imageDataArray[j++] = Y;
                        imageDataArray[j++] = 255;
                    }
                    break;
                case 3:
                    while (j < imageDataBytes) {
                        R = data[i++];
                        G = data[i++];
                        B = data[i++];

                        imageDataArray[j++] = R;
                        imageDataArray[j++] = G;
                        imageDataArray[j++] = B;
                        imageDataArray[j++] = 255;
                    }
                    break;
                case 4:
                    while (j < imageDataBytes) {
                        C = data[i++];
                        M = data[i++];
                        Y = data[i++];
                        K = data[i++];

                        k0 = 255 - K;
                        k1 = k0 / 255;


                        R = clampToUint8(k0 - C * k1);
                        G = clampToUint8(k0 - M * k1);
                        B = clampToUint8(k0 - Y * k1);

                        imageDataArray[j++] = R;
                        imageDataArray[j++] = G;
                        imageDataArray[j++] = B;
                        imageDataArray[j++] = 255;
                    }
                    break;
                default:
                    throw 'Unsupported color mode';
            }
        }
    };

    return constructor;
})();

module.exports = function decode (data) {
    const jpegImage = new JpegImage();

    jpegImage.loadFromBuffer(data);

    var imageData;
    if (typeof ImageData !== 'undefined') {
        imageData = new ImageData(jpegImage.width, jpegImage.height);
    } else {
        imageData = {
            width: jpegImage.width,
            height: jpegImage.height,
            data: new Uint8ClampedArray(jpegImage.width * jpegImage.height * 4)
        };
    }
    jpegImage.getData(imageData, jpegImage.width, jpegImage.height);

    return imageData;
};

},{}]},{},[3])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImJscC9ibHBpbWFnZS5qcyIsImJscC9kZWNvZGUuanMiLCJkb2NzL3ByZXZpZXcvcHJldmlldy5qcyIsImRvY3Mvc2hpbS5qcyIsIm1kbC9wYXJzZS5qcyIsIm1keC9wYXJzZS5qcyIsIm1vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0NC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzIiwicmVuZGVyZXIvaW50ZXJwLmpzIiwicmVuZGVyZXIvbW9kZWxJbnRlcnAuanMiLCJyZW5kZXJlci9tb2RlbFJlbmRlcmVyLmpzIiwicmVuZGVyZXIvcGFydGljbGVzLmpzIiwicmVuZGVyZXIvcmliYm9ucy5qcyIsInJlbmRlcmVyL3V0aWwuanMiLCJ0aGlyZF9wYXJ0eS9kZWNvZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNaQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9wQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGxFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMza0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCTFBUeXBlO1xuKGZ1bmN0aW9uIChCTFBUeXBlKSB7XG4gICAgQkxQVHlwZVtCTFBUeXBlW1wiQkxQMFwiXSA9IDBdID0gXCJCTFAwXCI7XG4gICAgQkxQVHlwZVtCTFBUeXBlW1wiQkxQMVwiXSA9IDFdID0gXCJCTFAxXCI7XG4gICAgQkxQVHlwZVtCTFBUeXBlW1wiQkxQMlwiXSA9IDJdID0gXCJCTFAyXCI7XG59KShCTFBUeXBlID0gZXhwb3J0cy5CTFBUeXBlIHx8IChleHBvcnRzLkJMUFR5cGUgPSB7fSkpO1xudmFyIEJMUENvbnRlbnQ7XG4oZnVuY3Rpb24gKEJMUENvbnRlbnQpIHtcbiAgICBCTFBDb250ZW50W0JMUENvbnRlbnRbXCJKUEVHXCJdID0gMF0gPSBcIkpQRUdcIjtcbiAgICBCTFBDb250ZW50W0JMUENvbnRlbnRbXCJEaXJlY3RcIl0gPSAxXSA9IFwiRGlyZWN0XCI7XG59KShCTFBDb250ZW50ID0gZXhwb3J0cy5CTFBDb250ZW50IHx8IChleHBvcnRzLkJMUENvbnRlbnQgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxwaW1hZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb2RlSlBFRyA9IHJlcXVpcmUoXCIuLi90aGlyZF9wYXJ0eS9kZWNvZGVyXCIpO1xudmFyIGJscGltYWdlXzEgPSByZXF1aXJlKFwiLi9ibHBpbWFnZVwiKTtcbmZ1bmN0aW9uIGtleXdvcmQodmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmlldy5nZXRVaW50OChvZmZzZXQpLCB2aWV3LmdldFVpbnQ4KG9mZnNldCArIDEpLCB2aWV3LmdldFVpbnQ4KG9mZnNldCArIDIpLCB2aWV3LmdldFVpbnQ4KG9mZnNldCArIDMpKTtcbn1cbmZ1bmN0aW9uIHVpbnQzMih2aWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0ICogNCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBiaXRWYWwoZGF0YSwgYml0Q291bnQsIGluZGV4KSB7XG4gICAgLy8gb25seSAxLCA0IG9yIDggYml0c1xuICAgIHZhciBieXRlID0gZGF0YVtNYXRoLmZsb29yKGluZGV4ICogYml0Q291bnQgLyA4KV0sIHZhbHNQZXJCeXRlID0gOCAvIGJpdENvdW50O1xuICAgIHJldHVybiAoYnl0ZSA+PiAodmFsc1BlckJ5dGUgLSBpbmRleCAlIHZhbHNQZXJCeXRlIC0gMSkpICYgKCgxIDw8IGJpdENvdW50KSAtIDEpO1xufVxuLy8gbm9kZS5qcyBoYXZlIG5vIG5hdGl2ZSBJbWFnZURhdGFcbmZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiBJbWFnZURhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgZGF0YTogbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNClcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvZGUoYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdmFyIGltYWdlID0ge1xuICAgICAgICB0eXBlOiBibHBpbWFnZV8xLkJMUFR5cGUuQkxQMSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgY29udGVudDogYmxwaW1hZ2VfMS5CTFBDb250ZW50LkpQRUcsXG4gICAgICAgIGFscGhhQml0czogMCxcbiAgICAgICAgbWlwbWFwczogW10sXG4gICAgICAgIGRhdGE6IGFycmF5QnVmZmVyLFxuICAgIH07XG4gICAgdmFyIHR5cGUgPSBrZXl3b3JkKHZpZXcsIDApO1xuICAgIGlmICh0eXBlID09PSAnQkxQMCcgfHwgdHlwZSA9PT0gJ0JMUDInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQkxQMC9CTFAyIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdCTFAxJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIGJscCBpbWFnZScpO1xuICAgIH1cbiAgICBpbWFnZS5jb250ZW50ID0gdWludDMyKHZpZXcsIDEpO1xuICAgIGlmIChpbWFnZS5jb250ZW50ICE9PSBibHBpbWFnZV8xLkJMUENvbnRlbnQuSlBFRyAmJiBpbWFnZS5jb250ZW50ICE9PSBibHBpbWFnZV8xLkJMUENvbnRlbnQuRGlyZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBCTFAgY29udGVudCcpO1xuICAgIH1cbiAgICBpbWFnZS5hbHBoYUJpdHMgPSB1aW50MzIodmlldywgMik7XG4gICAgaW1hZ2Uud2lkdGggPSB1aW50MzIodmlldywgMyk7XG4gICAgaW1hZ2UuaGVpZ2h0ID0gdWludDMyKHZpZXcsIDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICB2YXIgbWlwbWFwID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiB1aW50MzIodmlldywgNyArIGkpLFxuICAgICAgICAgICAgc2l6ZTogdWludDMyKHZpZXcsIDcgKyAxNiArIGkpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtaXBtYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGltYWdlLm1pcG1hcHMucHVzaChtaXBtYXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBnZXRJbWFnZURhdGEoYmxwLCBtaXBtYXBMZXZlbCkge1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJscC5kYXRhKSwgdWludDhEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYmxwLmRhdGEpLCBtaXBtYXAgPSBibHAubWlwbWFwc1ttaXBtYXBMZXZlbF07XG4gICAgaWYgKGJscC5jb250ZW50ID09PSBibHBpbWFnZV8xLkJMUENvbnRlbnQuSlBFRykge1xuICAgICAgICB2YXIgaGVhZGVyU2l6ZSA9IHVpbnQzMih2aWV3LCAzOSksIGRhdGEgPSBuZXcgVWludDhBcnJheShoZWFkZXJTaXplICsgbWlwbWFwLnNpemUpO1xuICAgICAgICBkYXRhLnNldCh1aW50OERhdGEuc3ViYXJyYXkoNDAgKiA0LCA0MCAqIDQgKyBoZWFkZXJTaXplKSk7XG4gICAgICAgIGRhdGEuc2V0KHVpbnQ4RGF0YS5zdWJhcnJheShtaXBtYXAub2Zmc2V0LCBtaXBtYXAub2Zmc2V0ICsgbWlwbWFwLnNpemUpLCBoZWFkZXJTaXplKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZUpQRUcoZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGFsZXR0ZSA9IG5ldyBVaW50OEFycmF5KGJscC5kYXRhLCAzOSAqIDQsIDI1NiAqIDQpLCB3aWR0aCA9IGJscC53aWR0aCAvICgxIDw8IG1pcG1hcExldmVsKSwgaGVpZ2h0ID0gYmxwLmhlaWdodCAvICgxIDw8IG1pcG1hcExldmVsKSwgc2l6ZSA9IHdpZHRoICogaGVpZ2h0LCBhbHBoYURhdGEgPSBuZXcgVWludDhBcnJheShibHAuZGF0YSwgbWlwbWFwLm9mZnNldCArIHNpemUsIE1hdGguY2VpbChzaXplICogYmxwLmFscGhhQml0cyAvIDgpKSwgaW1hZ2VEYXRhID0gY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpLCB2YWxQZXJBbHBoYUJpdCA9IDI1NSAvICgoMSA8PCBibHAuYWxwaGFCaXRzKSAtIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIHBhbGV0dGVJbmRleCA9IHZpZXcuZ2V0VWludDgobWlwbWFwLm9mZnNldCArIGkpICogNDtcbiAgICAgICAgICAgIC8vIEJHUkEgb3JkZXJcbiAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2kgKiA0XSA9IHBhbGV0dGVbcGFsZXR0ZUluZGV4ICsgMl07XG4gICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpICogNCArIDFdID0gcGFsZXR0ZVtwYWxldHRlSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2kgKiA0ICsgMl0gPSBwYWxldHRlW3BhbGV0dGVJbmRleF07XG4gICAgICAgICAgICBpZiAoYmxwLmFscGhhQml0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpICogNCArIDNdID0gYml0VmFsKGFscGhhRGF0YSwgYmxwLmFscGhhQml0cywgaSkgKiB2YWxQZXJBbHBoYUJpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2kgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgICB9XG59XG5leHBvcnRzLmdldEltYWdlRGF0YSA9IGdldEltYWdlRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4uLy4uL21kbC9wYXJzZVwiKTtcbnZhciBwYXJzZV8yID0gcmVxdWlyZShcIi4uLy4uL21keC9wYXJzZVwiKTtcbnZhciBnbF9tYXRyaXhfMSA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG52YXIgbW9kZWxSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL21vZGVsUmVuZGVyZXJcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3V0aWxcIik7XG52YXIgZGVjb2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vYmxwL2RlY29kZVwiKTtcbnJlcXVpcmUoXCIuLi9zaGltXCIpO1xudmFyIG1vZGVsO1xudmFyIG1vZGVsUmVuZGVyZXI7XG52YXIgY2FudmFzO1xudmFyIGdsO1xudmFyIHBNYXRyaXggPSBnbF9tYXRyaXhfMS5tYXQ0LmNyZWF0ZSgpO1xudmFyIG12TWF0cml4ID0gZ2xfbWF0cml4XzEubWF0NC5jcmVhdGUoKTtcbnZhciBsb2FkZWRUZXh0dXJlcyA9IDA7XG52YXIgdG90YWxUZXh0dXJlcyA9IDA7XG52YXIgY2xlYW51cE5hbWVSZWdleHAgPSAvLio/KFteXFxcXFxcL10rKVxcLlxcdyskLztcbnZhciBjYW1lcmFUaGV0YSA9IE1hdGguUEkgLyA0O1xudmFyIGNhbWVyYVBoaSA9IDA7XG52YXIgY2FtZXJhRGlzdGFuY2UgPSA1MDA7XG52YXIgY2FtZXJhVGFyZ2V0WiA9IDUwO1xudmFyIGNhbWVyYUJhc2VQb3MgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIGNhbWVyYVBvcyA9IGdsX21hdHJpeF8xLnZlYzMuY3JlYXRlKCk7XG52YXIgY2FtZXJhVGFyZ2V0ID0gZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKTtcbnZhciBjYW1lcmFVcCA9IGdsX21hdHJpeF8xLnZlYzMuZnJvbVZhbHVlcygwLCAwLCAxKTtcbnZhciBjYW1lcmFRdWF0ID0gZ2xfbWF0cml4XzEucXVhdC5jcmVhdGUoKTtcbnZhciBzdGFydDtcbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsKHRpbWVzdGFtcCkge1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIHZhciBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXJ0O1xuICAgIC8vIGRlbHRhIC89IDEwO1xuICAgIHN0YXJ0ID0gdGltZXN0YW1wO1xuICAgIG1vZGVsUmVuZGVyZXIudXBkYXRlKGRlbHRhKTtcbn1cbmZ1bmN0aW9uIGluaXRHTCgpIHtcbiAgICBpZiAoZ2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGFsZXJ0KGVycik7XG4gICAgfVxufVxudmFyIGNhbWVyYVBvc1Byb2plY3RlZCA9IGdsX21hdHJpeF8xLnZlYzMuY3JlYXRlKCk7XG52YXIgdmVydGljYWxRdWF0ID0gZ2xfbWF0cml4XzEucXVhdC5jcmVhdGUoKTtcbnZhciBmcm9tQ2FtZXJhQmFzZVZlYyA9IGdsX21hdHJpeF8xLnZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbmZ1bmN0aW9uIGNhbGNDYW1lcmFRdWF0KCkge1xuICAgIGdsX21hdHJpeF8xLnZlYzMuc2V0KGNhbWVyYVBvc1Byb2plY3RlZCwgY2FtZXJhUG9zWzBdLCBjYW1lcmFQb3NbMV0sIDApO1xuICAgIGdsX21hdHJpeF8xLnZlYzMuc3VidHJhY3QoY2FtZXJhUG9zLCBjYW1lcmFQb3MsIGNhbWVyYVRhcmdldCk7XG4gICAgZ2xfbWF0cml4XzEudmVjMy5ub3JtYWxpemUoY2FtZXJhUG9zUHJvamVjdGVkLCBjYW1lcmFQb3NQcm9qZWN0ZWQpO1xuICAgIGdsX21hdHJpeF8xLnZlYzMubm9ybWFsaXplKGNhbWVyYVBvcywgY2FtZXJhUG9zKTtcbiAgICBnbF9tYXRyaXhfMS5xdWF0LnJvdGF0aW9uVG8oY2FtZXJhUXVhdCwgZnJvbUNhbWVyYUJhc2VWZWMsIGNhbWVyYVBvc1Byb2plY3RlZCk7XG4gICAgZ2xfbWF0cml4XzEucXVhdC5yb3RhdGlvblRvKHZlcnRpY2FsUXVhdCwgY2FtZXJhUG9zUHJvamVjdGVkLCBjYW1lcmFQb3MpO1xuICAgIGdsX21hdHJpeF8xLnF1YXQubXVsKGNhbWVyYVF1YXQsIHZlcnRpY2FsUXVhdCwgY2FtZXJhUXVhdCk7XG59XG5mdW5jdGlvbiBkcmF3U2NlbmUoKSB7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIGdsX21hdHJpeF8xLm1hdDQucGVyc3BlY3RpdmUocE1hdHJpeCwgTWF0aC5QSSAvIDQsIGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQsIDAuMSwgMTAwMDAuMCk7XG4gICAgZ2xfbWF0cml4XzEudmVjMy5zZXQoY2FtZXJhQmFzZVBvcywgTWF0aC5jb3MoY2FtZXJhVGhldGEpICogTWF0aC5jb3MoY2FtZXJhUGhpKSAqIGNhbWVyYURpc3RhbmNlLCBNYXRoLmNvcyhjYW1lcmFUaGV0YSkgKiBNYXRoLnNpbihjYW1lcmFQaGkpICogY2FtZXJhRGlzdGFuY2UsIE1hdGguc2luKGNhbWVyYVRoZXRhKSAqIGNhbWVyYURpc3RhbmNlKTtcbiAgICBjYW1lcmFUYXJnZXRbMl0gPSBjYW1lcmFUYXJnZXRaO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgIHV0aWxfMS52ZWMzUm90YXRlWihjYW1lcmFQb3MsIGNhbWVyYUJhc2VQb3MsIHdpbmRvd1snYW5nbGUnXSB8fCAwKTtcbiAgICBnbF9tYXRyaXhfMS5tYXQ0Lmxvb2tBdChtdk1hdHJpeCwgY2FtZXJhUG9zLCBjYW1lcmFUYXJnZXQsIGNhbWVyYVVwKTtcbiAgICBjYWxjQ2FtZXJhUXVhdCgpO1xuICAgIG1vZGVsUmVuZGVyZXIuc2V0Q2FtZXJhKGNhbWVyYVBvcywgY2FtZXJhUXVhdCk7XG4gICAgbW9kZWxSZW5kZXJlci5yZW5kZXIobXZNYXRyaXgsIHBNYXRyaXgpO1xufVxuZnVuY3Rpb24gdGljayh0aW1lc3RhbXApIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgdXBkYXRlTW9kZWwodGltZXN0YW1wKTtcbiAgICBkcmF3U2NlbmUoKTtcbn1cbmZ1bmN0aW9uIGxvYWRUZXh0dXJlKHNyYywgdGV4dHVyZU5hbWUsIGZsYWdzKSB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vZGVsUmVuZGVyZXIuc2V0VGV4dHVyZUltYWdlKHRleHR1cmVOYW1lLCBpbWcsIGZsYWdzKTtcbiAgICAgICAgaGFuZGxlTG9hZGVkVGV4dHVyZSgpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHNyYztcbn1cbmZ1bmN0aW9uIGhhbmRsZUxvYWRlZFRleHR1cmUoKSB7XG4gICAgaWYgKCsrbG9hZGVkVGV4dHVyZXMgPT09IHRvdGFsVGV4dHVyZXMpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlTW9kZWwoaXNCaW5hcnksIHhocikge1xuICAgIGlmIChpc0JpbmFyeSkge1xuICAgICAgICByZXR1cm4gcGFyc2VfMi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlXzEucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc01vZGVsTG9hZGluZygpIHtcbiAgICBjb25zb2xlLmxvZyhtb2RlbCk7XG4gICAgbG9hZGVkVGV4dHVyZXMgPSB0b3RhbFRleHR1cmVzID0gMDtcbiAgICBtb2RlbFJlbmRlcmVyID0gbmV3IG1vZGVsUmVuZGVyZXJfMS5Nb2RlbFJlbmRlcmVyKG1vZGVsKTtcbiAgICBpbml0R0woKTtcbiAgICBtb2RlbFJlbmRlcmVyLmluaXRHTChnbCk7XG4gICAgc2V0QW5pbWF0aW9uTGlzdCgpO1xufVxuZnVuY3Rpb24gc2V0U2FtcGxlVGV4dHVyZXMoKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG1vZGVsLlRleHR1cmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IF9hW19pXTtcbiAgICAgICAgaWYgKHRleHR1cmUuSW1hZ2UpIHtcbiAgICAgICAgICAgICsrdG90YWxUZXh0dXJlcztcbiAgICAgICAgICAgIGxvYWRUZXh0dXJlKHRleHR1cmUuSW1hZ2UsIHRleHR1cmUuSW1hZ2UsIHRleHR1cmUuRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbG9hZE1vZGVsKCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgZmlsZSA9ICdwcmV2aWV3L0Zvb3RtYW4ubWRsJztcbiAgICB2YXIgaXNCaW5hcnkgPSBmaWxlLmluZGV4T2YoJy5tZHgnKSA+IC0xO1xuICAgIGlmIChpc0JpbmFyeSkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG4gICAgeGhyLm9wZW4oJ0dFVCcsIGZpbGUsIHRydWUpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDAgJiYgeGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgICAgIG1vZGVsID0gcGFyc2VNb2RlbChpc0JpbmFyeSwgeGhyKTtcbiAgICAgICAgICAgIHByb2Nlc3NNb2RlbExvYWRpbmcoKTtcbiAgICAgICAgICAgIHNldFNhbXBsZVRleHR1cmVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG59XG5mdW5jdGlvbiBpbml0KCkge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcbiAgICBpbml0Q29udHJvbHMoKTtcbiAgICBpbml0Q2FtZXJhTW92ZSgpO1xuICAgIGluaXREcmFnRHJvcCgpO1xuICAgIC8vIGxvYWRNb2RlbCgpO1xuICAgIHVwZGF0ZUNhbnZhc1NpemUoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlQ2FudmFzU2l6ZSk7XG59XG5mdW5jdGlvbiBpbml0Q29udHJvbHMoKSB7XG4gICAgdmFyIGlucHV0Q29sb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29sb3InKTtcbiAgICBpbnB1dENvbG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsID0gaW5wdXRDb2xvci52YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgdmFyIGFyciA9IGdsX21hdHJpeF8xLnZlYzMuZnJvbVZhbHVlcyhwYXJzZUludCh2YWwuc2xpY2UoMCwgMiksIDE2KSAvIDI1NSwgcGFyc2VJbnQodmFsLnNsaWNlKDIsIDQpLCAxNikgLyAyNTUsIHBhcnNlSW50KHZhbC5zbGljZSg0LCA2KSwgMTYpIC8gMjU1KTtcbiAgICAgICAgbW9kZWxSZW5kZXJlci5zZXRUZWFtQ29sb3IoYXJyKTtcbiAgICB9KTtcbiAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbGVjdCcpO1xuICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kZWxSZW5kZXJlci5zZXRTZXF1ZW5jZShwYXJzZUludChzZWxlY3QudmFsdWUsIDEwKSk7XG4gICAgfSk7XG4gICAgdmFyIGlucHV0WiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YXJnZXRaJyk7XG4gICAgaW5wdXRaLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW1lcmFUYXJnZXRaID0gcGFyc2VJbnQoaW5wdXRaLnZhbHVlLCAxMCk7XG4gICAgfSk7XG4gICAgdmFyIGlucHV0RGlzdGFuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlzdGFuY2UnKTtcbiAgICBpbnB1dERpc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW1lcmFEaXN0YW5jZSA9IHBhcnNlSW50KGlucHV0RGlzdGFuY2UudmFsdWUsIDEwKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRDYW1lcmFNb3ZlKCkge1xuICAgIHZhciBkb3duID0gZmFsc2U7XG4gICAgdmFyIGRvd25YLCBkb3duWTtcbiAgICBmdW5jdGlvbiBjb29yZHMoZXZlbnQpIHtcbiAgICAgICAgdmFyIGxpc3QgPSAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID9cbiAgICAgICAgICAgIGV2ZW50LmNoYW5nZWRUb3VjaGVzIDpcbiAgICAgICAgICAgIGV2ZW50LnRvdWNoZXMpIHx8IFtldmVudF07XG4gICAgICAgIHJldHVybiBbbGlzdFswXS5wYWdlWCwgbGlzdFswXS5wYWdlWV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbWVyYURpc3RhbmNlKGRpc3RhbmNlKSB7XG4gICAgICAgIGNhbWVyYURpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgIGlmIChjYW1lcmFEaXN0YW5jZSA+IDEwMDApIHtcbiAgICAgICAgICAgIGNhbWVyYURpc3RhbmNlID0gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FtZXJhRGlzdGFuY2UgPCAxMDApIHtcbiAgICAgICAgICAgIGNhbWVyYURpc3RhbmNlID0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXN0YW5jZScpLnZhbHVlID0gU3RyaW5nKGNhbWVyYURpc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZG93biA9IHRydWU7XG4gICAgICAgIF9hID0gY29vcmRzKGV2ZW50KSwgZG93blggPSBfYVswXSwgZG93blkgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIWRvd24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgICAgICAgIGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gY29vcmRzKGV2ZW50KSwgeCA9IF9hWzBdLCB5ID0gX2FbMV07XG4gICAgICAgIGNhbWVyYVBoaSArPSAtMSAqICh4IC0gZG93blgpICogMC4wMTtcbiAgICAgICAgY2FtZXJhVGhldGEgKz0gKHkgLSBkb3duWSkgKiAwLjAxO1xuICAgICAgICBpZiAoY2FtZXJhVGhldGEgPiBNYXRoLlBJIC8gMiAqIDAuOTgpIHtcbiAgICAgICAgICAgIGNhbWVyYVRoZXRhID0gTWF0aC5QSSAvIDIgKiAwLjk4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1lcmFUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGNhbWVyYVRoZXRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkb3duWCA9IHg7XG4gICAgICAgIGRvd25ZID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRlclVwKCkge1xuICAgICAgICBkb3duID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdoZWVsKGV2ZW50KSB7XG4gICAgICAgIHVwZGF0ZUNhbWVyYURpc3RhbmNlKGNhbWVyYURpc3RhbmNlICogKDEgLSBldmVudC5kZWx0YVkgLyAzMCkpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRDYW1lcmFEaXN0YW5jZTtcbiAgICBmdW5jdGlvbiBnZXN0dXJlU3RhcnQoKSB7XG4gICAgICAgIHN0YXJ0Q2FtZXJhRGlzdGFuY2UgPSBjYW1lcmFEaXN0YW5jZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VzdHVyZUNoYW5nZShldmVudCkge1xuICAgICAgICB1cGRhdGVDYW1lcmFEaXN0YW5jZShzdGFydENhbWVyYURpc3RhbmNlICogKDEgLyBldmVudC5zY2FsZSkpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBwb2ludGVyRG93bik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHBvaW50ZXJEb3duKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBwb2ludGVyTW92ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcG9pbnRlck1vdmUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBwb2ludGVyVXApO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgcG9pbnRlclVwKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHBvaW50ZXJVcCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB3aGVlbCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgZ2VzdHVyZVN0YXJ0KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdnZXN0dXJlY2hhbmdlJywgZ2VzdHVyZUNoYW5nZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYW52YXNTaXplKCkge1xuICAgIHZhciB3aWR0aCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBjYW52YXMucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbn1cbmZ1bmN0aW9uIGVuY29kZShodG1sKSB7XG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cbmZ1bmN0aW9uIHNldEFuaW1hdGlvbkxpc3QoKSB7XG4gICAgdmFyIGxpc3QgPSBtb2RlbC5TZXF1ZW5jZXMubWFwKGZ1bmN0aW9uIChzZXEpIHsgcmV0dXJuIHNlcS5OYW1lOyB9KTtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbGlzdCA9IFsnTm9uZSddO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbGVjdCcpO1xuICAgIHNlbGVjdC5pbm5lckhUTUwgPSBsaXN0Lm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHsgcmV0dXJuIFwiPG9wdGlvbiB2YWx1ZT1cXFwiXCIgKyBpbmRleCArIFwiXFxcIj5cIiArIGVuY29kZShpdGVtKSArIFwiPC9vcHRpb24+XCI7IH0pLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gc2V0RHJhZ0Ryb3BUZXh0dXJlcygpIHtcbiAgICB2YXIgdGV4dHVyZXNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZHJhZy10ZXh0dXJlcycpO1xuICAgIHRleHR1cmVzQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtb2RlbC5UZXh0dXJlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBfYVtfaV07XG4gICAgICAgIGlmICh0ZXh0dXJlLkltYWdlKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByb3cuY2xhc3NOYW1lID0gJ2RyYWcnO1xuICAgICAgICAgICAgcm93LnRleHRDb250ZW50ID0gdGV4dHVyZS5JbWFnZTtcbiAgICAgICAgICAgIHJvdy5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGV4dHVyZScsIHRleHR1cmUuSW1hZ2UpO1xuICAgICAgICAgICAgcm93LnNldEF0dHJpYnV0ZSgnZGF0YS10ZXh0dXJlLWZsYWdzJywgU3RyaW5nKHRleHR1cmUuRmxhZ3MpKTtcbiAgICAgICAgICAgIHRleHR1cmVzQ29udGFpbmVyLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbml0RHJhZ0Ryb3AoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKTtcbiAgICB2YXIgZHJvcFRhcmdldDtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgZnVuY3Rpb24gb25EcmFnRW50ZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGRyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gZXZlbnQudGFyZ2V0ICYmIGRyb3BUYXJnZXQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBkcm9wVGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdfaG92ZXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NMaXN0ICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2RyYWcnKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2RyYWdfaG92ZXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb250YWluZXJfZHJhZycpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBmdW5jdGlvbiBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnY29udGFpbmVyX2RyYWcnKTtcbiAgICAgICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgZHJvcFRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnX2hvdmVyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIGZ1bmN0aW9uIG9uRHJhZ0xlYXZlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuICAgIH0pO1xuICAgIHZhciBkcm9wTW9kZWwgPSBmdW5jdGlvbiAoZmlsZSwgdGV4dHVyZXMpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHZhciBpc01EWCA9IGZpbGUubmFtZS5pbmRleE9mKCcubWR4JykgPiAtMTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTURYKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gcGFyc2VfMi5wYXJzZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gcGFyc2VfMS5wYXJzZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIHNob3dFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NNb2RlbExvYWRpbmcoKTtcbiAgICAgICAgICAgIHNldFRleHR1cmVzKHRleHR1cmVzKTtcbiAgICAgICAgICAgIHNldERyYWdEcm9wVGV4dHVyZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzTURYKSB7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRyb3BUZXh0dXJlID0gZnVuY3Rpb24gKGZpbGUsIHRleHR1cmVOYW1lLCB0ZXh0dXJlRmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHZhciBpc0JMUCA9IGZpbGUubmFtZS5pbmRleE9mKCcuYmxwJykgPiAtMTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc0JMUCkge1xuICAgICAgICAgICAgICAgIHZhciBibHBfMSA9IGRlY29kZV8xLmRlY29kZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlLm5hbWUsIGJscF8xKTtcbiAgICAgICAgICAgICAgICBtb2RlbFJlbmRlcmVyLnNldFRleHR1cmVJbWFnZURhdGEodGV4dHVyZU5hbWUsIGJscF8xLm1pcG1hcHMubWFwKGZ1bmN0aW9uIChtaXBtYXAsIGkpIHsgcmV0dXJuIGRlY29kZV8xLmdldEltYWdlRGF0YShibHBfMSwgaSk7IH0pLCB0ZXh0dXJlRmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZ18xID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1nXzEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlLm5hbWUsIGltZ18xKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxSZW5kZXJlci5zZXRUZXh0dXJlSW1hZ2UodGV4dHVyZU5hbWUsIGltZ18xLCB0ZXh0dXJlRmxhZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nXzEuc3JjID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUxvYWRlZFRleHR1cmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQkxQKSB7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBmdW5jdGlvbiBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2NvbnRhaW5lcl9kcmFnJyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb250YWluZXJfY3VzdG9tJyk7XG4gICAgICAgIGlmICghZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRyb3BUYXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ19ob3ZlcmVkJyk7XG4gICAgICAgIHZhciBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgaWYgKCFmaWxlcyB8fCAhZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRyb3BUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRleHR1cmUnKSkge1xuICAgICAgICAgICAgZHJvcFRleHR1cmUoZmlsZXNbMF0sIGRyb3BUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRleHR1cmUnKSwgTnVtYmVyKGRyb3BUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRleHR1cmUtZmxhZ3MnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1vZGVsRmlsZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLm5hbWUuaW5kZXhPZignLm1kbCcpID4gLTEgfHwgZmlsZS5uYW1lLmluZGV4T2YoJy5tZHgnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsRmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlbEZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbaV0sIG5hbWVfMSA9IGZpbGUubmFtZS5yZXBsYWNlKGNsZWFudXBOYW1lUmVnZXhwLCAnJDEnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUubmFtZS5pbmRleE9mKCcubWRsJykgPiAtMSB8fCBmaWxlLm5hbWUuaW5kZXhPZignLm1keCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzW25hbWVfMV0gPSBmaWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkcm9wTW9kZWwobW9kZWxGaWxlLCB0ZXh0dXJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBzZXRUZXh0dXJlcyh0ZXh0dXJlcykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbW9kZWwuVGV4dHVyZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLkltYWdlKSB7XG4gICAgICAgICAgICAgICAgKyt0b3RhbFRleHR1cmVzO1xuICAgICAgICAgICAgICAgIHZhciBjbGVhbnVwTmFtZSA9IHRleHR1cmUuSW1hZ2UucmVwbGFjZShjbGVhbnVwTmFtZVJlZ2V4cCwgJyQxJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXBOYW1lIGluIHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BUZXh0dXJlKHRleHR1cmVzW2NsZWFudXBOYW1lXSwgdGV4dHVyZS5JbWFnZSwgdGV4dHVyZS5GbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2FkVGV4dHVyZSgncHJldmlldy9lbXB0eS5wbmcnLCB0ZXh0dXJlLkltYWdlLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgaW5pdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmV2aWV3LmpzLm1hcCIsImlmICghRmxvYXQzMkFycmF5LnByb3RvdHlwZS5yZXZlcnNlKSB7XG4gICAgRmxvYXQzMkFycmF5LnByb3RvdHlwZS5yZXZlcnNlID0gQXJyYXkucHJvdG90eXBlLnJldmVyc2U7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uL21vZGVsXCIpO1xudmFyIFN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZShzdHIpIHtcbiAgICAgICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgU3RhdGUucHJvdG90eXBlLmNoYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0clt0aGlzLnBvc107XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGU7XG59KCkpO1xuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdm9pZCAwKSB7IHN0ciA9ICcnOyB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4RXJyb3IsIG5lYXIgXCIgKyBzdGF0ZS5wb3MgKyAoc3RyID8gJywgJyArIHN0ciA6ICcnKSk7XG59XG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY2hhcigpID09PSAnLycgJiYgc3RhdGUuc3RyW3N0YXRlLnBvcyArIDFdID09PSAnLycpIHtcbiAgICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zdHIubGVuZ3RoICYmIHN0YXRlLnN0clsrK3N0YXRlLnBvc10gIT09ICdcXG4nKVxuICAgICAgICAgICAgO1xuICAgICAgICArK3N0YXRlLnBvcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbnZhciBzcGFjZVJFID0gL1xccy9pO1xuZnVuY3Rpb24gcGFyc2VTcGFjZShzdGF0ZSkge1xuICAgIHdoaWxlIChzcGFjZVJFLnRlc3Qoc3RhdGUuY2hhcigpKSkge1xuICAgICAgICArK3N0YXRlLnBvcztcbiAgICB9XG59XG52YXIga2V5d29yZEZpcnN0Q2hhclJFID0gL1thLXpdL2k7XG52YXIga2V5d29yZE90aGVyQ2hhclJFID0gL1thLXowLTldL2k7XG5mdW5jdGlvbiBwYXJzZUtleXdvcmQoc3RhdGUpIHtcbiAgICBpZiAoIWtleXdvcmRGaXJzdENoYXJSRS50ZXN0KHN0YXRlLmNoYXIoKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXl3b3JkID0gc3RhdGUuY2hhcigpO1xuICAgICsrc3RhdGUucG9zO1xuICAgIHdoaWxlIChrZXl3b3JkT3RoZXJDaGFyUkUudGVzdChzdGF0ZS5jaGFyKCkpKSB7XG4gICAgICAgIGtleXdvcmQgKz0gc3RhdGUuc3RyW3N0YXRlLnBvcysrXTtcbiAgICB9XG4gICAgcGFyc2VTcGFjZShzdGF0ZSk7XG4gICAgcmV0dXJuIGtleXdvcmQ7XG59XG5mdW5jdGlvbiBwYXJzZVN5bWJvbChzdGF0ZSwgc3ltYm9sKSB7XG4gICAgaWYgKHN0YXRlLmNoYXIoKSA9PT0gc3ltYm9sKSB7XG4gICAgICAgICsrc3RhdGUucG9zO1xuICAgICAgICBwYXJzZVNwYWNlKHN0YXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgc3ltYm9sKSB7XG4gICAgaWYgKHN0YXRlLmNoYXIoKSAhPT0gc3ltYm9sKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsIFwiZXh0ZWN0ZWQgXCIgKyBzeW1ib2wpO1xuICAgIH1cbiAgICArK3N0YXRlLnBvcztcbiAgICBwYXJzZVNwYWNlKHN0YXRlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmNoYXIoKSA9PT0gJ1wiJykge1xuICAgICAgICB2YXIgc3RhcnQgPSArK3N0YXRlLnBvczsgLy8gXCJcbiAgICAgICAgd2hpbGUgKHN0YXRlLmNoYXIoKSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgKytzdGF0ZS5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgKytzdGF0ZS5wb3M7IC8vIFwiXG4gICAgICAgIHZhciByZXMgPSBzdGF0ZS5zdHIuc3Vic3RyaW5nKHN0YXJ0LCBzdGF0ZS5wb3MgLSAxKTtcbiAgICAgICAgcGFyc2VTcGFjZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxudmFyIG51bWJlckZpcnN0Q2hhclJFID0gL1stMC05XS87XG52YXIgbnVtYmVyT3RoZXJDaGFyUkUgPSAvWy0rLjAtOWVdL2k7XG5mdW5jdGlvbiBwYXJzZU51bWJlcihzdGF0ZSkge1xuICAgIGlmIChudW1iZXJGaXJzdENoYXJSRS50ZXN0KHN0YXRlLmNoYXIoKSkpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgICAgICArK3N0YXRlLnBvcztcbiAgICAgICAgd2hpbGUgKG51bWJlck90aGVyQ2hhclJFLnRlc3Qoc3RhdGUuY2hhcigpKSkge1xuICAgICAgICAgICAgKytzdGF0ZS5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlRmxvYXQoc3RhdGUuc3RyLnN1YnN0cmluZyhzdGFydCwgc3RhdGUucG9zKSk7XG4gICAgICAgIHBhcnNlU3BhY2Uoc3RhdGUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXkoc3RhdGUsIGFyciwgcG9zKSB7XG4gICAgaWYgKHN0YXRlLmNoYXIoKSAhPT0gJ3snKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWFycikge1xuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgcG9zID0gMDtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgd2hpbGUgKHN0YXRlLmNoYXIoKSAhPT0gJ30nKSB7XG4gICAgICAgIHZhciBudW0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgIGlmIChudW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJbcG9zKytdID0gbnVtO1xuICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclNpbmdsZUl0ZW0oc3RhdGUsIGFycikge1xuICAgIGlmIChzdGF0ZS5jaGFyKCkgIT09ICd7Jykge1xuICAgICAgICBhcnJbMF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIHZhciBwb3MgPSAwO1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIgbnVtID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICBpZiAobnVtID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyW3BvcysrXSA9IG51bTtcbiAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgfVxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdGF0ZSkge1xuICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBpZiAoc3RhdGUuY2hhcigpICE9PSAneycpIHtcbiAgICAgICAgcHJlZml4ID0gcGFyc2VTdHJpbmcoc3RhdGUpO1xuICAgICAgICBpZiAocHJlZml4ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVmaXggPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIHN0cmluZyBvciBudW1iZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICBpZiAoIWtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXl3b3JkID09PSAnSW50ZXJ2YWwnKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMik7XG4gICAgICAgICAgICBvYmpba2V5d29yZF0gPSBwYXJzZUFycmF5KHN0YXRlLCBhcnJheSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ01pbmltdW1FeHRlbnQnIHx8IGtleXdvcmQgPT09ICdNYXhpbXVtRXh0ZW50Jykge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgICAgIG9ialtrZXl3b3JkXSA9IHBhcnNlQXJyYXkoc3RhdGUsIGFycmF5LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXl3b3JkXSA9IHBhcnNlQXJyYXkoc3RhdGUpIHx8IHBhcnNlU3RyaW5nKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChvYmpba2V5d29yZF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5d29yZF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgfVxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgIHJldHVybiBbcHJlZml4LCBvYmpdO1xufVxuZnVuY3Rpb24gcGFyc2VWZXJzaW9uKHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciBfYSA9IHBhcnNlT2JqZWN0KHN0YXRlKSwgdW51c2VkID0gX2FbMF0sIG9iaiA9IF9hWzFdO1xuICAgIGlmIChvYmouRm9ybWF0VmVyc2lvbikge1xuICAgICAgICBtb2RlbC5WZXJzaW9uID0gb2JqLkZvcm1hdFZlcnNpb247XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VNb2RlbEluZm8oc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIF9hID0gcGFyc2VPYmplY3Qoc3RhdGUpLCBuYW1lID0gX2FbMF0sIG9iaiA9IF9hWzFdO1xuICAgIG1vZGVsLkluZm8gPSBvYmo7XG4gICAgbW9kZWwuSW5mby5OYW1lID0gbmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2VxdWVuY2VzKHN0YXRlLCBtb2RlbCkge1xuICAgIHBhcnNlTnVtYmVyKHN0YXRlKTsgLy8gY291bnQsIG5vdCB1c2VkXG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICBwYXJzZUtleXdvcmQoc3RhdGUpOyAvLyBBbmltXG4gICAgICAgIHZhciBfYSA9IHBhcnNlT2JqZWN0KHN0YXRlKSwgbmFtZV8xID0gX2FbMF0sIG9iaiA9IF9hWzFdO1xuICAgICAgICBvYmouTmFtZSA9IG5hbWVfMTtcbiAgICAgICAgb2JqLk5vbkxvb3BpbmcgPSAnTm9uTG9vcGluZycgaW4gb2JqO1xuICAgICAgICByZXMucHVzaChvYmopO1xuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICBtb2RlbC5TZXF1ZW5jZXMgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZVRleHR1cmVzKHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBwYXJzZU51bWJlcihzdGF0ZSk7IC8vIGNvdW50LCBub3QgdXNlZFxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICBwYXJzZUtleXdvcmQoc3RhdGUpOyAvLyBCaXRtYXBcbiAgICAgICAgdmFyIF9hID0gcGFyc2VPYmplY3Qoc3RhdGUpLCB1bnVzZWQgPSBfYVswXSwgb2JqID0gX2FbMV07XG4gICAgICAgIG9iai5GbGFncyA9IDA7XG4gICAgICAgIGlmICgnV3JhcFdpZHRoJyBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5GbGFncyArPSBtb2RlbF8xLlRleHR1cmVGbGFncy5XcmFwV2lkdGg7XG4gICAgICAgICAgICBkZWxldGUgb2JqLldyYXBXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ1dyYXBIZWlnaHQnIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLkZsYWdzICs9IG1vZGVsXzEuVGV4dHVyZUZsYWdzLldyYXBIZWlnaHQ7XG4gICAgICAgICAgICBkZWxldGUgb2JqLldyYXBIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2gob2JqKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuVGV4dHVyZXMgPSByZXM7XG59XG52YXIgQW5pbVZlY3RvclR5cGU7XG4oZnVuY3Rpb24gKEFuaW1WZWN0b3JUeXBlKSB7XG4gICAgQW5pbVZlY3RvclR5cGVbQW5pbVZlY3RvclR5cGVbXCJJTlQxXCJdID0gMF0gPSBcIklOVDFcIjtcbiAgICBBbmltVmVjdG9yVHlwZVtBbmltVmVjdG9yVHlwZVtcIkZMT0FUMVwiXSA9IDFdID0gXCJGTE9BVDFcIjtcbiAgICBBbmltVmVjdG9yVHlwZVtBbmltVmVjdG9yVHlwZVtcIkZMT0FUM1wiXSA9IDJdID0gXCJGTE9BVDNcIjtcbiAgICBBbmltVmVjdG9yVHlwZVtBbmltVmVjdG9yVHlwZVtcIkZMT0FUNFwiXSA9IDNdID0gXCJGTE9BVDRcIjtcbn0pKEFuaW1WZWN0b3JUeXBlIHx8IChBbmltVmVjdG9yVHlwZSA9IHt9KSk7XG52YXIgYW5pbVZlY3RvclNpemUgPSAoX2EgPSB7fSxcbiAgICBfYVtBbmltVmVjdG9yVHlwZS5JTlQxXSA9IDEsXG4gICAgX2FbQW5pbVZlY3RvclR5cGUuRkxPQVQxXSA9IDEsXG4gICAgX2FbQW5pbVZlY3RvclR5cGUuRkxPQVQzXSA9IDMsXG4gICAgX2FbQW5pbVZlY3RvclR5cGUuRkxPQVQ0XSA9IDQsXG4gICAgX2EpO1xuZnVuY3Rpb24gcGFyc2VBbmltS2V5ZnJhbWUoc3RhdGUsIGZyYW1lLCB0eXBlLCBsaW5lVHlwZSkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIEZyYW1lOiBmcmFtZSxcbiAgICAgICAgVmVjdG9yOiBudWxsXG4gICAgfTtcbiAgICB2YXIgVmVjdG9yID0gdHlwZSA9PT0gQW5pbVZlY3RvclR5cGUuSU5UMSA/IEludDMyQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4gICAgdmFyIGl0ZW1Db3VudCA9IGFuaW1WZWN0b3JTaXplW3R5cGVdO1xuICAgIHJlcy5WZWN0b3IgPSBwYXJzZUFycmF5T3JTaW5nbGVJdGVtKHN0YXRlLCBuZXcgVmVjdG9yKGl0ZW1Db3VudCkpO1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgIGlmIChsaW5lVHlwZSA9PT0gbW9kZWxfMS5MaW5lVHlwZS5IZXJtaXRlIHx8IGxpbmVUeXBlID09PSBtb2RlbF8xLkxpbmVUeXBlLkJlemllcikge1xuICAgICAgICBwYXJzZUtleXdvcmQoc3RhdGUpOyAvLyBJblRhblxuICAgICAgICByZXMuSW5UYW4gPSBwYXJzZUFycmF5T3JTaW5nbGVJdGVtKHN0YXRlLCBuZXcgVmVjdG9yKGl0ZW1Db3VudCkpO1xuICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICAgICAgcGFyc2VLZXl3b3JkKHN0YXRlKTsgLy8gT3V0VGFuXG4gICAgICAgIHJlcy5PdXRUYW4gPSBwYXJzZUFycmF5T3JTaW5nbGVJdGVtKHN0YXRlLCBuZXcgVmVjdG9yKGl0ZW1Db3VudCkpO1xuICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlQW5pbVZlY3RvcihzdGF0ZSwgdHlwZSkge1xuICAgIHZhciBhbmltVmVjdG9yID0ge1xuICAgICAgICBMaW5lVHlwZTogbW9kZWxfMS5MaW5lVHlwZS5Eb250SW50ZXJwLFxuICAgICAgICBHbG9iYWxTZXFJZDogbnVsbCxcbiAgICAgICAgS2V5czogW11cbiAgICB9O1xuICAgIHBhcnNlTnVtYmVyKHN0YXRlKTsgLy8gY291bnQsIG5vdCB1c2VkXG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgdmFyIGxpbmVUeXBlID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICBpZiAobGluZVR5cGUgPT09ICdEb250SW50ZXJwJyB8fCBsaW5lVHlwZSA9PT0gJ0xpbmVhcicgfHwgbGluZVR5cGUgPT09ICdIZXJtaXRlJyB8fCBsaW5lVHlwZSA9PT0gJ0JlemllcicpIHtcbiAgICAgICAgYW5pbVZlY3Rvci5MaW5lVHlwZSA9IG1vZGVsXzEuTGluZVR5cGVbbGluZVR5cGVdO1xuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ0dsb2JhbFNlcUlkJykge1xuICAgICAgICAgICAgYW5pbVZlY3RvcltrZXl3b3JkXSA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZyYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGZyYW1lIG51bWJlciBvciBHbG9iYWxTZXFJZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICc6Jyk7XG4gICAgICAgICAgICBhbmltVmVjdG9yLktleXMucHVzaChwYXJzZUFuaW1LZXlmcmFtZShzdGF0ZSwgZnJhbWUsIHR5cGUsIGFuaW1WZWN0b3IuTGluZVR5cGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICByZXR1cm4gYW5pbVZlY3Rvcjtcbn1cbmZ1bmN0aW9uIHBhcnNlTGF5ZXIoc3RhdGUpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBBbHBoYTogbnVsbCxcbiAgICAgICAgVFZlcnRleEFuaW1JZDogbnVsbCxcbiAgICAgICAgU2hhZGluZzogMCxcbiAgICAgICAgQ29vcmRJZDogMFxuICAgIH07XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgd2hpbGUgKHN0YXRlLmNoYXIoKSAhPT0gJ30nKSB7XG4gICAgICAgIHZhciBrZXl3b3JkID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIGlmICgha2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgICAgICBrZXl3b3JkID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3RhdGljICYmIGtleXdvcmQgPT09ICdUZXh0dXJlSUQnKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIEFuaW1WZWN0b3JUeXBlLklOVDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1N0YXRpYyAmJiBrZXl3b3JkID09PSAnQWxwaGEnKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1Vuc2hhZGVkJyB8fCBrZXl3b3JkID09PSAnU3BoZXJlRW52TWFwJyB8fCBrZXl3b3JkID09PSAnVHdvU2lkZWQnIHx8XG4gICAgICAgICAgICBrZXl3b3JkID09PSAnVW5mb2dnZWQnIHx8IGtleXdvcmQgPT09ICdOb0RlcHRoVGVzdCcgfHwga2V5d29yZCA9PT0gJ05vRGVwdGhTZXQnKSB7XG4gICAgICAgICAgICByZXMuU2hhZGluZyB8PSBtb2RlbF8xLkxheWVyU2hhZGluZ1trZXl3b3JkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnRmlsdGVyTW9kZScpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gJ05vbmUnIHx8IHZhbCA9PT0gJ1RyYW5zcGFyZW50JyB8fCB2YWwgPT09ICdCbGVuZCcgfHwgdmFsID09PSAnQWRkaXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgdmFsID09PSAnQWRkQWxwaGEnIHx8IHZhbCA9PT0gJ01vZHVsYXRlJyB8fCB2YWwgPT09ICdNb2R1bGF0ZTJ4Jykge1xuICAgICAgICAgICAgICAgIHJlcy5GaWx0ZXJNb2RlID0gbW9kZWxfMS5GaWx0ZXJNb2RlW3ZhbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1RWZXJ0ZXhBbmltSWQnKSB7XG4gICAgICAgICAgICByZXMuVFZlcnRleEFuaW1JZCA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlTWF0ZXJpYWxzKHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBwYXJzZU51bWJlcihzdGF0ZSk7IC8vIGNvdW50LCBub3QgdXNlZFxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgUmVuZGVyTW9kZTogMCxcbiAgICAgICAgICAgIExheWVyczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VLZXl3b3JkKHN0YXRlKTsgLy8gTWF0ZXJpYWxcbiAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFrZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ0xheWVyJykge1xuICAgICAgICAgICAgICAgIG9iai5MYXllcnMucHVzaChwYXJzZUxheWVyKHN0YXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnUHJpb3JpdHlQbGFuZScpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5d29yZF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnQ29uc3RhbnRDb2xvcicgfHwga2V5d29yZCA9PT0gJ1NvcnRQcmltc0ZhclonIHx8IGtleXdvcmQgPT09ICdGdWxsUmVzb2x1dGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmouUmVuZGVyTW9kZSB8PSBtb2RlbF8xLk1hdGVyaWFsUmVuZGVyTW9kZVtrZXl3b3JkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtYXRlcmlhbCBwcm9wZXJ0eSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICAgICAgcmVzLnB1c2gob2JqKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuTWF0ZXJpYWxzID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VHZW9zZXQoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgVmVydGljZXM6IG51bGwsXG4gICAgICAgIE5vcm1hbHM6IG51bGwsXG4gICAgICAgIFRWZXJ0aWNlczogW10sXG4gICAgICAgIFZlcnRleEdyb3VwOiBudWxsLFxuICAgICAgICBGYWNlczogbnVsbCxcbiAgICAgICAgR3JvdXBzOiBudWxsLFxuICAgICAgICBUb3RhbEdyb3Vwc0NvdW50OiBudWxsLFxuICAgICAgICBNaW5pbXVtRXh0ZW50OiBudWxsLFxuICAgICAgICBNYXhpbXVtRXh0ZW50OiBudWxsLFxuICAgICAgICBCb3VuZHNSYWRpdXM6IG51bGwsXG4gICAgICAgIEFuaW1zOiBbXSxcbiAgICAgICAgTWF0ZXJpYWxJRDogbnVsbCxcbiAgICAgICAgU2VsZWN0aW9uR3JvdXA6IG51bGwsXG4gICAgICAgIFVuc2VsZWN0YWJsZTogZmFsc2VcbiAgICB9O1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIGlmICgha2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdWZXJ0aWNlcycgfHwga2V5d29yZCA9PT0gJ05vcm1hbHMnIHx8IGtleXdvcmQgPT09ICdUVmVydGljZXMnKSB7XG4gICAgICAgICAgICB2YXIgY291bnRQZXJPYmogPSAzO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQgPT09ICdUVmVydGljZXMnKSB7XG4gICAgICAgICAgICAgICAgY291bnRQZXJPYmogPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvdW50ID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICAgICAgdmFyIGFyciA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiBjb3VudFBlck9iaik7XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjb3VudDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIHBhcnNlQXJyYXkoc3RhdGUsIGFyciwgaW5kZXggKiBjb3VudFBlck9iaik7XG4gICAgICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnVFZlcnRpY2VzJykge1xuICAgICAgICAgICAgICAgIHJlcy5UVmVydGljZXMucHVzaChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gYXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdWZXJ0ZXhHcm91cCcpIHtcbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IG5ldyBVaW50OEFycmF5KHJlcy5WZXJ0aWNlcy5sZW5ndGggLyAzKTtcbiAgICAgICAgICAgIHBhcnNlQXJyYXkoc3RhdGUsIHJlc1trZXl3b3JkXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0ZhY2VzJykge1xuICAgICAgICAgICAgcGFyc2VOdW1iZXIoc3RhdGUpOyAvLyBncm91cCBjb3VudCwgYWx3YXlzIDE/XG4gICAgICAgICAgICB2YXIgaW5kZXhDb3VudCA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgICAgIHJlcy5GYWNlcyA9IG5ldyBVaW50MTZBcnJheShpbmRleENvdW50KTtcbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgICAgICAgICAgcGFyc2VLZXl3b3JkKHN0YXRlKTsgLy8gVHJpYW5nbGVzXG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICAgICAgICAgIHBhcnNlQXJyYXkoc3RhdGUsIHJlcy5GYWNlcywgMCk7XG4gICAgICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0dyb3VwcycpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgICAgIHBhcnNlTnVtYmVyKHN0YXRlKTsgLy8gZ3JvdXBzIGNvdW50LCB1bnVzZWRcbiAgICAgICAgICAgIHJlcy5Ub3RhbEdyb3Vwc0NvdW50ID0gcGFyc2VOdW1iZXIoc3RhdGUpOyAvLyBzdW1tZWQgaW4gc3ViYXJyYXlzXG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgIHBhcnNlS2V5d29yZChzdGF0ZSk7IC8vIE1hdHJpY2VzXG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2gocGFyc2VBcnJheShzdGF0ZSkpO1xuICAgICAgICAgICAgICAgIHBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgICAgICAgICByZXMuR3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdNaW5pbXVtRXh0ZW50JyB8fCBrZXl3b3JkID09PSAnTWF4aW11bUV4dGVudCcpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VBcnJheShzdGF0ZSwgYXJyLCAwKTtcbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdCb3VuZHNSYWRpdXMnIHx8IGtleXdvcmQgPT09ICdNYXRlcmlhbElEJyB8fCBrZXl3b3JkID09PSAnU2VsZWN0aW9uR3JvdXAnKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnQW5pbScpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBhcnNlT2JqZWN0KHN0YXRlKSwgdW51c2VkID0gX2FbMF0sIG9iaiA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKG9iai5BbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqLkFscGhhID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5Bbmltcy5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1Vuc2VsZWN0YWJsZScpIHtcbiAgICAgICAgICAgIHJlcy5VbnNlbGVjdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuR2Vvc2V0cy5wdXNoKHJlcyk7XG59XG5mdW5jdGlvbiBwYXJzZUdlb3NldEFuaW0oc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgR2Vvc2V0SWQ6IC0xLFxuICAgICAgICBBbHBoYTogMSxcbiAgICAgICAgQ29sb3I6IG51bGwsXG4gICAgICAgIEZsYWdzOiAwXG4gICAgfTtcbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFrZXl3b3JkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXl3b3JkID09PSAnQWxwaGEnKSB7XG4gICAgICAgICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICByZXMuQWxwaGEgPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuQWxwaGEgPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0NvbG9yJykge1xuICAgICAgICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgICAgICAgICByZXMuQ29sb3IgPSBwYXJzZUFycmF5KHN0YXRlLCBhcnJheSwgMCk7XG4gICAgICAgICAgICAgICAgcmVzLkNvbG9yLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5Db2xvciA9IHBhcnNlQW5pbVZlY3RvcihzdGF0ZSwgQW5pbVZlY3RvclR5cGUuRkxPQVQzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcmVzLkNvbG9yLktleXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGtleS5WZWN0b3IucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LkluVGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuSW5UYW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5Lk91dFRhbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0Ryb3BTaGFkb3cnKSB7XG4gICAgICAgICAgICByZXMuRmxhZ3MgfD0gbW9kZWxfMS5HZW9zZXRBbmltRmxhZ3Nba2V5d29yZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgfVxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgIG1vZGVsLkdlb3NldEFuaW1zLnB1c2gocmVzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTm9kZShzdGF0ZSwgdHlwZSwgbW9kZWwpIHtcbiAgICB2YXIgbmFtZSA9IHBhcnNlU3RyaW5nKHN0YXRlKTtcbiAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgTmFtZTogbmFtZSxcbiAgICAgICAgT2JqZWN0SWQ6IG51bGwsXG4gICAgICAgIFBhcmVudDogbnVsbCxcbiAgICAgICAgUGl2b3RQb2ludDogbnVsbCxcbiAgICAgICAgRmxhZ3M6IG1vZGVsXzEuTm9kZVR5cGVbdHlwZV1cbiAgICB9O1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIGlmICgha2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdUcmFuc2xhdGlvbicgfHwga2V5d29yZCA9PT0gJ1JvdGF0aW9uJyB8fCBrZXl3b3JkID09PSAnU2NhbGluZycgfHwga2V5d29yZCA9PT0gJ1Zpc2liaWxpdHknKSB7XG4gICAgICAgICAgICB2YXIgdmVjdG9yVHlwZSA9IEFuaW1WZWN0b3JUeXBlLkZMT0FUMztcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnUm90YXRpb24nKSB7XG4gICAgICAgICAgICAgICAgdmVjdG9yVHlwZSA9IEFuaW1WZWN0b3JUeXBlLkZMT0FUNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdWaXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgICAgIHZlY3RvclR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlW2tleXdvcmRdID0gcGFyc2VBbmltVmVjdG9yKHN0YXRlLCB2ZWN0b3JUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnQmlsbGJvYXJkZWRMb2NrWicgfHwga2V5d29yZCA9PT0gJ0JpbGxib2FyZGVkTG9ja1knIHx8IGtleXdvcmQgPT09ICdCaWxsYm9hcmRlZExvY2tYJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ0JpbGxib2FyZGVkJyB8fCBrZXl3b3JkID09PSAnQ2FtZXJhQW5jaG9yZWQnKSB7XG4gICAgICAgICAgICBub2RlLkZsYWdzIHw9IG1vZGVsXzEuTm9kZUZsYWdzW2tleXdvcmRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdEb250SW5oZXJpdCcpIHtcbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsID09PSAnVHJhbnNsYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5GbGFncyB8PSBtb2RlbF8xLk5vZGVGbGFncy5Eb250SW5oZXJpdFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID09PSAnUm90YXRpb24nKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5GbGFncyB8PSBtb2RlbF8xLk5vZGVGbGFncy5Eb250SW5oZXJpdFJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID09PSAnU2NhbGluZycpIHtcbiAgICAgICAgICAgICAgICBub2RlLkZsYWdzIHw9IG1vZGVsXzEuTm9kZUZsYWdzLkRvbnRJbmhlcml0U2NhbGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdQYXRoJykge1xuICAgICAgICAgICAgbm9kZVtrZXl3b3JkXSA9IHBhcnNlU3RyaW5nKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUtleXdvcmQoc3RhdGUpIHx8IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnR2Vvc2V0SWQnICYmIHZhbCA9PT0gJ011bHRpcGxlJyB8fFxuICAgICAgICAgICAgICAgIGtleXdvcmQgPT09ICdHZW9zZXRBbmltSWQnICYmIHZhbCA9PT0gJ05vbmUnKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVba2V5d29yZF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgfVxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgIG1vZGVsLk5vZGVzW25vZGUuT2JqZWN0SWRdID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9uZShzdGF0ZSwgbW9kZWwpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlTm9kZShzdGF0ZSwgJ0JvbmUnLCBtb2RlbCk7XG4gICAgbW9kZWwuQm9uZXMucHVzaChub2RlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSGVscGVyKHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciBub2RlID0gcGFyc2VOb2RlKHN0YXRlLCAnSGVscGVyJywgbW9kZWwpO1xuICAgIG1vZGVsLkhlbHBlcnMucHVzaChub2RlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXR0YWNobWVudChzdGF0ZSwgbW9kZWwpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlTm9kZShzdGF0ZSwgJ0F0dGFjaG1lbnQnLCBtb2RlbCk7XG4gICAgbW9kZWwuQXR0YWNobWVudHMucHVzaChub2RlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGl2b3RQb2ludHMoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIGNvdW50ID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2gocGFyc2VBcnJheShzdGF0ZSwgbmV3IEZsb2F0MzJBcnJheSgzKSwgMCkpO1xuICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuUGl2b3RQb2ludHMgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50T2JqZWN0KHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciBuYW1lID0gcGFyc2VTdHJpbmcoc3RhdGUpO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIE5hbWU6IG5hbWUsXG4gICAgICAgIE9iamVjdElkOiBudWxsLFxuICAgICAgICBQYXJlbnQ6IG51bGwsXG4gICAgICAgIFBpdm90UG9pbnQ6IG51bGwsXG4gICAgICAgIEV2ZW50VHJhY2s6IG51bGwsXG4gICAgICAgIEZsYWdzOiBtb2RlbF8xLk5vZGVUeXBlLkV2ZW50T2JqZWN0XG4gICAgfTtcbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICBpZiAoIWtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXl3b3JkID09PSAnRXZlbnRUcmFjaycpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHBhcnNlTnVtYmVyKHN0YXRlKTsgLy8gRXZlbnRUcmFjayBjb3VudFxuICAgICAgICAgICAgcmVzLkV2ZW50VHJhY2sgPSBwYXJzZUFycmF5KHN0YXRlLCBuZXcgVWludDMyQXJyYXkoY291bnQpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnVHJhbnNsYXRpb24nIHx8IGtleXdvcmQgPT09ICdSb3RhdGlvbicgfHwga2V5d29yZCA9PT0gJ1NjYWxpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGtleXdvcmQgPT09ICdSb3RhdGlvbicgPyBBbmltVmVjdG9yVHlwZS5GTE9BVDQgOiBBbmltVmVjdG9yVHlwZS5GTE9BVDM7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICBtb2RlbC5FdmVudE9iamVjdHMucHVzaChyZXMpO1xuICAgIG1vZGVsLk5vZGVzLnB1c2gocmVzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29sbGlzaW9uU2hhcGUoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIG5hbWUgPSBwYXJzZVN0cmluZyhzdGF0ZSk7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgTmFtZTogbmFtZSxcbiAgICAgICAgT2JqZWN0SWQ6IG51bGwsXG4gICAgICAgIFBhcmVudDogbnVsbCxcbiAgICAgICAgUGl2b3RQb2ludDogbnVsbCxcbiAgICAgICAgU2hhcGU6IG1vZGVsXzEuQ29sbGlzaW9uU2hhcGVUeXBlLkJveCxcbiAgICAgICAgVmVydGljZXM6IG51bGwsXG4gICAgICAgIEZsYWdzOiBtb2RlbF8xLk5vZGVUeXBlLkNvbGxpc2lvblNoYXBlXG4gICAgfTtcbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICBpZiAoIWtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXl3b3JkID09PSAnU3BoZXJlJykge1xuICAgICAgICAgICAgcmVzLlNoYXBlID0gbW9kZWxfMS5Db2xsaXNpb25TaGFwZVR5cGUuU3BoZXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdCb3gnKSB7XG4gICAgICAgICAgICByZXMuU2hhcGUgPSBtb2RlbF8xLkNvbGxpc2lvblNoYXBlVHlwZS5Cb3g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1ZlcnRpY2VzJykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIDMpO1xuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFycmF5KHN0YXRlLCB2ZXJ0aWNlcywgaSAqIDMpO1xuICAgICAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgICAgICAgICByZXMuVmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnVHJhbnNsYXRpb24nIHx8IGtleXdvcmQgPT09ICdSb3RhdGlvbicgfHwga2V5d29yZCA9PT0gJ1NjYWxpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGtleXdvcmQgPT09ICdSb3RhdGlvbicgPyBBbmltVmVjdG9yVHlwZS5GTE9BVDQgOiBBbmltVmVjdG9yVHlwZS5GTE9BVDM7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICBtb2RlbC5Db2xsaXNpb25TaGFwZXMucHVzaChyZXMpO1xuICAgIG1vZGVsLk5vZGVzLnB1c2gocmVzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlR2xvYmFsU2VxdWVuY2VzKHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgY291bnQgPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBrZXl3b3JkID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdEdXJhdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHBhcnNlTnVtYmVyKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgfVxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgIG1vZGVsLkdsb2JhbFNlcXVlbmNlcyA9IHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlVW5rbm93bkJsb2NrKHN0YXRlKSB7XG4gICAgdmFyIG9wZW5lZDtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSB1bmRlZmluZWQgJiYgc3RhdGUuY2hhcigpICE9PSAneycpIHtcbiAgICAgICAgKytzdGF0ZS5wb3M7XG4gICAgfVxuICAgIG9wZW5lZCA9IDE7XG4gICAgKytzdGF0ZS5wb3M7XG4gICAgd2hpbGUgKHN0YXRlLmNoYXIoKSAhPT0gdW5kZWZpbmVkICYmIG9wZW5lZCA+IDApIHtcbiAgICAgICAgaWYgKHN0YXRlLmNoYXIoKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICArK29wZW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyKCkgPT09ICd9Jykge1xuICAgICAgICAgICAgLS1vcGVuZWQ7XG4gICAgICAgIH1cbiAgICAgICAgKytzdGF0ZS5wb3M7XG4gICAgfVxuICAgIHBhcnNlU3BhY2Uoc3RhdGUpO1xufVxuZnVuY3Rpb24gcGFyc2VQYXJ0aWNsZUVtaXR0ZXIoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgT2JqZWN0SWQ6IG51bGwsXG4gICAgICAgIFBhcmVudDogbnVsbCxcbiAgICAgICAgTmFtZTogbnVsbCxcbiAgICAgICAgRmxhZ3M6IDBcbiAgICB9O1xuICAgIHJlcy5OYW1lID0gcGFyc2VTdHJpbmcoc3RhdGUpO1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXl3b3JkID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdPYmplY3RJZCcgfHwga2V5d29yZCA9PT0gJ1BhcmVudCcpIHtcbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnRW1pdHRlclVzZXNNREwnIHx8IGtleXdvcmQgPT09ICdFbWl0dGVyVXNlc1RHQScpIHtcbiAgICAgICAgICAgIHJlcy5GbGFncyB8PSBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlckZsYWdzW2tleXdvcmRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1N0YXRpYyAmJiAoa2V5d29yZCA9PT0gJ1Zpc2liaWxpdHknIHx8IGtleXdvcmQgPT09ICdUcmFuc2xhdGlvbicgfHwga2V5d29yZCA9PT0gJ1JvdGF0aW9uJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ1NjYWxpbmcnIHx8IGtleXdvcmQgPT09ICdFbWlzc2lvblJhdGUnIHx8IGtleXdvcmQgPT09ICdHcmF2aXR5JyB8fCBrZXl3b3JkID09PSAnTG9uZ2l0dWRlJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ0xhdGl0dWRlJykpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gQW5pbVZlY3RvclR5cGUuRkxPQVQzO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQgPT09ICdWaXNpYmlsaXR5JyB8fCBrZXl3b3JkID09PSAnRW1pc3Npb25SYXRlJyB8fCBrZXl3b3JkID09PSAnR3Jhdml0eScgfHxcbiAgICAgICAgICAgICAgICBrZXl3b3JkID09PSAnTG9uZ2l0dWRlJyB8fCBrZXl3b3JkID09PSAnTGF0aXR1ZGUnKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IEFuaW1WZWN0b3JUeXBlLkZMT0FUMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdSb3RhdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gQW5pbVZlY3RvclR5cGUuRkxPQVQ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VBbmltVmVjdG9yKHN0YXRlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnUGFydGljbGUnKSB7XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgIHZhciBrZXl3b3JkMiA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3RhdGljMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChrZXl3b3JkMiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTdGF0aWMyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDIgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljMiAmJiAoa2V5d29yZDIgPT09ICdMaWZlU3BhbicgfHwga2V5d29yZDIgPT09ICdJbml0VmVsb2NpdHknKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNba2V5d29yZDJdID0gcGFyc2VBbmltVmVjdG9yKHN0YXRlLCBBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkMiA9PT0gJ0xpZmVTcGFuJyB8fCBrZXl3b3JkMiA9PT0gJ0luaXRWZWxvY2l0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleXdvcmQyXSA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZDIgPT09ICdQYXRoJykge1xuICAgICAgICAgICAgICAgICAgICByZXMuUGF0aCA9IHBhcnNlU3RyaW5nKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuUGFydGljbGVFbWl0dGVycy5wdXNoKHJlcyk7XG59XG5mdW5jdGlvbiBwYXJzZVBhcnRpY2xlRW1pdHRlcjIoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIG5hbWUgPSBwYXJzZVN0cmluZyhzdGF0ZSk7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgTmFtZTogbmFtZSxcbiAgICAgICAgT2JqZWN0SWQ6IG51bGwsXG4gICAgICAgIFBhcmVudDogbnVsbCxcbiAgICAgICAgUGl2b3RQb2ludDogbnVsbCxcbiAgICAgICAgRmxhZ3M6IG1vZGVsXzEuTm9kZVR5cGUuUGFydGljbGVFbWl0dGVyLFxuICAgICAgICBGcmFtZUZsYWdzOiAwXG4gICAgfTtcbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFrZXl3b3JkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdGF0aWMgJiYgKGtleXdvcmQgPT09ICdTcGVlZCcgfHwga2V5d29yZCA9PT0gJ0xhdGl0dWRlJyB8fCBrZXl3b3JkID09PSAnVmlzaWJpbGl0eScgfHxcbiAgICAgICAgICAgIGtleXdvcmQgPT09ICdFbWlzc2lvblJhdGUnIHx8IGtleXdvcmQgPT09ICdXaWR0aCcgfHwga2V5d29yZCA9PT0gJ0xlbmd0aCcgfHwga2V5d29yZCA9PT0gJ1RyYW5zbGF0aW9uJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ1JvdGF0aW9uJyB8fCBrZXl3b3JkID09PSAnU2NhbGluZycgfHwga2V5d29yZCA9PT0gJ0dyYXZpdHknIHx8IGtleXdvcmQgPT09ICdWYXJpYXRpb24nKSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDM7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdSb3RhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NwZWVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdMYXRpdHVkZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnVmlzaWJpbGl0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRW1pc3Npb25SYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdXaWR0aCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnTGVuZ3RoJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHcmF2aXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdWYXJpYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gQW5pbVZlY3RvclR5cGUuRkxPQVQxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IHBhcnNlQW5pbVZlY3RvcihzdGF0ZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1ZhcmlhdGlvbicgfHwga2V5d29yZCA9PT0gJ0dyYXZpdHknKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1NvcnRQcmltc0ZhclonIHx8IGtleXdvcmQgPT09ICdVbnNoYWRlZCcgfHwga2V5d29yZCA9PT0gJ0xpbmVFbWl0dGVyJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ1VuZm9nZ2VkJyB8fCBrZXl3b3JkID09PSAnTW9kZWxTcGFjZScgfHwga2V5d29yZCA9PT0gJ1hZUXVhZCcpIHtcbiAgICAgICAgICAgIHJlcy5GbGFncyB8PSBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGbGFnc1trZXl3b3JkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnQm90aCcpIHtcbiAgICAgICAgICAgIHJlcy5GcmFtZUZsYWdzIHw9IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLkhlYWQgfCBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncy5UYWlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdIZWFkJyB8fCBrZXl3b3JkID09PSAnVGFpbCcpIHtcbiAgICAgICAgICAgIHJlcy5GcmFtZUZsYWdzIHw9IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzW2tleXdvcmRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdTcXVpcnQnKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdEb250SW5oZXJpdCcpIHtcbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsID09PSAnVHJhbnNsYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzLkZsYWdzIHw9IG1vZGVsXzEuTm9kZUZsYWdzLkRvbnRJbmhlcml0VHJhbnNsYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPT09ICdSb3RhdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXMuRmxhZ3MgfD0gbW9kZWxfMS5Ob2RlRmxhZ3MuRG9udEluaGVyaXRSb3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gJ1NjYWxpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzLkZsYWdzIHw9IG1vZGVsXzEuTm9kZUZsYWdzLkRvbnRJbmhlcml0U2NhbGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdTZWdtZW50Q29sb3InKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JzID0gW107XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ3snKTtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgIHBhcnNlS2V5d29yZChzdGF0ZSk7IC8vIENvbG9yXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgICAgICAgICBwYXJzZUFycmF5KHN0YXRlLCBjb2xvckFyciwgMCk7XG4gICAgICAgICAgICAgICAgLy8gYmdyIG9yZGVyLCBpbnZlcnNlIGZyb20gbWR4XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBjb2xvckFyclswXTtcbiAgICAgICAgICAgICAgICBjb2xvckFyclswXSA9IGNvbG9yQXJyWzJdO1xuICAgICAgICAgICAgICAgIGNvbG9yQXJyWzJdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChjb2xvckFycik7XG4gICAgICAgICAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICAgICAgICAgIHJlcy5TZWdtZW50Q29sb3IgPSBjb2xvcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0FscGhhJykge1xuICAgICAgICAgICAgcmVzLkFscGhhID0gbmV3IFVpbnQ4QXJyYXkoMyk7XG4gICAgICAgICAgICBwYXJzZUFycmF5KHN0YXRlLCByZXMuQWxwaGEsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdQYXJ0aWNsZVNjYWxpbmcnKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAgICAgcGFyc2VBcnJheShzdGF0ZSwgcmVzW2tleXdvcmRdLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnTGlmZVNwYW5VVkFuaW0nIHx8IGtleXdvcmQgPT09ICdEZWNheVVWQW5pbScgfHwga2V5d29yZCA9PT0gJ1RhaWxVVkFuaW0nIHx8XG4gICAgICAgICAgICBrZXl3b3JkID09PSAnVGFpbERlY2F5VVZBbmltJykge1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gbmV3IFVpbnQzMkFycmF5KDMpO1xuICAgICAgICAgICAgcGFyc2VBcnJheShzdGF0ZSwgcmVzW2tleXdvcmRdLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnVHJhbnNwYXJlbnQnIHx8IGtleXdvcmQgPT09ICdCbGVuZCcgfHwga2V5d29yZCA9PT0gJ0FkZGl0aXZlJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ0FscGhhS2V5JyB8fCBrZXl3b3JkID09PSAnTW9kdWxhdGUnIHx8IGtleXdvcmQgPT09ICdNb2R1bGF0ZTJ4Jykge1xuICAgICAgICAgICAgcmVzLkZpbHRlck1vZGUgPSBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlW2tleXdvcmRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICBtb2RlbC5QYXJ0aWNsZUVtaXR0ZXJzMi5wdXNoKHJlcyk7XG4gICAgbW9kZWwuTm9kZXMucHVzaChyZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VDYW1lcmEoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgTmFtZTogbnVsbCxcbiAgICAgICAgUG9zaXRpb246IG51bGwsXG4gICAgICAgIEZpZWxkT2ZWaWV3OiAwLFxuICAgICAgICBOZWFyQ2xpcDogMCxcbiAgICAgICAgRmFyQ2xpcDogMCxcbiAgICAgICAgVGFyZ2V0UG9zaXRpb246IG51bGxcbiAgICB9O1xuICAgIHJlcy5OYW1lID0gcGFyc2VTdHJpbmcoc3RhdGUpO1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIGlmICgha2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdQb3NpdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy5Qb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgICAgICBwYXJzZUFycmF5KHN0YXRlLCByZXMuUG9zaXRpb24sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdGaWVsZE9mVmlldycgfHwga2V5d29yZCA9PT0gJ05lYXJDbGlwJyB8fCBrZXl3b3JkID09PSAnRmFyQ2xpcCcpIHtcbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IHBhcnNlTnVtYmVyKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnVGFyZ2V0Jykge1xuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgICAgICAgICB3aGlsZSAoc3RhdGUuY2hhcigpICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5d29yZDIgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChrZXl3b3JkMiA9PT0gJ1Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXMuVGFyZ2V0UG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUFycmF5KHN0YXRlLCByZXMuVGFyZ2V0UG9zaXRpb24sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkMiA9PT0gJ1RyYW5zbGF0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXMuVGFyZ2V0VHJhbnNsYXRpb24gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIEFuaW1WZWN0b3JUeXBlLkZMT0FUMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ1RyYW5zbGF0aW9uJyB8fCBrZXl3b3JkID09PSAnUm90YXRpb24nKSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIGtleXdvcmQgPT09ICdSb3RhdGlvbicgP1xuICAgICAgICAgICAgICAgIEFuaW1WZWN0b3JUeXBlLkZMT0FUMSA6XG4gICAgICAgICAgICAgICAgQW5pbVZlY3RvclR5cGUuRkxPQVQzKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuQ2FtZXJhcy5wdXNoKHJlcyk7XG59XG5mdW5jdGlvbiBwYXJzZUxpZ2h0KHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciBuYW1lID0gcGFyc2VTdHJpbmcoc3RhdGUpO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIE5hbWU6IG5hbWUsXG4gICAgICAgIE9iamVjdElkOiBudWxsLFxuICAgICAgICBQYXJlbnQ6IG51bGwsXG4gICAgICAgIFBpdm90UG9pbnQ6IG51bGwsXG4gICAgICAgIEZsYWdzOiBtb2RlbF8xLk5vZGVUeXBlLkxpZ2h0LFxuICAgICAgICBMaWdodFR5cGU6IDBcbiAgICB9O1xuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAneycpO1xuICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICB2YXIga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXl3b3JkID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0YXRpYyAmJiAoa2V5d29yZCA9PT0gJ1Zpc2liaWxpdHknIHx8IGtleXdvcmQgPT09ICdDb2xvcicgfHwga2V5d29yZCA9PT0gJ0ludGVuc2l0eScgfHxcbiAgICAgICAgICAgIGtleXdvcmQgPT09ICdBbWJJbnRlbnNpdHknIHx8IGtleXdvcmQgPT09ICdBbWJDb2xvcicgfHwga2V5d29yZCA9PT0gJ1RyYW5zbGF0aW9uJyB8fFxuICAgICAgICAgICAga2V5d29yZCA9PT0gJ1JvdGF0aW9uJyB8fCBrZXl3b3JkID09PSAnU2NhbGluZycgfHwga2V5d29yZCA9PT0gJ0F0dGVudWF0aW9uU3RhcnQnIHx8XG4gICAgICAgICAgICBrZXl3b3JkID09PSAnQXR0ZW51YXRpb25FbmQnKSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDM7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdSb3RhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1Zpc2liaWxpdHknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0ludGVuc2l0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnQW1iSW50ZW5zaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdBdHRlbnVhdGlvblN0YXJ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdBdHRlbnVhdGlvbkVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VBbmltVmVjdG9yKHN0YXRlLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnQ29sb3InIHx8IGtleXdvcmQgPT09ICdBbWJDb2xvcicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcmVzW2tleXdvcmRdLktleXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGtleS5WZWN0b3IucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LkluVGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuSW5UYW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5Lk91dFRhbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ09tbmlkaXJlY3Rpb25hbCcgfHwga2V5d29yZCA9PT0gJ0RpcmVjdGlvbmFsJyB8fCBrZXl3b3JkID09PSAnQW1iaWVudCcpIHtcbiAgICAgICAgICAgIHJlcy5MaWdodFR5cGUgPSBtb2RlbF8xLkxpZ2h0VHlwZVtrZXl3b3JkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnQ29sb3InIHx8IGtleXdvcmQgPT09ICdBbWJDb2xvcicpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgICAgICBwYXJzZUFycmF5KHN0YXRlLCBjb2xvciwgMCk7XG4gICAgICAgICAgICAvLyBiZ3Igb3JkZXIsIGludmVyc2UgZnJvbSBtZHhcbiAgICAgICAgICAgIHZhciB0ZW1wID0gY29sb3JbMF07XG4gICAgICAgICAgICBjb2xvclswXSA9IGNvbG9yWzJdO1xuICAgICAgICAgICAgY29sb3JbMl0gPSB0ZW1wO1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNba2V5d29yZF0gPSBwYXJzZU51bWJlcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTeW1ib2woc3RhdGUsICcsJyk7XG4gICAgfVxuICAgIHN0cmljdFBhcnNlU3ltYm9sKHN0YXRlLCAnfScpO1xuICAgIG1vZGVsLkxpZ2h0cy5wdXNoKHJlcyk7XG4gICAgbW9kZWwuTm9kZXMucHVzaChyZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VUZXh0dXJlQW5pbXMoc3RhdGUsIG1vZGVsKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHBhcnNlTnVtYmVyKHN0YXRlKTsgLy8gY291bnQsIG5vdCB1c2VkXG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgd2hpbGUgKHN0YXRlLmNoYXIoKSAhPT0gJ30nKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgcGFyc2VLZXl3b3JkKHN0YXRlKTsgLy8gVFZlcnRleEFuaW1cbiAgICAgICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5jaGFyKCkgIT09ICd9Jykge1xuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBwYXJzZUtleXdvcmQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFrZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ1RyYW5zbGF0aW9uJyB8fCBrZXl3b3JkID09PSAnUm90YXRpb24nIHx8IGtleXdvcmQgPT09ICdTY2FsaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0ga2V5d29yZCA9PT0gJ1JvdGF0aW9uJyA/IEFuaW1WZWN0b3JUeXBlLkZMT0FUNCA6IEFuaW1WZWN0b3JUeXBlLkZMT0FUMztcbiAgICAgICAgICAgICAgICBvYmpba2V5d29yZF0gPSBwYXJzZUFuaW1WZWN0b3Ioc3RhdGUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRleHR1cmUgYW5pbSBwcm9wZXJ0eSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVN5bWJvbChzdGF0ZSwgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICAgICAgcmVzLnB1c2gob2JqKTtcbiAgICB9XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd9Jyk7XG4gICAgbW9kZWwuVGV4dHVyZUFuaW1zID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VSaWJib25FbWl0dGVyKHN0YXRlLCBtb2RlbCkge1xuICAgIHZhciBuYW1lID0gcGFyc2VTdHJpbmcoc3RhdGUpO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIE5hbWU6IG5hbWUsXG4gICAgICAgIE9iamVjdElkOiBudWxsLFxuICAgICAgICBQYXJlbnQ6IG51bGwsXG4gICAgICAgIFBpdm90UG9pbnQ6IG51bGwsXG4gICAgICAgIEZsYWdzOiBtb2RlbF8xLk5vZGVUeXBlLlJpYmJvbkVtaXR0ZXIsXG4gICAgICAgIEhlaWdodEFib3ZlOiBudWxsLFxuICAgICAgICBIZWlnaHRCZWxvdzogbnVsbCxcbiAgICAgICAgQWxwaGE6IG51bGwsXG4gICAgICAgIENvbG9yOiBudWxsLFxuICAgICAgICBMaWZlU3BhbjogbnVsbCxcbiAgICAgICAgVGV4dHVyZVNsb3Q6IG51bGwsXG4gICAgICAgIEVtaXNzaW9uUmF0ZTogbnVsbCxcbiAgICAgICAgUm93czogbnVsbCxcbiAgICAgICAgQ29sdW1uczogbnVsbCxcbiAgICAgICAgTWF0ZXJpYWxJRDogbnVsbCxcbiAgICAgICAgR3Jhdml0eTogbnVsbCxcbiAgICAgICAgVmlzaWJpbGl0eTogbnVsbFxuICAgIH07XG4gICAgc3RyaWN0UGFyc2VTeW1ib2woc3RhdGUsICd7Jyk7XG4gICAgd2hpbGUgKHN0YXRlLmNoYXIoKSAhPT0gJ30nKSB7XG4gICAgICAgIHZhciBrZXl3b3JkID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIGlmICgha2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXdvcmQgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgICAgICBrZXl3b3JkID0gcGFyc2VLZXl3b3JkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3RhdGljICYmIChrZXl3b3JkID09PSAnVmlzaWJpbGl0eScgfHwga2V5d29yZCA9PT0gJ0hlaWdodEFib3ZlJyB8fCBrZXl3b3JkID09PSAnSGVpZ2h0QmVsb3cnIHx8XG4gICAgICAgICAgICBrZXl3b3JkID09PSAnVHJhbnNsYXRpb24nIHx8IGtleXdvcmQgPT09ICdSb3RhdGlvbicgfHwga2V5d29yZCA9PT0gJ1NjYWxpbmcnIHx8IGtleXdvcmQgPT09ICdBbHBoYScgfHxcbiAgICAgICAgICAgIGtleXdvcmQgPT09ICdUZXh0dXJlU2xvdCcpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IEFuaW1WZWN0b3JUeXBlLkZMT0FUMztcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5d29yZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEFuaW1WZWN0b3JUeXBlLkZMT0FUNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVmlzaWJpbGl0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnSGVpZ2h0QWJvdmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0hlaWdodEJlbG93JzpcbiAgICAgICAgICAgICAgICBjYXNlICdBbHBoYSc6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBBbmltVmVjdG9yVHlwZS5GTE9BVDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RleHR1cmVTbG90JzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEFuaW1WZWN0b3JUeXBlLklOVDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VBbmltVmVjdG9yKHN0YXRlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnQ29sb3InKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAgICAgcGFyc2VBcnJheShzdGF0ZSwgY29sb3IsIDApO1xuICAgICAgICAgICAgLy8gYmdyIG9yZGVyLCBpbnZlcnNlIGZyb20gbWR4XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGNvbG9yWzBdO1xuICAgICAgICAgICAgY29sb3JbMF0gPSBjb2xvclsyXTtcbiAgICAgICAgICAgIGNvbG9yWzJdID0gdGVtcDtcbiAgICAgICAgICAgIHJlc1trZXl3b3JkXSA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gcGFyc2VOdW1iZXIoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlU3ltYm9sKHN0YXRlLCAnLCcpO1xuICAgIH1cbiAgICBzdHJpY3RQYXJzZVN5bWJvbChzdGF0ZSwgJ30nKTtcbiAgICBtb2RlbC5SaWJib25FbWl0dGVycy5wdXNoKHJlcyk7XG4gICAgbW9kZWwuTm9kZXMucHVzaChyZXMpO1xufVxudmFyIHBhcnNlcnMgPSB7XG4gICAgVmVyc2lvbjogcGFyc2VWZXJzaW9uLFxuICAgIE1vZGVsOiBwYXJzZU1vZGVsSW5mbyxcbiAgICBTZXF1ZW5jZXM6IHBhcnNlU2VxdWVuY2VzLFxuICAgIFRleHR1cmVzOiBwYXJzZVRleHR1cmVzLFxuICAgIE1hdGVyaWFsczogcGFyc2VNYXRlcmlhbHMsXG4gICAgR2Vvc2V0OiBwYXJzZUdlb3NldCxcbiAgICBHZW9zZXRBbmltOiBwYXJzZUdlb3NldEFuaW0sXG4gICAgQm9uZTogcGFyc2VCb25lLFxuICAgIEhlbHBlcjogcGFyc2VIZWxwZXIsXG4gICAgQXR0YWNobWVudDogcGFyc2VBdHRhY2htZW50LFxuICAgIFBpdm90UG9pbnRzOiBwYXJzZVBpdm90UG9pbnRzLFxuICAgIEV2ZW50T2JqZWN0OiBwYXJzZUV2ZW50T2JqZWN0LFxuICAgIENvbGxpc2lvblNoYXBlOiBwYXJzZUNvbGxpc2lvblNoYXBlLFxuICAgIEdsb2JhbFNlcXVlbmNlczogcGFyc2VHbG9iYWxTZXF1ZW5jZXMsXG4gICAgUGFydGljbGVFbWl0dGVyOiBwYXJzZVBhcnRpY2xlRW1pdHRlcixcbiAgICBQYXJ0aWNsZUVtaXR0ZXIyOiBwYXJzZVBhcnRpY2xlRW1pdHRlcjIsXG4gICAgQ2FtZXJhOiBwYXJzZUNhbWVyYSxcbiAgICBMaWdodDogcGFyc2VMaWdodCxcbiAgICBUZXh0dXJlQW5pbXM6IHBhcnNlVGV4dHVyZUFuaW1zLFxuICAgIFJpYmJvbkVtaXR0ZXI6IHBhcnNlUmliYm9uRW1pdHRlclxufTtcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShzdHIpO1xuICAgIHZhciBtb2RlbCA9IHtcbiAgICAgICAgLy8gZGVmYXVsdFxuICAgICAgICBWZXJzaW9uOiA4MDAsXG4gICAgICAgIEluZm86IHtcbiAgICAgICAgICAgIE5hbWU6ICcnLFxuICAgICAgICAgICAgTWluaW11bUV4dGVudDogbnVsbCxcbiAgICAgICAgICAgIE1heGltdW1FeHRlbnQ6IG51bGwsXG4gICAgICAgICAgICBCb3VuZHNSYWRpdXM6IDAsXG4gICAgICAgICAgICBCbGVuZFRpbWU6IDE1MFxuICAgICAgICB9LFxuICAgICAgICBTZXF1ZW5jZXM6IFtdLFxuICAgICAgICBHbG9iYWxTZXF1ZW5jZXM6IFtdLFxuICAgICAgICBUZXh0dXJlczogW10sXG4gICAgICAgIE1hdGVyaWFsczogW10sXG4gICAgICAgIFRleHR1cmVBbmltczogW10sXG4gICAgICAgIEdlb3NldHM6IFtdLFxuICAgICAgICBHZW9zZXRBbmltczogW10sXG4gICAgICAgIEJvbmVzOiBbXSxcbiAgICAgICAgSGVscGVyczogW10sXG4gICAgICAgIEF0dGFjaG1lbnRzOiBbXSxcbiAgICAgICAgRXZlbnRPYmplY3RzOiBbXSxcbiAgICAgICAgUGFydGljbGVFbWl0dGVyczogW10sXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlcnMyOiBbXSxcbiAgICAgICAgQ2FtZXJhczogW10sXG4gICAgICAgIExpZ2h0czogW10sXG4gICAgICAgIFJpYmJvbkVtaXR0ZXJzOiBbXSxcbiAgICAgICAgQ29sbGlzaW9uU2hhcGVzOiBbXSxcbiAgICAgICAgUGl2b3RQb2ludHM6IFtdLFxuICAgICAgICBOb2RlczogW11cbiAgICB9O1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zdHIubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChwYXJzZUNvbW1lbnQoc3RhdGUpKVxuICAgICAgICAgICAgO1xuICAgICAgICB2YXIga2V5d29yZCA9IHBhcnNlS2V5d29yZChzdGF0ZSk7XG4gICAgICAgIGlmIChrZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAoa2V5d29yZCBpbiBwYXJzZXJzKSB7XG4gICAgICAgICAgICAgICAgcGFyc2Vyc1trZXl3b3JkXShzdGF0ZSwgbW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VVbmtub3duQmxvY2soc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbC5Ob2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobW9kZWwuUGl2b3RQb2ludHNbaV0pIHtcbiAgICAgICAgICAgIG1vZGVsLk5vZGVzW2ldLlBpdm90UG9pbnQgPSBtb2RlbC5QaXZvdFBvaW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG52YXIgX2E7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uL21vZGVsXCIpO1xudmFyIEJJR19FTkRJQU4gPSB0cnVlO1xudmFyIE5PTkUgPSAtMTtcbnZhciBBbmltVmVjdG9yVHlwZTtcbihmdW5jdGlvbiAoQW5pbVZlY3RvclR5cGUpIHtcbiAgICBBbmltVmVjdG9yVHlwZVtBbmltVmVjdG9yVHlwZVtcIklOVDFcIl0gPSAwXSA9IFwiSU5UMVwiO1xuICAgIEFuaW1WZWN0b3JUeXBlW0FuaW1WZWN0b3JUeXBlW1wiRkxPQVQxXCJdID0gMV0gPSBcIkZMT0FUMVwiO1xuICAgIEFuaW1WZWN0b3JUeXBlW0FuaW1WZWN0b3JUeXBlW1wiRkxPQVQzXCJdID0gMl0gPSBcIkZMT0FUM1wiO1xuICAgIEFuaW1WZWN0b3JUeXBlW0FuaW1WZWN0b3JUeXBlW1wiRkxPQVQ0XCJdID0gM10gPSBcIkZMT0FUNFwiO1xufSkoQW5pbVZlY3RvclR5cGUgfHwgKEFuaW1WZWN0b3JUeXBlID0ge30pKTtcbnZhciBhbmltVmVjdG9yU2l6ZSA9IChfYSA9IHt9LFxuICAgIF9hW0FuaW1WZWN0b3JUeXBlLklOVDFdID0gMSxcbiAgICBfYVtBbmltVmVjdG9yVHlwZS5GTE9BVDFdID0gMSxcbiAgICBfYVtBbmltVmVjdG9yVHlwZS5GTE9BVDNdID0gMyxcbiAgICBfYVtBbmltVmVjdG9yVHlwZS5GTE9BVDRdID0gNCxcbiAgICBfYSk7XG52YXIgU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlKGFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYWIgPSBhcnJheUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmFiKTtcbiAgICAgICAgdGhpcy51aW50ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hYik7XG4gICAgfVxuICAgIFN0YXRlLnByb3RvdHlwZS5rZXl3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnVpbnRbdGhpcy5wb3NdLCB0aGlzLnVpbnRbdGhpcy5wb3MgKyAxXSwgdGhpcy51aW50W3RoaXMucG9zICsgMl0sIHRoaXMudWludFt0aGlzLnBvcyArIDNdKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFN0YXRlLnByb3RvdHlwZS5leHBlY3RLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQsIGVycm9yVGV4dCkge1xuICAgICAgICBpZiAodGhpcy5rZXl3b3JkKCkgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUudWludDggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3MrKyk7XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUudWludDE2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLnBvcywgQklHX0VORElBTik7XG4gICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5wb3MsIEJJR19FTkRJQU4pO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgU3RhdGUucHJvdG90eXBlLmZsb2F0MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLnBvcywgQklHX0VORElBTik7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAvLyBhY3R1YWwgc3RyaW5nIGxlbmd0aFxuICAgICAgICAvLyBkYXRhIG1heSBjb25zaXN0IG9mIFsnYScsICdiJywgJ2MnLCAwLCAwLCAwXVxuICAgICAgICB2YXIgc3RyaW5nTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB3aGlsZSAodGhpcy51aW50W3RoaXMucG9zICsgc3RyaW5nTGVuZ3RoIC0gMV0gPT09IDAgJiYgc3RyaW5nTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLS1zdHJpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gPz9cbiAgICAgICAgLy8gVFMyNDYxOlR5cGUgJ1VpbnQ4QXJyYXknIGlzIG5vdCBhbiBhcnJheSB0eXBlLlxuICAgICAgICAvLyBsZXQgcmVzID0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi50aGlzLnVpbnQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgbGVuZ3RoKSk7XG4gICAgICAgIHZhciByZXMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdGhpcy51aW50LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHN0cmluZ0xlbmd0aCkpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBTdGF0ZS5wcm90b3R5cGUuYW5pbVZlY3RvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICBLZXlzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaXNJbnQgPSB0eXBlID09PSBBbmltVmVjdG9yVHlwZS5JTlQxO1xuICAgICAgICB2YXIgdmVjdG9yU2l6ZSA9IGFuaW1WZWN0b3JTaXplW3R5cGVdO1xuICAgICAgICB2YXIga2V5c0NvdW50ID0gdGhpcy5pbnQzMigpO1xuICAgICAgICByZXMuTGluZVR5cGUgPSB0aGlzLmludDMyKCk7XG4gICAgICAgIHJlcy5HbG9iYWxTZXFJZCA9IHRoaXMuaW50MzIoKTtcbiAgICAgICAgaWYgKHJlcy5HbG9iYWxTZXFJZCA9PT0gTk9ORSkge1xuICAgICAgICAgICAgcmVzLkdsb2JhbFNlcUlkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNDb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYW5pbUtleUZyYW1lID0ge307XG4gICAgICAgICAgICBhbmltS2V5RnJhbWUuRnJhbWUgPSB0aGlzLmludDMyKCk7XG4gICAgICAgICAgICBpZiAoaXNJbnQpIHtcbiAgICAgICAgICAgICAgICBhbmltS2V5RnJhbWUuVmVjdG9yID0gbmV3IEludDMyQXJyYXkodmVjdG9yU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltS2V5RnJhbWUuVmVjdG9yID0gbmV3IEZsb2F0MzJBcnJheSh2ZWN0b3JTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmVjdG9yU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1LZXlGcmFtZS5WZWN0b3Jbal0gPSB0aGlzLmludDMyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmltS2V5RnJhbWUuVmVjdG9yW2pdID0gdGhpcy5mbG9hdDMyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcy5MaW5lVHlwZSA9PT0gbW9kZWxfMS5MaW5lVHlwZS5IZXJtaXRlIHx8IHJlcy5MaW5lVHlwZSA9PT0gbW9kZWxfMS5MaW5lVHlwZS5CZXppZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gWydJblRhbicsICdPdXRUYW4nXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGFuaW1LZXlGcmFtZVtwYXJ0XSA9IG5ldyBGbG9hdDMyQXJyYXkodmVjdG9yU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmVjdG9yU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltS2V5RnJhbWVbcGFydF1bal0gPSB0aGlzLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltS2V5RnJhbWVbcGFydF1bal0gPSB0aGlzLmZsb2F0MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5LZXlzLnB1c2goYW5pbUtleUZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlO1xufSgpKTtcbmZ1bmN0aW9uIHBhcnNlRXh0ZW50KG9iaiwgc3RhdGUpIHtcbiAgICBvYmouQm91bmRzUmFkaXVzID0gc3RhdGUuZmxvYXQzMigpO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBbJ01pbmltdW1FeHRlbnQnLCAnTWF4aW11bUV4dGVudCddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICBvYmpba2V5XSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICBvYmpba2V5XVtpXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVmVyc2lvbihtb2RlbCwgc3RhdGUpIHtcbiAgICBtb2RlbC5WZXJzaW9uID0gc3RhdGUuaW50MzIoKTtcbn1cbnZhciBNT0RFTF9OQU1FX0xFTkdUSCA9IDB4MTUwO1xuZnVuY3Rpb24gcGFyc2VNb2RlbEluZm8obW9kZWwsIHN0YXRlKSB7XG4gICAgbW9kZWwuSW5mby5OYW1lID0gc3RhdGUuc3RyKE1PREVMX05BTUVfTEVOR1RIKTtcbiAgICBzdGF0ZS5pbnQzMigpOyAvLyB1bmtub3duIDQtYnl0ZSBzZXF1ZW5jZVxuICAgIHBhcnNlRXh0ZW50KG1vZGVsLkluZm8sIHN0YXRlKTtcbiAgICBtb2RlbC5JbmZvLkJsZW5kVGltZSA9IHN0YXRlLmludDMyKCk7XG59XG52YXIgTU9ERUxfU0VRVUVOQ0VfTkFNRV9MRU5HVEggPSAweDUwO1xuZnVuY3Rpb24gcGFyc2VTZXF1ZW5jZXMobW9kZWwsIHN0YXRlLCBzaXplKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvcyArIHNpemUpIHtcbiAgICAgICAgdmFyIG5hbWVfMSA9IHN0YXRlLnN0cihNT0RFTF9TRVFVRU5DRV9OQU1FX0xFTkdUSCk7XG4gICAgICAgIHZhciBzZXF1ZW5jZSA9IHt9O1xuICAgICAgICBzZXF1ZW5jZS5OYW1lID0gbmFtZV8xO1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgVWludDMyQXJyYXkoMik7XG4gICAgICAgIGludGVydmFsWzBdID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgaW50ZXJ2YWxbMV0gPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBzZXF1ZW5jZS5JbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICBzZXF1ZW5jZS5Nb3ZlU3BlZWQgPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIHNlcXVlbmNlLk5vbkxvb3BpbmcgPSBzdGF0ZS5pbnQzMigpID4gMDtcbiAgICAgICAgc2VxdWVuY2UuUmFyaXR5ID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBzdGF0ZS5pbnQzMigpOyAvLyB1bmtub3duIDQtYnl0ZSBzZXF1ZW5jZSAoc3luY1BvaW50PylcbiAgICAgICAgcGFyc2VFeHRlbnQoc2VxdWVuY2UsIHN0YXRlKTtcbiAgICAgICAgbW9kZWwuU2VxdWVuY2VzLnB1c2goc2VxdWVuY2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlTWF0ZXJpYWxzKG1vZGVsLCBzdGF0ZSwgc2l6ZSkge1xuICAgIHZhciBzdGFydFBvcyA9IHN0YXRlLnBvcztcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHN0YXRlLmludDMyKCk7IC8vIG1hdGVyaWFsIHNpemUgaW5jbHVzaXZlXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IHtcbiAgICAgICAgICAgIExheWVyczogW11cbiAgICAgICAgfTtcbiAgICAgICAgbWF0ZXJpYWwuUHJpb3JpdHlQbGFuZSA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIG1hdGVyaWFsLlJlbmRlck1vZGUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBzdGF0ZS5leHBlY3RLZXl3b3JkKCdMQVlTJywgJ0luY29ycmVjdCBtYXRlcmlhbHMgZm9ybWF0Jyk7XG4gICAgICAgIHZhciBsYXllcnNDb3VudCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0UG9zMiA9IHN0YXRlLnBvcztcbiAgICAgICAgICAgIHZhciBzaXplMiA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB7fTtcbiAgICAgICAgICAgIGxheWVyLkZpbHRlck1vZGUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICAgICAgbGF5ZXIuU2hhZGluZyA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgICAgICBsYXllci5UZXh0dXJlSUQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICAgICAgbGF5ZXIuVFZlcnRleEFuaW1JZCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgICAgICBpZiAobGF5ZXIuVFZlcnRleEFuaW1JZCA9PT0gTk9ORSkge1xuICAgICAgICAgICAgICAgIGxheWVyLlRWZXJ0ZXhBbmltSWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIuQ29vcmRJZCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgICAgICBsYXllci5BbHBoYSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvczIgKyBzaXplMikge1xuICAgICAgICAgICAgICAgIHZhciBrZXl3b3JkID0gc3RhdGUua2V5d29yZCgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnS01UQScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuQWxwaGEgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLTVRGJykge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5UZXh0dXJlSUQgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLklOVDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxheWVyIGNodW5rIGRhdGEgJyArIGtleXdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGVyaWFsLkxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5NYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7XG4gICAgfVxufVxudmFyIE1PREVMX1RFWFRVUkVfUEFUSF9MRU5HVEggPSAweDEwMDtcbmZ1bmN0aW9uIHBhcnNlVGV4dHVyZXMobW9kZWwsIHN0YXRlLCBzaXplKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvcyArIHNpemUpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB7fTtcbiAgICAgICAgdGV4dHVyZS5SZXBsYWNlYWJsZUlkID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgdGV4dHVyZS5JbWFnZSA9IHN0YXRlLnN0cihNT0RFTF9URVhUVVJFX1BBVEhfTEVOR1RIKTtcbiAgICAgICAgc3RhdGUuaW50MzIoKTsgLy8gdW5rbm93biA0LWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgdGV4dHVyZS5GbGFncyA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIG1vZGVsLlRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VHZW9zZXRzKG1vZGVsLCBzdGF0ZSwgc2l6ZSkge1xuICAgIHZhciBzdGFydFBvcyA9IHN0YXRlLnBvcztcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHZhciBnZW9zZXQgPSB7fTtcbiAgICAgICAgc3RhdGUuaW50MzIoKTsgLy8gZ2Vvc2V0IHNpemUsIG5vdCB1c2VkXG4gICAgICAgIHN0YXRlLmV4cGVjdEtleXdvcmQoJ1ZSVFgnLCAnSW5jb3JyZWN0IGdlb3NldHMgZm9ybWF0Jyk7XG4gICAgICAgIHZhciB2ZXJ0aWNlc0NvdW50ID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZ2Vvc2V0LlZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0NvdW50ICogMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXNDb3VudCAqIDM7ICsraSkge1xuICAgICAgICAgICAgZ2Vvc2V0LlZlcnRpY2VzW2ldID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4cGVjdEtleXdvcmQoJ05STVMnLCAnSW5jb3JyZWN0IGdlb3NldHMgZm9ybWF0Jyk7XG4gICAgICAgIHZhciBub3JtYWxzQ291bnQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBnZW9zZXQuTm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsc0NvdW50ICogMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9ybWFsc0NvdW50ICogMzsgKytpKSB7XG4gICAgICAgICAgICBnZW9zZXQuTm9ybWFsc1tpXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHBlY3RLZXl3b3JkKCdQVFlQJywgJ0luY29ycmVjdCBnZW9zZXRzIGZvcm1hdCcpO1xuICAgICAgICB2YXIgcHJpbWl0aXZlQ291bnQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1pdGl2ZUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbnQzMigpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgZ2Vvc2V0cyBmb3JtYXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHBlY3RLZXl3b3JkKCdQQ05UJywgJ0luY29ycmVjdCBnZW9zZXRzIGZvcm1hdCcpO1xuICAgICAgICB2YXIgZmFjZUdyb3VwQ291bnQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhY2VHcm91cENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHN0YXRlLmludDMyKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXhwZWN0S2V5d29yZCgnUFZUWCcsICdJbmNvcnJlY3QgZ2Vvc2V0cyBmb3JtYXQnKTtcbiAgICAgICAgdmFyIGluZGljZXNDb3VudCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGdlb3NldC5GYWNlcyA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzQ291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXNDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBnZW9zZXQuRmFjZXNbaV0gPSBzdGF0ZS51aW50MTYoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHBlY3RLZXl3b3JkKCdHTkRYJywgJ0luY29ycmVjdCBnZW9zZXRzIGZvcm1hdCcpO1xuICAgICAgICB2YXIgdmVydGljZXNHcm91cENvdW50ID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZ2Vvc2V0LlZlcnRleEdyb3VwID0gbmV3IFVpbnQ4QXJyYXkodmVydGljZXNHcm91cENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlc0dyb3VwQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgZ2Vvc2V0LlZlcnRleEdyb3VwW2ldID0gc3RhdGUudWludDgoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHBlY3RLZXl3b3JkKCdNVEdDJywgJ0luY29ycmVjdCBnZW9zZXRzIGZvcm1hdCcpO1xuICAgICAgICB2YXIgZ3JvdXBzQ291bnQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBnZW9zZXQuR3JvdXBzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgLy8gbmV3IEFycmF5KGFycmF5IGxlbmd0aClcbiAgICAgICAgICAgIGdlb3NldC5Hcm91cHNbaV0gPSBuZXcgQXJyYXkoc3RhdGUuaW50MzIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXhwZWN0S2V5d29yZCgnTUFUUycsICdJbmNvcnJlY3QgZ2Vvc2V0cyBmb3JtYXQnKTtcbiAgICAgICAgZ2Vvc2V0LlRvdGFsR3JvdXBzQ291bnQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IDA7XG4gICAgICAgIHZhciBncm91cENvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb3NldC5Ub3RhbEdyb3Vwc0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGlmIChncm91cEluZGV4ID49IGdlb3NldC5Hcm91cHNbZ3JvdXBDb3VudGVyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBncm91cENvdW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlb3NldC5Hcm91cHNbZ3JvdXBDb3VudGVyXVtncm91cEluZGV4KytdID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgfVxuICAgICAgICBnZW9zZXQuTWF0ZXJpYWxJRCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGdlb3NldC5TZWxlY3Rpb25Hcm91cCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGdlb3NldC5VbnNlbGVjdGFibGUgPSBzdGF0ZS5pbnQzMigpID4gMDtcbiAgICAgICAgcGFyc2VFeHRlbnQoZ2Vvc2V0LCBzdGF0ZSk7XG4gICAgICAgIHZhciBnZW9zZXRBbmltQ291bnQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBnZW9zZXQuQW5pbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9zZXRBbmltQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGdlb3NldEFuaW0gPSB7fTtcbiAgICAgICAgICAgIHBhcnNlRXh0ZW50KGdlb3NldEFuaW0sIHN0YXRlKTtcbiAgICAgICAgICAgIGdlb3NldC5Bbmltcy5wdXNoKGdlb3NldEFuaW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4cGVjdEtleXdvcmQoJ1VWQVMnLCAnSW5jb3JyZWN0IGdlb3NldHMgZm9ybWF0Jyk7XG4gICAgICAgIHZhciB0ZXh0dXJlQ2h1bmtDb3VudCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGdlb3NldC5UVmVydGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlQ2h1bmtDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBzdGF0ZS5leHBlY3RLZXl3b3JkKCdVVkJTJywgJ0luY29ycmVjdCBnZW9zZXRzIGZvcm1hdCcpO1xuICAgICAgICAgICAgdmFyIHRleHR1cmVDb29yZHNDb3VudCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgICAgICB2YXIgdHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh0ZXh0dXJlQ29vcmRzQ291bnQgKiAyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZUNvb3Jkc0NvdW50ICogMjsgKytqKSB7XG4gICAgICAgICAgICAgICAgdHZlcnRpY2VzW2pdID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Vvc2V0LlRWZXJ0aWNlcy5wdXNoKHR2ZXJ0aWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuR2Vvc2V0cy5wdXNoKGdlb3NldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VHZW9zZXRBbmltcyhtb2RlbCwgc3RhdGUsIHNpemUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBzdGF0ZS5wb3M7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXJ0UG9zICsgc2l6ZSkge1xuICAgICAgICB2YXIgYW5pbVN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgICAgICB2YXIgYW5pbVNpemUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICB2YXIgZ2Vvc2V0QW5pbSA9IHt9O1xuICAgICAgICBnZW9zZXRBbmltLkFscGhhID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBnZW9zZXRBbmltLkZsYWdzID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZ2Vvc2V0QW5pbS5Db2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICBnZW9zZXRBbmltLkNvbG9yW2ldID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICB9XG4gICAgICAgIGdlb3NldEFuaW0uR2Vvc2V0SWQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBpZiAoZ2Vvc2V0QW5pbS5HZW9zZXRJZCA9PT0gTk9ORSkge1xuICAgICAgICAgICAgZ2Vvc2V0QW5pbS5HZW9zZXRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLnBvcyA8IGFuaW1TdGFydFBvcyArIGFuaW1TaXplKSB7XG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IHN0YXRlLmtleXdvcmQoKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnS0dBTycpIHtcbiAgICAgICAgICAgICAgICBnZW9zZXRBbmltLkFscGhhID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tHQUMnKSB7XG4gICAgICAgICAgICAgICAgZ2Vvc2V0QW5pbS5Db2xvciA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IEdlb3NldEFuaW0gY2h1bmsgZGF0YSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuR2Vvc2V0QW5pbXMucHVzaChnZW9zZXRBbmltKTtcbiAgICB9XG59XG52YXIgTU9ERUxfTk9ERV9OQU1FX0xFTkdUSCA9IDB4NTA7XG5mdW5jdGlvbiBwYXJzZU5vZGUobW9kZWwsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHZhciBzaXplID0gc3RhdGUuaW50MzIoKTtcbiAgICBub2RlLk5hbWUgPSBzdGF0ZS5zdHIoTU9ERUxfTk9ERV9OQU1FX0xFTkdUSCk7XG4gICAgbm9kZS5PYmplY3RJZCA9IHN0YXRlLmludDMyKCk7XG4gICAgaWYgKG5vZGUuT2JqZWN0SWQgPT09IE5PTkUpIHtcbiAgICAgICAgbm9kZS5PYmplY3RJZCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuUGFyZW50ID0gc3RhdGUuaW50MzIoKTtcbiAgICBpZiAobm9kZS5QYXJlbnQgPT09IE5PTkUpIHtcbiAgICAgICAgbm9kZS5QYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLkZsYWdzID0gc3RhdGUuaW50MzIoKTtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHZhciBrZXl3b3JkID0gc3RhdGUua2V5d29yZCgpO1xuICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ0tHVFInKSB7XG4gICAgICAgICAgICBub2RlLlRyYW5zbGF0aW9uID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLR1JUJykge1xuICAgICAgICAgICAgbm9kZS5Sb3RhdGlvbiA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS0dTQycpIHtcbiAgICAgICAgICAgIG5vZGUuU2NhbGluZyA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG5vZGUgY2h1bmsgZGF0YSAnICsga2V5d29yZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW9kZWwuTm9kZXNbbm9kZS5PYmplY3RJZF0gPSBub2RlO1xufVxuZnVuY3Rpb24gcGFyc2VCb25lcyhtb2RlbCwgc3RhdGUsIHNpemUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBzdGF0ZS5wb3M7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXJ0UG9zICsgc2l6ZSkge1xuICAgICAgICB2YXIgYm9uZSA9IHt9O1xuICAgICAgICBwYXJzZU5vZGUobW9kZWwsIGJvbmUsIHN0YXRlKTtcbiAgICAgICAgYm9uZS5HZW9zZXRJZCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGlmIChib25lLkdlb3NldElkID09PSBOT05FKSB7XG4gICAgICAgICAgICBib25lLkdlb3NldElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBib25lLkdlb3NldEFuaW1JZCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGlmIChib25lLkdlb3NldEFuaW1JZCA9PT0gTk9ORSkge1xuICAgICAgICAgICAgYm9uZS5HZW9zZXRBbmltSWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLkJvbmVzLnB1c2goYm9uZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VIZWxwZXJzKG1vZGVsLCBzdGF0ZSwgc2l6ZSkge1xuICAgIHZhciBzdGFydFBvcyA9IHN0YXRlLnBvcztcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHZhciBoZWxwZXIgPSB7fTtcbiAgICAgICAgcGFyc2VOb2RlKG1vZGVsLCBoZWxwZXIsIHN0YXRlKTtcbiAgICAgICAgbW9kZWwuSGVscGVycy5wdXNoKGhlbHBlcik7XG4gICAgfVxufVxudmFyIE1PREVMX0FUVEFDSE1FTlRfUEFUSF9MRU5HVEggPSAweDEwMDtcbmZ1bmN0aW9uIHBhcnNlQXR0YWNobWVudHMobW9kZWwsIHN0YXRlLCBzaXplKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvcyArIHNpemUpIHtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnRTdGFydCA9IHN0YXRlLnBvcztcbiAgICAgICAgdmFyIGF0dGFjaG1lbnRTaXplID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB7fTtcbiAgICAgICAgcGFyc2VOb2RlKG1vZGVsLCBhdHRhY2htZW50LCBzdGF0ZSk7XG4gICAgICAgIGF0dGFjaG1lbnQuUGF0aCA9IHN0YXRlLnN0cihNT0RFTF9BVFRBQ0hNRU5UX1BBVEhfTEVOR1RIKTtcbiAgICAgICAgc3RhdGUuaW50MzIoKTsgLy8gdW5rbm93biA0LWJ5dGVcbiAgICAgICAgYXR0YWNobWVudC5BdHRhY2htZW50SUQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBpZiAoc3RhdGUucG9zIDwgYXR0YWNobWVudFN0YXJ0ICsgYXR0YWNobWVudFNpemUpIHtcbiAgICAgICAgICAgIHN0YXRlLmV4cGVjdEtleXdvcmQoJ0tBVFYnLCAnSW5jb3JyZWN0IGF0dGFjaG1lbnQgY2h1bmsgZGF0YScpO1xuICAgICAgICAgICAgYXR0YWNobWVudC5WaXNpYmlsaXR5ID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLkF0dGFjaG1lbnRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQaXZvdFBvaW50cyhtb2RlbCwgc3RhdGUsIHNpemUpIHtcbiAgICB2YXIgcG9pbnRzQ291bnQgPSBzaXplIC8gKDQgKiAzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgICAgbW9kZWwuUGl2b3RQb2ludHNbaV0gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBtb2RlbC5QaXZvdFBvaW50c1tpXVswXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgbW9kZWwuUGl2b3RQb2ludHNbaV1bMV0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIG1vZGVsLlBpdm90UG9pbnRzW2ldWzJdID0gc3RhdGUuZmxvYXQzMigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnRPYmplY3RzKG1vZGVsLCBzdGF0ZSwgc2l6ZSkge1xuICAgIHZhciBzdGFydFBvcyA9IHN0YXRlLnBvcztcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHZhciBldmVudE9iamVjdCA9IHt9O1xuICAgICAgICBwYXJzZU5vZGUobW9kZWwsIGV2ZW50T2JqZWN0LCBzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmV4cGVjdEtleXdvcmQoJ0tFVlQnLCAnSW5jb3JyZWN0IEV2ZW50T2JqZWN0IGNodW5rIGRhdGEnKTtcbiAgICAgICAgdmFyIGV2ZW50VHJhY2tDb3VudCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGV2ZW50T2JqZWN0LkV2ZW50VHJhY2sgPSBuZXcgVWludDMyQXJyYXkoZXZlbnRUcmFja0NvdW50KTtcbiAgICAgICAgc3RhdGUuaW50MzIoKTsgLy8gdW51c2VkIDQtYnl0ZT9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudFRyYWNrQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgZXZlbnRPYmplY3QuRXZlbnRUcmFja1tpXSA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuRXZlbnRPYmplY3RzLnB1c2goZXZlbnRPYmplY3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQ29sbGlzaW9uU2hhcGVzKG1vZGVsLCBzdGF0ZSwgc2l6ZSkge1xuICAgIHZhciBzdGFydFBvcyA9IHN0YXRlLnBvcztcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHZhciBjb2xsaXNpb25TaGFwZSA9IHt9O1xuICAgICAgICBwYXJzZU5vZGUobW9kZWwsIGNvbGxpc2lvblNoYXBlLCBzdGF0ZSk7XG4gICAgICAgIGNvbGxpc2lvblNoYXBlLlNoYXBlID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgaWYgKGNvbGxpc2lvblNoYXBlLlNoYXBlID09PSBtb2RlbF8xLkNvbGxpc2lvblNoYXBlVHlwZS5Cb3gpIHtcbiAgICAgICAgICAgIGNvbGxpc2lvblNoYXBlLlZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxpc2lvblNoYXBlLlZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxpc2lvblNoYXBlLlZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb2xsaXNpb25TaGFwZS5WZXJ0aWNlc1tpXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sbGlzaW9uU2hhcGUuU2hhcGUgPT09IG1vZGVsXzEuQ29sbGlzaW9uU2hhcGVUeXBlLlNwaGVyZSkge1xuICAgICAgICAgICAgY29sbGlzaW9uU2hhcGUuQm91bmRzUmFkaXVzID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLkNvbGxpc2lvblNoYXBlcy5wdXNoKGNvbGxpc2lvblNoYXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUdsb2JhbFNlcXVlbmNlcyhtb2RlbCwgc3RhdGUsIHNpemUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBzdGF0ZS5wb3M7XG4gICAgbW9kZWwuR2xvYmFsU2VxdWVuY2VzID0gW107XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXJ0UG9zICsgc2l6ZSkge1xuICAgICAgICBtb2RlbC5HbG9iYWxTZXF1ZW5jZXMucHVzaChzdGF0ZS5pbnQzMigpKTtcbiAgICB9XG59XG52YXIgTU9ERUxfUEFSVElDTEVfRU1JVFRFUl9QQVRIX0xFTkdUSCA9IDB4MTAwO1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWNsZUVtaXR0ZXJzKG1vZGVsLCBzdGF0ZSwgc2l6ZSkge1xuICAgIHZhciBzdGFydFBvcyA9IHN0YXRlLnBvcztcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhcnRQb3MgKyBzaXplKSB7XG4gICAgICAgIHZhciBlbWl0dGVyU3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgICAgIHZhciBlbWl0dGVyU2l6ZSA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIHZhciBlbWl0dGVyID0ge307XG4gICAgICAgIHBhcnNlTm9kZShtb2RlbCwgZW1pdHRlciwgc3RhdGUpO1xuICAgICAgICBlbWl0dGVyLkVtaXNzaW9uUmF0ZSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5HcmF2aXR5ID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBlbWl0dGVyLkxvbmdpdHVkZSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5MYXRpdHVkZSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5QYXRoID0gc3RhdGUuc3RyKE1PREVMX1BBUlRJQ0xFX0VNSVRURVJfUEFUSF9MRU5HVEgpO1xuICAgICAgICBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBlbWl0dGVyLkxpZmVTcGFuID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBlbWl0dGVyLkluaXRWZWxvY2l0eSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnBvcyA8IGVtaXR0ZXJTdGFydCArIGVtaXR0ZXJTaXplKSB7XG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IHN0YXRlLmtleXdvcmQoKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnS1BFVicpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLlZpc2liaWxpdHkgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1BFRScpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLkVtaXNzaW9uUmF0ZSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUEVHJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuR3Jhdml0eSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUExOJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuTG9uZ2l0dWRlID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tQTFQnKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5MYXRpdHVkZSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUEVMJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuTGlmZVNwYW4gPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1BFUycpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLkluaXRWZWxvY2l0eSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhcnRpY2xlIGVtaXR0ZXIgY2h1bmsgZGF0YSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuUGFydGljbGVFbWl0dGVycy5wdXNoKGVtaXR0ZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUGFydGljbGVFbWl0dGVyczIobW9kZWwsIHN0YXRlLCBzaXplKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvcyArIHNpemUpIHtcbiAgICAgICAgdmFyIGVtaXR0ZXJTdGFydCA9IHN0YXRlLnBvcztcbiAgICAgICAgdmFyIGVtaXR0ZXJTaXplID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgdmFyIGVtaXR0ZXIgPSB7fTtcbiAgICAgICAgcGFyc2VOb2RlKG1vZGVsLCBlbWl0dGVyLCBzdGF0ZSk7XG4gICAgICAgIGVtaXR0ZXIuU3BlZWQgPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGVtaXR0ZXIuVmFyaWF0aW9uID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBlbWl0dGVyLkxhdGl0dWRlID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBlbWl0dGVyLkdyYXZpdHkgPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGVtaXR0ZXIuTGlmZVNwYW4gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGVtaXR0ZXIuRW1pc3Npb25SYXRlID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBlbWl0dGVyLldpZHRoID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBlbWl0dGVyLkxlbmd0aCA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5GaWx0ZXJNb2RlID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZW1pdHRlci5Sb3dzID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZW1pdHRlci5Db2x1bW5zID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgdmFyIGZyYW1lRmxhZ3MgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBlbWl0dGVyLkZyYW1lRmxhZ3MgPSAwO1xuICAgICAgICBpZiAoZnJhbWVGbGFncyA9PT0gMCB8fCBmcmFtZUZsYWdzID09PSAyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLkZyYW1lRmxhZ3MgfD0gbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3MuSGVhZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWVGbGFncyA9PT0gMSB8fCBmcmFtZUZsYWdzID09PSAyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLkZyYW1lRmxhZ3MgfD0gbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3MuVGFpbDtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLlRhaWxMZW5ndGggPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGVtaXR0ZXIuVGltZSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5TZWdtZW50Q29sb3IgPSBbXTtcbiAgICAgICAgLy8gYWx3YXlzIDMgc2VnbWVudHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuU2VnbWVudENvbG9yW2ldID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgICAgIC8vICByZ2Igb3JkZXIsIGludmVyc2UgZnJvbSBtZGxcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgKytqKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5TZWdtZW50Q29sb3JbaV1bal0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5BbHBoYSA9IG5ldyBVaW50OEFycmF5KDMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgZW1pdHRlci5BbHBoYVtpXSA9IHN0YXRlLnVpbnQ4KCk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5QYXJ0aWNsZVNjYWxpbmcgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgZW1pdHRlci5QYXJ0aWNsZVNjYWxpbmdbaV0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsnTGlmZVNwYW5VVkFuaW0nLCAnRGVjYXlVVkFuaW0nLCAnVGFpbFVWQW5pbScsICdUYWlsRGVjYXlVVkFuaW0nXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xuICAgICAgICAgICAgZW1pdHRlcltwYXJ0XSA9IG5ldyBVaW50MzJBcnJheSgzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlcltwYXJ0XVtpXSA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5UZXh0dXJlSUQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBpZiAoZW1pdHRlci5UZXh0dXJlSUQgPT09IE5PTkUpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuVGV4dHVyZUlEID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLlNxdWlydCA9IHN0YXRlLmludDMyKCkgPiAwO1xuICAgICAgICBlbWl0dGVyLlByaW9yaXR5UGxhbmUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBlbWl0dGVyLlJlcGxhY2VhYmxlSWQgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICB3aGlsZSAoc3RhdGUucG9zIDwgZW1pdHRlclN0YXJ0ICsgZW1pdHRlclNpemUpIHtcbiAgICAgICAgICAgIHZhciBrZXl3b3JkID0gc3RhdGUua2V5d29yZCgpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQgPT09ICdLUDJWJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuVmlzaWJpbGl0eSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUDJFJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuRW1pc3Npb25SYXRlID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tQMlcnKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5XaWR0aCA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUDJOJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuTGVuZ3RoID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tQMlMnKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5TcGVlZCA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUDJMJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuTGF0aXR1ZGUgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1AyRycpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLkdyYXZpdHkgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1AyUicpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLlZhcmlhdGlvbiA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhcnRpY2xlIGVtaXR0ZXIyIGNodW5rIGRhdGEgJyArIGtleXdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vZGVsLlBhcnRpY2xlRW1pdHRlcnMyLnB1c2goZW1pdHRlcik7XG4gICAgfVxufVxudmFyIE1PREVMX0NBTUVSQV9OQU1FX0xFTkdUSCA9IDB4NTA7XG5mdW5jdGlvbiBwYXJzZUNhbWVyYXMobW9kZWwsIHN0YXRlLCBzaXplKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvcyArIHNpemUpIHtcbiAgICAgICAgdmFyIGNhbWVyYVN0YXJ0ID0gc3RhdGUucG9zO1xuICAgICAgICB2YXIgY2FtZXJhU2l6ZSA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIHZhciBjYW1lcmEgPSB7fTtcbiAgICAgICAgY2FtZXJhLk5hbWUgPSBzdGF0ZS5zdHIoTU9ERUxfQ0FNRVJBX05BTUVfTEVOR1RIKTtcbiAgICAgICAgY2FtZXJhLlBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgY2FtZXJhLlBvc2l0aW9uWzBdID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBjYW1lcmEuUG9zaXRpb25bMV0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGNhbWVyYS5Qb3NpdGlvblsyXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgY2FtZXJhLkZpZWxkT2ZWaWV3ID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBjYW1lcmEuRmFyQ2xpcCA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgY2FtZXJhLk5lYXJDbGlwID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBjYW1lcmEuVGFyZ2V0UG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBjYW1lcmEuVGFyZ2V0UG9zaXRpb25bMF0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGNhbWVyYS5UYXJnZXRQb3NpdGlvblsxXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgY2FtZXJhLlRhcmdldFBvc2l0aW9uWzJdID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICB3aGlsZSAoc3RhdGUucG9zIDwgY2FtZXJhU3RhcnQgKyBjYW1lcmFTaXplKSB7XG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IHN0YXRlLmtleXdvcmQoKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkID09PSAnS0NUUicpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmEuVHJhbnNsYXRpb24gPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1RUUicpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmEuVGFyZ2V0VHJhbnNsYXRpb24gPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS0NSTCcpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmEuUm90YXRpb24gPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBjYW1lcmEgY2h1bmsgZGF0YSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuQ2FtZXJhcy5wdXNoKGNhbWVyYSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VMaWdodHMobW9kZWwsIHN0YXRlLCBzaXplKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGFydFBvcyArIHNpemUpIHtcbiAgICAgICAgdmFyIGxpZ2h0U3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgICAgIHZhciBsaWdodFNpemUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICB2YXIgbGlnaHQgPSB7fTtcbiAgICAgICAgcGFyc2VOb2RlKG1vZGVsLCBsaWdodCwgc3RhdGUpO1xuICAgICAgICBsaWdodC5MaWdodFR5cGUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICBsaWdodC5BdHRlbnVhdGlvblN0YXJ0ID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICBsaWdodC5BdHRlbnVhdGlvbkVuZCA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgbGlnaHQuQ29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAvLyAgcmdiIG9yZGVyLCBpbnZlcnNlIGZyb20gbWRsXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgKytqKSB7XG4gICAgICAgICAgICBsaWdodC5Db2xvcltqXSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgfVxuICAgICAgICBsaWdodC5JbnRlbnNpdHkgPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIGxpZ2h0LkFtYkNvbG9yID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgLy8gIHJnYiBvcmRlciwgaW52ZXJzZSBmcm9tIG1kbFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgbGlnaHQuQW1iQ29sb3Jbal0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGlnaHQuQW1iSW50ZW5zaXR5ID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICB3aGlsZSAoc3RhdGUucG9zIDwgbGlnaHRTdGFydCArIGxpZ2h0U2l6ZSkge1xuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBzdGF0ZS5rZXl3b3JkKCk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ0tMQVYnKSB7XG4gICAgICAgICAgICAgICAgbGlnaHQuVmlzaWJpbGl0eSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLTEFDJykge1xuICAgICAgICAgICAgICAgIGxpZ2h0LkNvbG9yID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tMQUknKSB7XG4gICAgICAgICAgICAgICAgbGlnaHQuSW50ZW5zaXR5ID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tMQkMnKSB7XG4gICAgICAgICAgICAgICAgbGlnaHQuQW1iQ29sb3IgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS0xCSScpIHtcbiAgICAgICAgICAgICAgICBsaWdodC5BbWJJbnRlbnNpdHkgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS0xBUycpIHtcbiAgICAgICAgICAgICAgICBsaWdodC5BdHRlbnVhdGlvblN0YXJ0ID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5JTlQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLTEFFJykge1xuICAgICAgICAgICAgICAgIGxpZ2h0LkF0dGVudWF0aW9uRW5kID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5JTlQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxpZ2h0IGNodW5rIGRhdGEgJyArIGtleXdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vZGVsLkxpZ2h0cy5wdXNoKGxpZ2h0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVRleHR1cmVBbmltcyhtb2RlbCwgc3RhdGUsIHNpemUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBzdGF0ZS5wb3M7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXJ0UG9zICsgc2l6ZSkge1xuICAgICAgICB2YXIgYW5pbVN0YXJ0ID0gc3RhdGUucG9zO1xuICAgICAgICB2YXIgYW5pbVNpemUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICB2YXIgYW5pbSA9IHt9O1xuICAgICAgICB3aGlsZSAoc3RhdGUucG9zIDwgYW5pbVN0YXJ0ICsgYW5pbVNpemUpIHtcbiAgICAgICAgICAgIHZhciBrZXl3b3JkID0gc3RhdGUua2V5d29yZCgpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQgPT09ICdLVEFUJykge1xuICAgICAgICAgICAgICAgIGFuaW0uVHJhbnNsYXRpb24gPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1RBUicpIHtcbiAgICAgICAgICAgICAgICBhbmltLlJvdGF0aW9uID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tUQVMnKSB7XG4gICAgICAgICAgICAgICAgYW5pbS5TY2FsaW5nID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGlnaHQgY2h1bmsgZGF0YSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuVGV4dHVyZUFuaW1zLnB1c2goYW5pbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSaWJib25FbWl0dGVycyhtb2RlbCwgc3RhdGUsIHNpemUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBzdGF0ZS5wb3M7XG4gICAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXJ0UG9zICsgc2l6ZSkge1xuICAgICAgICB2YXIgZW1pdHRlclN0YXJ0ID0gc3RhdGUucG9zO1xuICAgICAgICB2YXIgZW1pdHRlclNpemUgPSBzdGF0ZS5pbnQzMigpO1xuICAgICAgICB2YXIgZW1pdHRlciA9IHt9O1xuICAgICAgICBwYXJzZU5vZGUobW9kZWwsIGVtaXR0ZXIsIHN0YXRlKTtcbiAgICAgICAgZW1pdHRlci5IZWlnaHRBYm92ZSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5IZWlnaHRCZWxvdyA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5BbHBoYSA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5Db2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIC8vICByZ2Igb3JkZXIsIGludmVyc2UgZnJvbSBtZGxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyArK2opIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuQ29sb3Jbal0gPSBzdGF0ZS5mbG9hdDMyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5MaWZlU3BhbiA9IHN0YXRlLmZsb2F0MzIoKTtcbiAgICAgICAgZW1pdHRlci5UZXh0dXJlU2xvdCA9IHN0YXRlLmludDMyKCk7XG4gICAgICAgIGVtaXR0ZXIuRW1pc3Npb25SYXRlID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZW1pdHRlci5Sb3dzID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZW1pdHRlci5Db2x1bW5zID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZW1pdHRlci5NYXRlcmlhbElEID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgZW1pdHRlci5HcmF2aXR5ID0gc3RhdGUuZmxvYXQzMigpO1xuICAgICAgICB3aGlsZSAoc3RhdGUucG9zIDwgZW1pdHRlclN0YXJ0ICsgZW1pdHRlclNpemUpIHtcbiAgICAgICAgICAgIHZhciBrZXl3b3JkID0gc3RhdGUua2V5d29yZCgpO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQgPT09ICdLUlZTJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuVmlzaWJpbGl0eSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUkhBJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuSGVpZ2h0QWJvdmUgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLkZMT0FUMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXl3b3JkID09PSAnS1JIQicpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLkhlaWdodEJlbG93ID0gc3RhdGUuYW5pbVZlY3RvcihBbmltVmVjdG9yVHlwZS5GTE9BVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5d29yZCA9PT0gJ0tSQUwnKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5BbHBoYSA9IHN0YXRlLmFuaW1WZWN0b3IoQW5pbVZlY3RvclR5cGUuRkxPQVQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleXdvcmQgPT09ICdLUlRYJykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuVGV4dHVyZVNsb3QgPSBzdGF0ZS5hbmltVmVjdG9yKEFuaW1WZWN0b3JUeXBlLklOVDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcmliYm9uIGVtaXR0ZXIgY2h1bmsgZGF0YSAnICsga2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuUmliYm9uRW1pdHRlcnMucHVzaChlbWl0dGVyKTtcbiAgICB9XG59XG52YXIgcGFyc2VycyA9IHtcbiAgICBWRVJTOiBwYXJzZVZlcnNpb24sXG4gICAgTU9ETDogcGFyc2VNb2RlbEluZm8sXG4gICAgU0VRUzogcGFyc2VTZXF1ZW5jZXMsXG4gICAgTVRMUzogcGFyc2VNYXRlcmlhbHMsXG4gICAgVEVYUzogcGFyc2VUZXh0dXJlcyxcbiAgICBHRU9TOiBwYXJzZUdlb3NldHMsXG4gICAgR0VPQTogcGFyc2VHZW9zZXRBbmltcyxcbiAgICBCT05FOiBwYXJzZUJvbmVzLFxuICAgIEhFTFA6IHBhcnNlSGVscGVycyxcbiAgICBBVENIOiBwYXJzZUF0dGFjaG1lbnRzLFxuICAgIFBJVlQ6IHBhcnNlUGl2b3RQb2ludHMsXG4gICAgRVZUUzogcGFyc2VFdmVudE9iamVjdHMsXG4gICAgQ0xJRDogcGFyc2VDb2xsaXNpb25TaGFwZXMsXG4gICAgR0xCUzogcGFyc2VHbG9iYWxTZXF1ZW5jZXMsXG4gICAgUFJFTTogcGFyc2VQYXJ0aWNsZUVtaXR0ZXJzLFxuICAgIFBSRTI6IHBhcnNlUGFydGljbGVFbWl0dGVyczIsXG4gICAgQ0FNUzogcGFyc2VDYW1lcmFzLFxuICAgIExJVEU6IHBhcnNlTGlnaHRzLFxuICAgIFRYQU46IHBhcnNlVGV4dHVyZUFuaW1zLFxuICAgIFJJQkI6IHBhcnNlUmliYm9uRW1pdHRlcnNcbn07XG5mdW5jdGlvbiBwYXJzZShhcnJheUJ1ZmZlcikge1xuICAgIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShhcnJheUJ1ZmZlcik7XG4gICAgaWYgKHN0YXRlLmtleXdvcmQoKSAhPT0gJ01ETFgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgbWR4IG1vZGVsJyk7XG4gICAgfVxuICAgIHZhciBtb2RlbCA9IHtcbiAgICAgICAgLy8gZGVmYXVsdFxuICAgICAgICBWZXJzaW9uOiA4MDAsXG4gICAgICAgIEluZm86IHtcbiAgICAgICAgICAgIE5hbWU6ICcnLFxuICAgICAgICAgICAgTWluaW11bUV4dGVudDogbnVsbCxcbiAgICAgICAgICAgIE1heGltdW1FeHRlbnQ6IG51bGwsXG4gICAgICAgICAgICBCb3VuZHNSYWRpdXM6IDAsXG4gICAgICAgICAgICBCbGVuZFRpbWU6IDE1MFxuICAgICAgICB9LFxuICAgICAgICBTZXF1ZW5jZXM6IFtdLFxuICAgICAgICBHbG9iYWxTZXF1ZW5jZXM6IFtdLFxuICAgICAgICBUZXh0dXJlczogW10sXG4gICAgICAgIE1hdGVyaWFsczogW10sXG4gICAgICAgIFRleHR1cmVBbmltczogW10sXG4gICAgICAgIEdlb3NldHM6IFtdLFxuICAgICAgICBHZW9zZXRBbmltczogW10sXG4gICAgICAgIEJvbmVzOiBbXSxcbiAgICAgICAgSGVscGVyczogW10sXG4gICAgICAgIEF0dGFjaG1lbnRzOiBbXSxcbiAgICAgICAgRXZlbnRPYmplY3RzOiBbXSxcbiAgICAgICAgUGFydGljbGVFbWl0dGVyczogW10sXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlcnMyOiBbXSxcbiAgICAgICAgQ2FtZXJhczogW10sXG4gICAgICAgIExpZ2h0czogW10sXG4gICAgICAgIFJpYmJvbkVtaXR0ZXJzOiBbXSxcbiAgICAgICAgQ29sbGlzaW9uU2hhcGVzOiBbXSxcbiAgICAgICAgUGl2b3RQb2ludHM6IFtdLFxuICAgICAgICBOb2RlczogW11cbiAgICB9O1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleXdvcmQgPSBzdGF0ZS5rZXl3b3JkKCk7XG4gICAgICAgIHZhciBzaXplID0gc3RhdGUuaW50MzIoKTtcbiAgICAgICAgaWYgKGtleXdvcmQgaW4gcGFyc2Vycykge1xuICAgICAgICAgICAgcGFyc2Vyc1trZXl3b3JkXShtb2RlbCwgc3RhdGUsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdyb3VwICcgKyBrZXl3b3JkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVsLk5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtb2RlbC5Ob2Rlc1tpXSAmJiBtb2RlbC5QaXZvdFBvaW50c1tpXSkge1xuICAgICAgICAgICAgbW9kZWwuTm9kZXNbaV0uUGl2b3RQb2ludCA9IG1vZGVsLlBpdm90UG9pbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbnZhciBfYTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleHR1cmVGbGFncztcbihmdW5jdGlvbiAoVGV4dHVyZUZsYWdzKSB7XG4gICAgVGV4dHVyZUZsYWdzW1RleHR1cmVGbGFnc1tcIldyYXBXaWR0aFwiXSA9IDFdID0gXCJXcmFwV2lkdGhcIjtcbiAgICBUZXh0dXJlRmxhZ3NbVGV4dHVyZUZsYWdzW1wiV3JhcEhlaWdodFwiXSA9IDJdID0gXCJXcmFwSGVpZ2h0XCI7XG59KShUZXh0dXJlRmxhZ3MgPSBleHBvcnRzLlRleHR1cmVGbGFncyB8fCAoZXhwb3J0cy5UZXh0dXJlRmxhZ3MgPSB7fSkpO1xudmFyIEZpbHRlck1vZGU7XG4oZnVuY3Rpb24gKEZpbHRlck1vZGUpIHtcbiAgICBGaWx0ZXJNb2RlW0ZpbHRlck1vZGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBGaWx0ZXJNb2RlW0ZpbHRlck1vZGVbXCJUcmFuc3BhcmVudFwiXSA9IDFdID0gXCJUcmFuc3BhcmVudFwiO1xuICAgIEZpbHRlck1vZGVbRmlsdGVyTW9kZVtcIkJsZW5kXCJdID0gMl0gPSBcIkJsZW5kXCI7XG4gICAgRmlsdGVyTW9kZVtGaWx0ZXJNb2RlW1wiQWRkaXRpdmVcIl0gPSAzXSA9IFwiQWRkaXRpdmVcIjtcbiAgICBGaWx0ZXJNb2RlW0ZpbHRlck1vZGVbXCJBZGRBbHBoYVwiXSA9IDRdID0gXCJBZGRBbHBoYVwiO1xuICAgIEZpbHRlck1vZGVbRmlsdGVyTW9kZVtcIk1vZHVsYXRlXCJdID0gNV0gPSBcIk1vZHVsYXRlXCI7XG4gICAgRmlsdGVyTW9kZVtGaWx0ZXJNb2RlW1wiTW9kdWxhdGUyeFwiXSA9IDZdID0gXCJNb2R1bGF0ZTJ4XCI7XG59KShGaWx0ZXJNb2RlID0gZXhwb3J0cy5GaWx0ZXJNb2RlIHx8IChleHBvcnRzLkZpbHRlck1vZGUgPSB7fSkpO1xudmFyIExpbmVUeXBlO1xuKGZ1bmN0aW9uIChMaW5lVHlwZSkge1xuICAgIExpbmVUeXBlW0xpbmVUeXBlW1wiRG9udEludGVycFwiXSA9IDBdID0gXCJEb250SW50ZXJwXCI7XG4gICAgTGluZVR5cGVbTGluZVR5cGVbXCJMaW5lYXJcIl0gPSAxXSA9IFwiTGluZWFyXCI7XG4gICAgTGluZVR5cGVbTGluZVR5cGVbXCJIZXJtaXRlXCJdID0gMl0gPSBcIkhlcm1pdGVcIjtcbiAgICBMaW5lVHlwZVtMaW5lVHlwZVtcIkJlemllclwiXSA9IDNdID0gXCJCZXppZXJcIjtcbn0pKExpbmVUeXBlID0gZXhwb3J0cy5MaW5lVHlwZSB8fCAoZXhwb3J0cy5MaW5lVHlwZSA9IHt9KSk7XG52YXIgTGF5ZXJTaGFkaW5nO1xuKGZ1bmN0aW9uIChMYXllclNoYWRpbmcpIHtcbiAgICBMYXllclNoYWRpbmdbTGF5ZXJTaGFkaW5nW1wiVW5zaGFkZWRcIl0gPSAxXSA9IFwiVW5zaGFkZWRcIjtcbiAgICBMYXllclNoYWRpbmdbTGF5ZXJTaGFkaW5nW1wiU3BoZXJlRW52TWFwXCJdID0gMl0gPSBcIlNwaGVyZUVudk1hcFwiO1xuICAgIExheWVyU2hhZGluZ1tMYXllclNoYWRpbmdbXCJUd29TaWRlZFwiXSA9IDE2XSA9IFwiVHdvU2lkZWRcIjtcbiAgICBMYXllclNoYWRpbmdbTGF5ZXJTaGFkaW5nW1wiVW5mb2dnZWRcIl0gPSAzMl0gPSBcIlVuZm9nZ2VkXCI7XG4gICAgTGF5ZXJTaGFkaW5nW0xheWVyU2hhZGluZ1tcIk5vRGVwdGhUZXN0XCJdID0gNjRdID0gXCJOb0RlcHRoVGVzdFwiO1xuICAgIExheWVyU2hhZGluZ1tMYXllclNoYWRpbmdbXCJOb0RlcHRoU2V0XCJdID0gMTI4XSA9IFwiTm9EZXB0aFNldFwiO1xufSkoTGF5ZXJTaGFkaW5nID0gZXhwb3J0cy5MYXllclNoYWRpbmcgfHwgKGV4cG9ydHMuTGF5ZXJTaGFkaW5nID0ge30pKTtcbnZhciBNYXRlcmlhbFJlbmRlck1vZGU7XG4oZnVuY3Rpb24gKE1hdGVyaWFsUmVuZGVyTW9kZSkge1xuICAgIE1hdGVyaWFsUmVuZGVyTW9kZVtNYXRlcmlhbFJlbmRlck1vZGVbXCJDb25zdGFudENvbG9yXCJdID0gMV0gPSBcIkNvbnN0YW50Q29sb3JcIjtcbiAgICBNYXRlcmlhbFJlbmRlck1vZGVbTWF0ZXJpYWxSZW5kZXJNb2RlW1wiU29ydFByaW1zRmFyWlwiXSA9IDE2XSA9IFwiU29ydFByaW1zRmFyWlwiO1xuICAgIE1hdGVyaWFsUmVuZGVyTW9kZVtNYXRlcmlhbFJlbmRlck1vZGVbXCJGdWxsUmVzb2x1dGlvblwiXSA9IDMyXSA9IFwiRnVsbFJlc29sdXRpb25cIjtcbn0pKE1hdGVyaWFsUmVuZGVyTW9kZSA9IGV4cG9ydHMuTWF0ZXJpYWxSZW5kZXJNb2RlIHx8IChleHBvcnRzLk1hdGVyaWFsUmVuZGVyTW9kZSA9IHt9KSk7XG52YXIgR2Vvc2V0QW5pbUZsYWdzO1xuKGZ1bmN0aW9uIChHZW9zZXRBbmltRmxhZ3MpIHtcbiAgICBHZW9zZXRBbmltRmxhZ3NbR2Vvc2V0QW5pbUZsYWdzW1wiRHJvcFNoYWRvd1wiXSA9IDFdID0gXCJEcm9wU2hhZG93XCI7XG4gICAgR2Vvc2V0QW5pbUZsYWdzW0dlb3NldEFuaW1GbGFnc1tcIkNvbG9yXCJdID0gMl0gPSBcIkNvbG9yXCI7XG59KShHZW9zZXRBbmltRmxhZ3MgPSBleHBvcnRzLkdlb3NldEFuaW1GbGFncyB8fCAoZXhwb3J0cy5HZW9zZXRBbmltRmxhZ3MgPSB7fSkpO1xudmFyIE5vZGVGbGFncztcbihmdW5jdGlvbiAoTm9kZUZsYWdzKSB7XG4gICAgTm9kZUZsYWdzW05vZGVGbGFnc1tcIkRvbnRJbmhlcml0VHJhbnNsYXRpb25cIl0gPSAxXSA9IFwiRG9udEluaGVyaXRUcmFuc2xhdGlvblwiO1xuICAgIE5vZGVGbGFnc1tOb2RlRmxhZ3NbXCJEb250SW5oZXJpdFJvdGF0aW9uXCJdID0gMl0gPSBcIkRvbnRJbmhlcml0Um90YXRpb25cIjtcbiAgICBOb2RlRmxhZ3NbTm9kZUZsYWdzW1wiRG9udEluaGVyaXRTY2FsaW5nXCJdID0gNF0gPSBcIkRvbnRJbmhlcml0U2NhbGluZ1wiO1xuICAgIE5vZGVGbGFnc1tOb2RlRmxhZ3NbXCJCaWxsYm9hcmRlZFwiXSA9IDhdID0gXCJCaWxsYm9hcmRlZFwiO1xuICAgIE5vZGVGbGFnc1tOb2RlRmxhZ3NbXCJCaWxsYm9hcmRlZExvY2tYXCJdID0gMTZdID0gXCJCaWxsYm9hcmRlZExvY2tYXCI7XG4gICAgTm9kZUZsYWdzW05vZGVGbGFnc1tcIkJpbGxib2FyZGVkTG9ja1lcIl0gPSAzMl0gPSBcIkJpbGxib2FyZGVkTG9ja1lcIjtcbiAgICBOb2RlRmxhZ3NbTm9kZUZsYWdzW1wiQmlsbGJvYXJkZWRMb2NrWlwiXSA9IDY0XSA9IFwiQmlsbGJvYXJkZWRMb2NrWlwiO1xuICAgIE5vZGVGbGFnc1tOb2RlRmxhZ3NbXCJDYW1lcmFBbmNob3JlZFwiXSA9IDEyOF0gPSBcIkNhbWVyYUFuY2hvcmVkXCI7XG59KShOb2RlRmxhZ3MgPSBleHBvcnRzLk5vZGVGbGFncyB8fCAoZXhwb3J0cy5Ob2RlRmxhZ3MgPSB7fSkpO1xudmFyIE5vZGVUeXBlO1xuKGZ1bmN0aW9uIChOb2RlVHlwZSkge1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiSGVscGVyXCJdID0gMF0gPSBcIkhlbHBlclwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiQm9uZVwiXSA9IDI1Nl0gPSBcIkJvbmVcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkxpZ2h0XCJdID0gNTEyXSA9IFwiTGlnaHRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkV2ZW50T2JqZWN0XCJdID0gMTAyNF0gPSBcIkV2ZW50T2JqZWN0XCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJBdHRhY2htZW50XCJdID0gMjA0OF0gPSBcIkF0dGFjaG1lbnRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIlBhcnRpY2xlRW1pdHRlclwiXSA9IDQwOTZdID0gXCJQYXJ0aWNsZUVtaXR0ZXJcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNvbGxpc2lvblNoYXBlXCJdID0gODE5Ml0gPSBcIkNvbGxpc2lvblNoYXBlXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJSaWJib25FbWl0dGVyXCJdID0gMTYzODRdID0gXCJSaWJib25FbWl0dGVyXCI7XG59KShOb2RlVHlwZSA9IGV4cG9ydHMuTm9kZVR5cGUgfHwgKGV4cG9ydHMuTm9kZVR5cGUgPSB7fSkpO1xudmFyIENvbGxpc2lvblNoYXBlVHlwZTtcbihmdW5jdGlvbiAoQ29sbGlzaW9uU2hhcGVUeXBlKSB7XG4gICAgQ29sbGlzaW9uU2hhcGVUeXBlW0NvbGxpc2lvblNoYXBlVHlwZVtcIkJveFwiXSA9IDBdID0gXCJCb3hcIjtcbiAgICBDb2xsaXNpb25TaGFwZVR5cGVbQ29sbGlzaW9uU2hhcGVUeXBlW1wiU3BoZXJlXCJdID0gMl0gPSBcIlNwaGVyZVwiO1xufSkoQ29sbGlzaW9uU2hhcGVUeXBlID0gZXhwb3J0cy5Db2xsaXNpb25TaGFwZVR5cGUgfHwgKGV4cG9ydHMuQ29sbGlzaW9uU2hhcGVUeXBlID0ge30pKTtcbnZhciBQYXJ0aWNsZUVtaXR0ZXJGbGFncztcbihmdW5jdGlvbiAoUGFydGljbGVFbWl0dGVyRmxhZ3MpIHtcbiAgICBQYXJ0aWNsZUVtaXR0ZXJGbGFnc1tQYXJ0aWNsZUVtaXR0ZXJGbGFnc1tcIkVtaXR0ZXJVc2VzTURMXCJdID0gMzI3NjhdID0gXCJFbWl0dGVyVXNlc01ETFwiO1xuICAgIFBhcnRpY2xlRW1pdHRlckZsYWdzW1BhcnRpY2xlRW1pdHRlckZsYWdzW1wiRW1pdHRlclVzZXNUR0FcIl0gPSA2NTUzNl0gPSBcIkVtaXR0ZXJVc2VzVEdBXCI7XG59KShQYXJ0aWNsZUVtaXR0ZXJGbGFncyA9IGV4cG9ydHMuUGFydGljbGVFbWl0dGVyRmxhZ3MgfHwgKGV4cG9ydHMuUGFydGljbGVFbWl0dGVyRmxhZ3MgPSB7fSkpO1xudmFyIFBhcnRpY2xlRW1pdHRlcjJGbGFncztcbihmdW5jdGlvbiAoUGFydGljbGVFbWl0dGVyMkZsYWdzKSB7XG4gICAgUGFydGljbGVFbWl0dGVyMkZsYWdzW1BhcnRpY2xlRW1pdHRlcjJGbGFnc1tcIlVuc2hhZGVkXCJdID0gMzI3NjhdID0gXCJVbnNoYWRlZFwiO1xuICAgIFBhcnRpY2xlRW1pdHRlcjJGbGFnc1tQYXJ0aWNsZUVtaXR0ZXIyRmxhZ3NbXCJTb3J0UHJpbXNGYXJaXCJdID0gNjU1MzZdID0gXCJTb3J0UHJpbXNGYXJaXCI7XG4gICAgUGFydGljbGVFbWl0dGVyMkZsYWdzW1BhcnRpY2xlRW1pdHRlcjJGbGFnc1tcIkxpbmVFbWl0dGVyXCJdID0gMTMxMDcyXSA9IFwiTGluZUVtaXR0ZXJcIjtcbiAgICBQYXJ0aWNsZUVtaXR0ZXIyRmxhZ3NbUGFydGljbGVFbWl0dGVyMkZsYWdzW1wiVW5mb2dnZWRcIl0gPSAyNjIxNDRdID0gXCJVbmZvZ2dlZFwiO1xuICAgIFBhcnRpY2xlRW1pdHRlcjJGbGFnc1tQYXJ0aWNsZUVtaXR0ZXIyRmxhZ3NbXCJNb2RlbFNwYWNlXCJdID0gNTI0Mjg4XSA9IFwiTW9kZWxTcGFjZVwiO1xuICAgIFBhcnRpY2xlRW1pdHRlcjJGbGFnc1tQYXJ0aWNsZUVtaXR0ZXIyRmxhZ3NbXCJYWVF1YWRcIl0gPSAxMDQ4NTc2XSA9IFwiWFlRdWFkXCI7XG59KShQYXJ0aWNsZUVtaXR0ZXIyRmxhZ3MgPSBleHBvcnRzLlBhcnRpY2xlRW1pdHRlcjJGbGFncyB8fCAoZXhwb3J0cy5QYXJ0aWNsZUVtaXR0ZXIyRmxhZ3MgPSB7fSkpO1xudmFyIFBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlO1xuKGZ1bmN0aW9uIChQYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZSkge1xuICAgIFBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlW1BhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlW1wiQmxlbmRcIl0gPSAwXSA9IFwiQmxlbmRcIjtcbiAgICBQYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZVtQYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZVtcIkFkZGl0aXZlXCJdID0gMV0gPSBcIkFkZGl0aXZlXCI7XG4gICAgUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGVbUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGVbXCJNb2R1bGF0ZVwiXSA9IDJdID0gXCJNb2R1bGF0ZVwiO1xuICAgIFBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlW1BhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlW1wiTW9kdWxhdGUyeFwiXSA9IDNdID0gXCJNb2R1bGF0ZTJ4XCI7XG4gICAgUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGVbUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGVbXCJBbHBoYUtleVwiXSA9IDRdID0gXCJBbHBoYUtleVwiO1xufSkoUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGUgPSBleHBvcnRzLlBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlIHx8IChleHBvcnRzLlBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlID0ge30pKTtcbi8vIE5vdCBhY3R1YWxseSBtYXBwZWQgdG8gbWR4IGZsYWdzICgwOiBIZWFkLCAxOiBUYWlsLCAyOiBCb3RoKVxudmFyIFBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncztcbihmdW5jdGlvbiAoUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzKSB7XG4gICAgUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzW1BhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFnc1tcIkhlYWRcIl0gPSAxXSA9IFwiSGVhZFwiO1xuICAgIFBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFnc1tQYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3NbXCJUYWlsXCJdID0gMl0gPSBcIlRhaWxcIjtcbn0pKFBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncyA9IGV4cG9ydHMuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzIHx8IChleHBvcnRzLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncyA9IHt9KSk7XG52YXIgTGlnaHRUeXBlO1xuKGZ1bmN0aW9uIChMaWdodFR5cGUpIHtcbiAgICBMaWdodFR5cGVbTGlnaHRUeXBlW1wiT21uaWRpcmVjdGlvbmFsXCJdID0gMF0gPSBcIk9tbmlkaXJlY3Rpb25hbFwiO1xuICAgIExpZ2h0VHlwZVtMaWdodFR5cGVbXCJEaXJlY3Rpb25hbFwiXSA9IDFdID0gXCJEaXJlY3Rpb25hbFwiO1xuICAgIExpZ2h0VHlwZVtMaWdodFR5cGVbXCJBbWJpZW50XCJdID0gMl0gPSBcIkFtYmllbnRcIjtcbn0pKExpZ2h0VHlwZSA9IGV4cG9ydHMuTGlnaHRUeXBlIHx8IChleHBvcnRzLkxpZ2h0VHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjMuMlxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG4vLyBFTkQgSEVBREVSXG5cbmV4cG9ydHMuZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvY29tbW9uLmpzXCIpO1xuZXhwb3J0cy5tYXQyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDIuanNcIik7XG5leHBvcnRzLm1hdDJkID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDJkLmpzXCIpO1xuZXhwb3J0cy5tYXQzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDMuanNcIik7XG5leHBvcnRzLm1hdDQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0NC5qc1wiKTtcbmV4cG9ydHMucXVhdCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9xdWF0LmpzXCIpO1xuZXhwb3J0cy52ZWMyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzIuanNcIik7XG5leHBvcnRzLnZlYzMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMy5qc1wiKTtcbmV4cG9ydHMudmVjNCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWM0LmpzXCIpOyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbi8qKlxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBuYW1lIGdsTWF0cml4XG4gKi9cbnZhciBnbE1hdHJpeCA9IHt9O1xuXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZ2xNYXRyaXguRVBTSUxPTiA9IDAuMDAwMDAxO1xuZ2xNYXRyaXguQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmdsTWF0cml4LlJBTkRPTSA9IE1hdGgucmFuZG9tO1xuZ2xNYXRyaXguRU5BQkxFX1NJTUQgPSBmYWxzZTtcblxuLy8gQ2FwYWJpbGl0eSBkZXRlY3Rpb25cbmdsTWF0cml4LlNJTURfQVZBSUxBQkxFID0gKGdsTWF0cml4LkFSUkFZX1RZUEUgPT09IEZsb2F0MzJBcnJheSkgJiYgKCdTSU1EJyBpbiB0aGlzKTtcbmdsTWF0cml4LlVTRV9TSU1EID0gZ2xNYXRyaXguRU5BQkxFX1NJTUQgJiYgZ2xNYXRyaXguU0lNRF9BVkFJTEFCTEU7XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBnbE1hdHJpeC5BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzIFxuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICogXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZ2xNYXRyaXguZXF1YWxzID0gZnVuY3Rpb24oYSwgYikge1xuXHRyZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsTWF0cml4O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cbnZhciBtYXQyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0xMDtcbiAgICBvdXRbM10gPSBtMTE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5zZXQgPSBmdW5jdGlvbihvdXQsIG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTEwO1xuICAgIG91dFszXSA9IG0xMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTEgPSBhWzFdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhWzFdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgIG91dFswXSA9ICBhMyAqIGRldDtcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWEyICogZGV0O1xuICAgIG91dFszXSA9ICBhMCAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICAgIHZhciBhMCA9IGFbMF07XG4gICAgb3V0WzBdID0gIGFbM107XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gIGEwO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDIuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IC1zO1xuICAgIG91dFszXSA9IGM7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0Mi5zdWIgPSBtYXQyLnN1YnRyYWN0O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0Mi5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0Mi5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseVNjYWxhciA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDJkXG4gKiBcbiAqIEBkZXNjcmlwdGlvbiBcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDJkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IEEgbmV3IG1hdDJkXG4gKi9cbm1hdDJkLmZyb21WYWx1ZXMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gYTtcbiAgICBvdXRbMV0gPSBiO1xuICAgIG91dFsyXSA9IGM7XG4gICAgb3V0WzNdID0gZDtcbiAgICBvdXRbNF0gPSB0eDtcbiAgICBvdXRbNV0gPSB0eTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IGMgQ29tcG9uZW50IEMgKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gdHkgQ29tcG9uZW50IFRZIChpbmRleCA1KVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuc2V0ID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICBvdXRbMF0gPSBhO1xuICAgIG91dFsxXSA9IGI7XG4gICAgb3V0WzJdID0gYztcbiAgICBvdXRbM10gPSBkO1xuICAgIG91dFs0XSA9IHR4O1xuICAgIG91dFs1XSA9IHR5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXSxcbiAgICAgICAgYXR4ID0gYVs0XSwgYXR5ID0gYVs1XTtcblxuICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICBpZighZGV0KXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyZC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICAgIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5tdWwgPSBtYXQyZC5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gdlswXTtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyZC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59OyBcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0MmQuc3ViID0gbWF0MmQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MmQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0MmQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDJkLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MmQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xubWF0My5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMTA7XG4gICAgb3V0WzRdID0gbTExO1xuICAgIG91dFs1XSA9IG0xMjtcbiAgICBvdXRbNl0gPSBtMjA7XG4gICAgb3V0WzddID0gbTIxO1xuICAgIG91dFs4XSA9IG0yMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0xMDtcbiAgICBvdXRbNF0gPSBtMTE7XG4gICAgb3V0WzVdID0gbTEyO1xuICAgIG91dFs2XSA9IG0yMDtcbiAgICBvdXRbN10gPSBtMjE7XG4gICAgb3V0WzhdID0gbTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IHZbMF07XG4gICAgb3V0WzddID0gdlsxXTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IC1zO1xuICAgIG91dFs0XSA9IGM7XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB2WzFdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5zdWIgPSBtYXQzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgb3V0WzZdID0gYVs2XSAqIGI7XG4gICAgb3V0WzddID0gYVs3XSAqIGI7XG4gICAgb3V0WzhdID0gYVs4XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gICAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICAgIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLypcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0My5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIFxuICAgICAgICAgICBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgICBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sIGE2ID0gYVs2XSwgYTcgPSBhWzddLCBhOCA9IGFbOF07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV0sIGI2ID0gYVs2XSwgYjcgPSBiWzddLCBiOCA9IGJbOF07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQzO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0eDQgTWF0cml4XG4gKiBAbmFtZSBtYXQ0XG4gKi9cbnZhciBtYXQ0ID0ge1xuICBzY2FsYXI6IHt9LFxuICBTSU1EOiB7fSxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxuICovXG5tYXQ0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbihtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0wMztcbiAgICBvdXRbNF0gPSBtMTA7XG4gICAgb3V0WzVdID0gbTExO1xuICAgIG91dFs2XSA9IG0xMjtcbiAgICBvdXRbN10gPSBtMTM7XG4gICAgb3V0WzhdID0gbTIwO1xuICAgIG91dFs5XSA9IG0yMTtcbiAgICBvdXRbMTBdID0gbTIyO1xuICAgIG91dFsxMV0gPSBtMjM7XG4gICAgb3V0WzEyXSA9IG0zMDtcbiAgICBvdXRbMTNdID0gbTMxO1xuICAgIG91dFsxNF0gPSBtMzI7XG4gICAgb3V0WzE1XSA9IG0zMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTAzO1xuICAgIG91dFs0XSA9IG0xMDtcbiAgICBvdXRbNV0gPSBtMTE7XG4gICAgb3V0WzZdID0gbTEyO1xuICAgIG91dFs3XSA9IG0xMztcbiAgICBvdXRbOF0gPSBtMjA7XG4gICAgb3V0WzldID0gbTIxO1xuICAgIG91dFsxMF0gPSBtMjI7XG4gICAgb3V0WzExXSA9IG0yMztcbiAgICBvdXRbMTJdID0gbTMwO1xuICAgIG91dFsxM10gPSBtMzE7XG4gICAgb3V0WzE0XSA9IG0zMjtcbiAgICBvdXRbMTVdID0gbTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwLCBhMSwgYTIsIGEzLFxuICAgICAgICB0bXAwMSwgdG1wMjMsXG4gICAgICAgIG91dDAsIG91dDEsIG91dDIsIG91dDM7XG5cbiAgICBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gICAgdG1wMDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMCwgMSwgNCwgNSk7XG4gICAgdG1wMjMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMCwgMSwgNCwgNSk7XG4gICAgb3V0MCAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMCwgMiwgNCwgNik7XG4gICAgb3V0MSAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMSwgMywgNSwgNyk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCAgb3V0MCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCAgb3V0MSk7XG5cbiAgICB0bXAwMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAyLCAzLCA2LCA3KTtcbiAgICB0bXAyMyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAyLCAzLCA2LCA3KTtcbiAgICBvdXQyICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAwLCAyLCA0LCA2KTtcbiAgICBvdXQzICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAxLCAzLCA1LCA3KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsICBvdXQyKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBvdXQzKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcHNlIGEgbWF0NCB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC50cmFuc3Bvc2UgOiBtYXQ0LnNjYWxhci50cmFuc3Bvc2U7XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDQgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIHZhciByb3cwLCByb3cxLCByb3cyLCByb3czLFxuICAgICAgdG1wMSxcbiAgICAgIG1pbm9yMCwgbWlub3IxLCBtaW5vcjIsIG1pbm9yMyxcbiAgICAgIGRldCxcbiAgICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKSxcbiAgICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KSxcbiAgICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KSxcbiAgICAgIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgLy8gQ29tcHV0ZSBtYXRyaXggYWRqdWdhdGVcbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAwLCAxLCA0LCA1KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAwLCAxLCA0LCA1KTtcbiAgcm93MCA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MSwgMCwgMiwgNCwgNik7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzEsIHRtcDEsIDEsIDMsIDUsIDcpO1xuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDIsIDMsIDYsIDcpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDIsIDMsIDYsIDcpO1xuICByb3cyID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3czLCAwLCAyLCA0LCA2KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MywgdG1wMSwgMSwgMywgNSwgNyk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjEsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjMpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMywgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MSwgMiwgMywgMCwgMSksIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICByb3cyICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzIsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IyLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93MSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMyk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IyLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IzKTtcblxuICAvLyBDb21wdXRlIG1hdHJpeCBkZXRlcm1pbmFudFxuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCBtaW5vcjApO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGRldCwgMiwgMywgMCwgMSksIGRldCk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoZGV0LCAxLCAwLCAzLCAyKSwgZGV0KTtcbiAgdG1wMSAgPSBTSU1ELkZsb2F0MzJ4NC5yZWNpcHJvY2FsQXBwcm94aW1hdGlvbihkZXQpO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LnN1YihcbiAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZCh0bXAxLCB0bXAxKSxcbiAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIFNJTUQuRmxvYXQzMng0Lm11bCh0bXAxLCB0bXAxKSkpO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoZGV0LCAwLCAwLCAwLCAwKTtcbiAgaWYgKCFkZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBtYXRyaXggaW52ZXJzZVxuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjApKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IxKSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMikpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjMpKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NCB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5pbnZlcnQgOiBtYXQ0LnNjYWxhci5pbnZlcnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICB2YXIgYTAsIGExLCBhMiwgYTM7XG4gIHZhciByb3cwLCByb3cxLCByb3cyLCByb3czO1xuICB2YXIgdG1wMTtcbiAgdmFyIG1pbm9yMCwgbWlub3IxLCBtaW5vcjIsIG1pbm9yMztcblxuICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICB2YXIgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICB2YXIgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAvLyBUcmFuc3Bvc2UgdGhlIHNvdXJjZSBtYXRyaXguICBTb3J0IG9mLiAgTm90IGEgdHJ1ZSB0cmFuc3Bvc2Ugb3BlcmF0aW9uXG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMCwgMSwgNCwgNSk7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMCwgMSwgNCwgNSk7XG4gIHJvdzAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzEsIDAsIDIsIDQsIDYpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3cxLCB0bXAxLCAxLCAzLCA1LCA3KTtcblxuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDIsIDMsIDYsIDcpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDIsIDMsIDYsIDcpO1xuICByb3cyID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3czLCAwLCAyLCA0LCA2KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MywgdG1wMSwgMSwgMywgNSwgNyk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjEsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjMpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMywgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MSwgMiwgMywgMCwgMSksIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICByb3cyICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzIsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IyLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93MSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMyk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMik7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IyLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IzKTtcblxuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsICBtaW5vcjApO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsICBtaW5vcjEpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsICBtaW5vcjIpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBtaW5vcjMpO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDQgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbiBtYXQ0LmFkam9pbnQgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5hZGpvaW50IDogbWF0NC5zY2FsYXIuYWRqb2ludDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3MgZXhwbGljaXRseSB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZCwgbXVzdCBiZSBhIEZsb2F0MzJBcnJheVxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZCwgbXVzdCBiZSBhIEZsb2F0MzJBcnJheVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIHZhciBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgdmFyIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgICB2YXIgYjAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDApO1xuICAgIHZhciBvdXQwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCBvdXQwKTtcblxuICAgIHZhciBiMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgNCk7XG4gICAgdmFyIG91dDEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsIG91dDEpO1xuXG4gICAgdmFyIGIyID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCA4KTtcbiAgICB2YXIgb3V0MiA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCBvdXQyKTtcblxuICAgIHZhciBiMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgMTIpO1xuICAgIHZhciBvdXQzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIzLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIG91dDMpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQncyB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELm11bHRpcGx5IDogbWF0NC5zY2FsYXIubXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKSxcbiAgICAgICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpLFxuICAgICAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCksXG4gICAgICAgIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMiksXG4gICAgICAgIHZlYyA9IFNJTUQuRmxvYXQzMng0KHZbMF0sIHZbMV0sIHZbMl0gLCAwKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTsgb3V0WzFdID0gYVsxXTsgb3V0WzJdID0gYVsyXTsgb3V0WzNdID0gYVszXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTsgb3V0WzVdID0gYVs1XTsgb3V0WzZdID0gYVs2XTsgb3V0WzddID0gYVs3XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTsgb3V0WzldID0gYVs5XTsgb3V0WzEwXSA9IGFbMTBdOyBvdXRbMTFdID0gYVsxMV07XG4gICAgfVxuXG4gICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoYTAsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAwLCAwLCAwLCAwKSk7XG4gICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoYTEsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAxLCAxLCAxLCAxKSk7XG4gICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoYTIsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAyLCAyLCAyLCAyKSk7XG5cbiAgICB2YXIgdDAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoYTAsIFNJTUQuRmxvYXQzMng0LmFkZChhMSwgU0lNRC5GbG9hdDMyeDQuYWRkKGEyLCBhMykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCB0MCk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc2xhdGUgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC50cmFuc2xhdGUgOiBtYXQ0LnNjYWxhci50cmFuc2xhdGU7XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5zY2FsYXIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LlNJTUQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAsIGExLCBhMjtcbiAgICB2YXIgdmVjID0gU0lNRC5GbG9hdDMyeDQodlswXSwgdlsxXSwgdlsyXSwgMCk7XG5cbiAgICBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUoXG4gICAgICAgIG91dCwgMCwgU0lNRC5GbG9hdDMyeDQubXVsKGEwLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMCwgMCwgMCwgMCkpKTtcblxuICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShcbiAgICAgICAgb3V0LCA0LCBTSU1ELkZsb2F0MzJ4NC5tdWwoYTEsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAxLCAxLCAxLCAxKSkpO1xuXG4gICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKFxuICAgICAgICBvdXQsIDgsIFNJTUQuRmxvYXQzMng0Lm11bChhMiwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDIsIDIsIDIsIDIpKSk7XG5cbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxlID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQuc2NhbGUgOiBtYXQ0LnNjYWxhci5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5zaW4ocmFkKSksXG4gICAgICAgIGMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLmNvcyhyYWQpKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIHZhciBhXzEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIHZhciBhXzIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIHMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgcykpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyB1c2luZyBTSU1EIGlmIGF2YWlsYWJlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQucm90YXRlWCA6IG1hdDQuc2NhbGFyLnJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLnNpbihyYWQpKSxcbiAgICAgICAgYyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguY29zKHJhZCkpO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIHZhciBhXzAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIHZhciBhXzIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIHMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBzKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgYykpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyBpZiBTSU1EIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbiBtYXQ0LnJvdGF0ZVkgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5yb3RhdGVZIDogbWF0NC5zY2FsYXIucm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5zaW4ocmFkKSksXG4gICAgICAgIGMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLmNvcyhyYWQpKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB2YXIgYV8wID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICB2YXIgYV8xID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIHMpKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMgaWYgU0lNRCBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG4gbWF0NC5yb3RhdGVaID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQucm90YXRlWiA6IG1hdDQuc2NhbGFyLnJvdGF0ZVo7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IHZbMl07XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0O1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICAgIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICAgIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gICAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICAgIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICAgIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWFJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSAxO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSBzO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAtcztcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVlSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gLXM7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSBzO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21aUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IHM7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gLXM7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5tYXQ0LmdldFRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxuICovXG5tYXQ0LmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKG91dCwgbWF0KSB7XG4gIC8vIEFsZ29yaXRobSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gIHZhciB0cmFjZSA9IG1hdFswXSArIG1hdFs1XSArIG1hdFsxMF07XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7IFxuICAgIFMgPSBNYXRoLnNxcnQodHJhY2UgKyAxLjApICogMjtcbiAgICBvdXRbM10gPSAwLjI1ICogUztcbiAgICBvdXRbMF0gPSAobWF0WzZdIC0gbWF0WzldKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs4XSAtIG1hdFsyXSkgLyBTOyBcbiAgICBvdXRbMl0gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7IFxuICB9IGVsc2UgaWYgKChtYXRbMF0gPiBtYXRbNV0pJihtYXRbMF0gPiBtYXRbMTBdKSkgeyBcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFswXSAtIG1hdFs1XSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzZdIC0gbWF0WzldKSAvIFM7XG4gICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgb3V0WzFdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTOyBcbiAgICBvdXRbMl0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7IFxuICB9IGVsc2UgaWYgKG1hdFs1XSA+IG1hdFsxMF0pIHsgXG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbNV0gLSBtYXRbMF0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs4XSAtIG1hdFsyXSkgLyBTO1xuICAgIG91dFswXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUzsgXG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTOyBcbiAgfSBlbHNlIHsgXG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMTBdIC0gbWF0WzBdIC0gbWF0WzVdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICAgIG91dFswXSA9IChtYXRbOF0gKyBtYXRbMl0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzZdICsgbWF0WzldKSAvIFM7XG4gICAgb3V0WzJdID0gMC4yNSAqIFM7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUgPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzKSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejIsXG4gICAgICAgIHN4ID0gc1swXSxcbiAgICAgICAgc3kgPSBzWzFdLFxuICAgICAgICBzeiA9IHNbMl07XG5cbiAgICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICAgIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICAgIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gICAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gICAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgeDIgPSB4ICsgeCxcbiAgICAgIHkyID0geSArIHksXG4gICAgICB6MiA9IHogKyB6LFxuXG4gICAgICB4eCA9IHggKiB4MixcbiAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgeHogPSB4ICogejIsXG4gICAgICB5eSA9IHkgKiB5MixcbiAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgenogPSB6ICogejIsXG4gICAgICB3eCA9IHcgKiB4MixcbiAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgd3ogPSB3ICogejIsXG5cbiAgICAgIHN4ID0gc1swXSxcbiAgICAgIHN5ID0gc1sxXSxcbiAgICAgIHN6ID0gc1syXSxcblxuICAgICAgb3ggPSBvWzBdLFxuICAgICAgb3kgPSBvWzFdLFxuICAgICAgb3ogPSBvWzJdO1xuXG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXRbMF0gKiBveCArIG91dFs0XSAqIG95ICsgb3V0WzhdICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dFsxXSAqIG94ICsgb3V0WzVdICogb3kgKyBvdXRbOV0gKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0WzJdICogb3ggKyBvdXRbNl0gKiBveSArIG91dFsxMF0gKiBveik7XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gZnVuY3Rpb24gKG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgICBvdXRbOV0gPSBhWzldIC0gYls5XTtcbiAgICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5zdWIgPSBtYXQ0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgb3V0WzZdID0gYVs2XSAqIGI7XG4gICAgb3V0WzddID0gYVs3XSAqIGI7XG4gICAgb3V0WzhdID0gYVs4XSAqIGI7XG4gICAgb3V0WzldID0gYVs5XSAqIGI7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICAgIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gICAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICAgIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gICAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICAgIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgICBvdXRbOV0gPSBhWzldICsgKGJbOV0gKiBzY2FsZSk7XG4gICAgb3V0WzEwXSA9IGFbMTBdICsgKGJbMTBdICogc2NhbGUpO1xuICAgIG91dFsxMV0gPSBhWzExXSArIChiWzExXSAqIHNjYWxlKTtcbiAgICBvdXRbMTJdID0gYVsxMl0gKyAoYlsxMl0gKiBzY2FsZSk7XG4gICAgb3V0WzEzXSA9IGFbMTNdICsgKGJbMTNdICogc2NhbGUpO1xuICAgIG91dFsxNF0gPSBhWzE0XSArIChiWzE0XSAqIHNjYWxlKTtcbiAgICBvdXRbMTVdID0gYVsxNV0gKyAoYlsxNV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQ0LmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBcbiAgICAgICAgICAgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBcbiAgICAgICAgICAgYVs4XSA9PT0gYls4XSAmJiBhWzldID09PSBiWzldICYmIGFbMTBdID09PSBiWzEwXSAmJiBhWzExXSA9PT0gYlsxMV0gJiZcbiAgICAgICAgICAgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgID0gYVswXSwgIGExICA9IGFbMV0sICBhMiAgPSBhWzJdLCAgYTMgID0gYVszXSxcbiAgICAgICAgYTQgID0gYVs0XSwgIGE1ICA9IGFbNV0sICBhNiAgPSBhWzZdLCAgYTcgID0gYVs3XSwgXG4gICAgICAgIGE4ICA9IGFbOF0sICBhOSAgPSBhWzldLCAgYTEwID0gYVsxMF0sIGExMSA9IGFbMTFdLCBcbiAgICAgICAgYTEyID0gYVsxMl0sIGExMyA9IGFbMTNdLCBhMTQgPSBhWzE0XSwgYTE1ID0gYVsxNV07XG5cbiAgICB2YXIgYjAgID0gYlswXSwgIGIxICA9IGJbMV0sICBiMiAgPSBiWzJdLCAgYjMgID0gYlszXSxcbiAgICAgICAgYjQgID0gYls0XSwgIGI1ICA9IGJbNV0sICBiNiAgPSBiWzZdLCAgYjcgID0gYls3XSwgXG4gICAgICAgIGI4ICA9IGJbOF0sICBiOSAgPSBiWzldLCAgYjEwID0gYlsxMF0sIGIxMSA9IGJbMTFdLCBcbiAgICAgICAgYjEyID0gYlsxMl0sIGIxMyA9IGJbMTNdLCBiMTQgPSBiWzE0XSwgYjE1ID0gYlsxNV07XG5cbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSkpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0NDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcbnZhciBtYXQzID0gcmVxdWlyZShcIi4vbWF0My5qc1wiKTtcbnZhciB2ZWMzID0gcmVxdWlyZShcIi4vdmVjMy5qc1wiKTtcbnZhciB2ZWM0ID0gcmVxdWlyZShcIi4vdmVjNC5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxuICogQHBhcmFtICB7cXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXG4gKi9cbnF1YXQuZ2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0X2F4aXMsIHEpIHtcbiAgICB2YXIgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcbiAgICBpZiAocyAhPSAwLjApIHtcbiAgICAgICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICAgICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgICAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgICAgIG91dF9heGlzWzJdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJhZDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gcXVhdC5jcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gcXVhdC5jcmVhdGUoKTtcbiAgXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgcXVhdC5zbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgcXVhdC5zbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgcXVhdC5zbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bMV0tbVszXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXhhY3RFcXVhbHMgPSB2ZWM0LmV4YWN0RXF1YWxzO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5xdWF0LmVxdWFscyA9IHZlYzQuZXF1YWxzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YXQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cbnZhciB2ZWMyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jZWlsID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmZsb29yID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yb3VuZCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIG91dFswXSA9IG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMyLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMyO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY2VpbCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZmxvb3IgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm91bmQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5oZXJtaXRlID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxLFxuICAgICAgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0LFxuICAgICAgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSksXG4gICAgICBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmJlemllciA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdCxcbiAgICAgIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3byxcbiAgICAgIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgICB3ID0gdyB8fCAxLjA7XG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICB2YXIgcCA9IFtdLCByPVtdO1xuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0ICBwWzBdID0gYVswXSAtIGJbMF07XG5cdCAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQgIC8vcGVyZm9ybSByb3RhdGlvblxuXHQgIHJbMF0gPSBwWzBdO1xuXHQgIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcblx0ICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cblx0ICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdCAgb3V0WzBdID0gclswXSArIGJbMF07XG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XG5cdCAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVZID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICBcdHJbMV0gPSBwWzFdO1xuICBcdHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVaID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICBcdHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzJdID0gcFsyXTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG52ZWMzLmFuZ2xlID0gZnVuY3Rpb24oYSwgYikge1xuICAgXG4gICAgdmFyIHRlbXBBID0gdmVjMy5mcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIHZhciB0ZW1wQiA9IHZlYzMuZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKTtcbiBcbiAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICAgIHZlYzMubm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG4gXG4gICAgdmFyIGNvc2luZSA9IHZlYzMuZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgfSAgICAgXG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmVjMy5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMztcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xudmFyIHZlYzQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0Lm11bCA9IHZlYzQubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXYgPSB2ZWM0LmRpdmlkZTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNlaWwgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5mbG9vciA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJvdW5kID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICAgIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpc3QgPSB2ZWM0LmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyRGlzdCA9IHZlYzQuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubGVuID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJMZW4gPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAtYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0geSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0geiAqIGxlbjtcbiAgICAgICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWM0LmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gICAgb3V0WzBdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzFdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzJdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzNdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgdmVjNC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHZlYzQuc2NhbGUob3V0LCBvdXQsIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWM0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWM0LmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmVjNC5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWM0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbFwiKTtcbnZhciBnbF9tYXRyaXhfMSA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG52YXIgZmluZEtleWZyYW1lc1JlcyA9IHtcbiAgICBmcmFtZTogMCxcbiAgICBsZWZ0OiBudWxsLFxuICAgIHJpZ2h0OiBudWxsXG59O1xuZnVuY3Rpb24gbGVycChsZWZ0LCByaWdodCwgdCkge1xuICAgIHJldHVybiBsZWZ0ICogKDEgLSB0KSArIHJpZ2h0ICogdDtcbn1cbmV4cG9ydHMubGVycCA9IGxlcnA7XG5mdW5jdGlvbiBiZXppZXIobGVmdCwgb3V0VGFuLCBpblRhbiwgcmlnaHQsIHQpIHtcbiAgICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0LCBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvciwgZmFjdG9yVGltZXMyID0gdCAqIHQsIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yLCBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd28sIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvciwgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gICAgcmV0dXJuIGxlZnQgKiBmYWN0b3IxICsgb3V0VGFuICogZmFjdG9yMiArIGluVGFuICogZmFjdG9yMyArIHJpZ2h0ICogZmFjdG9yNDtcbn1cbmZ1bmN0aW9uIGhlcm1pdGUobGVmdCwgb3V0VGFuLCBpblRhbiwgcmlnaHQsIHQpIHtcbiAgICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQsIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDEsIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdCwgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSksIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgICByZXR1cm4gbGVmdCAqIGZhY3RvcjEgKyBvdXRUYW4gKiBmYWN0b3IyICsgaW5UYW4gKiBmYWN0b3IzICsgcmlnaHQgKiBmYWN0b3I0O1xufVxuZnVuY3Rpb24gZmluZEtleWZyYW1lcyhhbmltVmVjdG9yLCBmcmFtZSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIWFuaW1WZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IGFuaW1WZWN0b3IuS2V5cztcbiAgICB2YXIgZmlyc3QgPSAwO1xuICAgIHZhciBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChhcnJheVswXS5GcmFtZSA+IHRvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcnJheVtjb3VudCAtIDFdLkZyYW1lIDwgZnJvbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICB2YXIgc3RlcCA9IGNvdW50ID4+IDE7XG4gICAgICAgIGlmIChhcnJheVtmaXJzdCArIHN0ZXBdLkZyYW1lIDw9IGZyYW1lKSB7XG4gICAgICAgICAgICBmaXJzdCA9IGZpcnN0ICsgc3RlcCArIDE7XG4gICAgICAgICAgICBjb3VudCAtPSBzdGVwICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ID0gc3RlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3QgPT09IGFycmF5Lmxlbmd0aCB8fCBhcnJheVtmaXJzdF0uRnJhbWUgPiB0bykge1xuICAgICAgICBpZiAoZmlyc3QgPiAwICYmIGFycmF5W2ZpcnN0IC0gMV0uRnJhbWUgPj0gZnJvbSkge1xuICAgICAgICAgICAgZmluZEtleWZyYW1lc1Jlcy5mcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgZmluZEtleWZyYW1lc1Jlcy5sZWZ0ID0gYXJyYXlbZmlyc3QgLSAxXTtcbiAgICAgICAgICAgIGZpbmRLZXlmcmFtZXNSZXMucmlnaHQgPSBhcnJheVtmaXJzdCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRLZXlmcmFtZXNSZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3QgPT09IDAgfHwgYXJyYXlbZmlyc3QgLSAxXS5GcmFtZSA8IGZyb20pIHtcbiAgICAgICAgaWYgKGFycmF5W2ZpcnN0XS5GcmFtZSA8PSB0bykge1xuICAgICAgICAgICAgZmluZEtleWZyYW1lc1Jlcy5mcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgZmluZEtleWZyYW1lc1Jlcy5sZWZ0ID0gYXJyYXlbZmlyc3RdO1xuICAgICAgICAgICAgZmluZEtleWZyYW1lc1Jlcy5yaWdodCA9IGFycmF5W2ZpcnN0XTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kS2V5ZnJhbWVzUmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZEtleWZyYW1lc1Jlcy5mcmFtZSA9IGZyYW1lO1xuICAgIGZpbmRLZXlmcmFtZXNSZXMubGVmdCA9IGFycmF5W2ZpcnN0IC0gMV07XG4gICAgZmluZEtleWZyYW1lc1Jlcy5yaWdodCA9IGFycmF5W2ZpcnN0XTtcbiAgICByZXR1cm4gZmluZEtleWZyYW1lc1Jlcztcbn1cbmV4cG9ydHMuZmluZEtleWZyYW1lcyA9IGZpbmRLZXlmcmFtZXM7XG5mdW5jdGlvbiBpbnRlcnBOdW0oZnJhbWUsIGxlZnQsIHJpZ2h0LCBsaW5lVHlwZSkge1xuICAgIGlmIChsZWZ0LkZyYW1lID09PSByaWdodC5GcmFtZSkge1xuICAgICAgICByZXR1cm4gbGVmdC5WZWN0b3JbMF07XG4gICAgfVxuICAgIHZhciB0ID0gKGZyYW1lIC0gbGVmdC5GcmFtZSkgLyAocmlnaHQuRnJhbWUgLSBsZWZ0LkZyYW1lKTtcbiAgICBpZiAobGluZVR5cGUgPT09IG1vZGVsXzEuTGluZVR5cGUuRG9udEludGVycCkge1xuICAgICAgICByZXR1cm4gbGVmdC5WZWN0b3JbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmVUeXBlID09PSBtb2RlbF8xLkxpbmVUeXBlLkJlemllcikge1xuICAgICAgICByZXR1cm4gYmV6aWVyKGxlZnQuVmVjdG9yWzBdLCBsZWZ0Lk91dFRhblswXSwgcmlnaHQuSW5UYW5bMF0sIHJpZ2h0LlZlY3RvclswXSwgdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmVUeXBlID09PSBtb2RlbF8xLkxpbmVUeXBlLkhlcm1pdGUpIHtcbiAgICAgICAgcmV0dXJuIGhlcm1pdGUobGVmdC5WZWN0b3JbMF0sIGxlZnQuT3V0VGFuWzBdLCByaWdodC5JblRhblswXSwgcmlnaHQuVmVjdG9yWzBdLCB0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIExpbmVhclxuICAgICAgICByZXR1cm4gbGVycChsZWZ0LlZlY3RvclswXSwgcmlnaHQuVmVjdG9yWzBdLCB0KTtcbiAgICB9XG59XG5leHBvcnRzLmludGVycE51bSA9IGludGVycE51bTtcbmZ1bmN0aW9uIGludGVycFZlYzMob3V0LCBmcmFtZSwgbGVmdCwgcmlnaHQsIGxpbmVUeXBlKSB7XG4gICAgaWYgKGxlZnQuRnJhbWUgPT09IHJpZ2h0LkZyYW1lKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LlZlY3RvcjtcbiAgICB9XG4gICAgdmFyIHQgPSAoZnJhbWUgLSBsZWZ0LkZyYW1lKSAvIChyaWdodC5GcmFtZSAtIGxlZnQuRnJhbWUpO1xuICAgIGlmIChsaW5lVHlwZSA9PT0gbW9kZWxfMS5MaW5lVHlwZS5Eb250SW50ZXJwKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LlZlY3RvcjtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluZVR5cGUgPT09IG1vZGVsXzEuTGluZVR5cGUuQmV6aWVyKSB7XG4gICAgICAgIHJldHVybiBnbF9tYXRyaXhfMS52ZWMzLmJlemllcihvdXQsIGxlZnQuVmVjdG9yLCBsZWZ0Lk91dFRhbiwgcmlnaHQuSW5UYW4sIHJpZ2h0LlZlY3RvciwgdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmVUeXBlID09PSBtb2RlbF8xLkxpbmVUeXBlLkhlcm1pdGUpIHtcbiAgICAgICAgcmV0dXJuIGdsX21hdHJpeF8xLnZlYzMuaGVybWl0ZShvdXQsIGxlZnQuVmVjdG9yLCBsZWZ0Lk91dFRhbiwgcmlnaHQuSW5UYW4sIHJpZ2h0LlZlY3RvciwgdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2xfbWF0cml4XzEudmVjMy5sZXJwKG91dCwgbGVmdC5WZWN0b3IsIHJpZ2h0LlZlY3RvciwgdCk7XG4gICAgfVxufVxuZXhwb3J0cy5pbnRlcnBWZWMzID0gaW50ZXJwVmVjMztcbmZ1bmN0aW9uIGludGVycFF1YXQob3V0LCBmcmFtZSwgbGVmdCwgcmlnaHQsIGxpbmVUeXBlKSB7XG4gICAgaWYgKGxlZnQuRnJhbWUgPT09IHJpZ2h0LkZyYW1lKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LlZlY3RvcjtcbiAgICB9XG4gICAgdmFyIHQgPSAoZnJhbWUgLSBsZWZ0LkZyYW1lKSAvIChyaWdodC5GcmFtZSAtIGxlZnQuRnJhbWUpO1xuICAgIGlmIChsaW5lVHlwZSA9PT0gbW9kZWxfMS5MaW5lVHlwZS5Eb250SW50ZXJwKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LlZlY3RvcjtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluZVR5cGUgPT09IG1vZGVsXzEuTGluZVR5cGUuSGVybWl0ZSB8fCBsaW5lVHlwZSA9PT0gbW9kZWxfMS5MaW5lVHlwZS5CZXppZXIpIHtcbiAgICAgICAgcmV0dXJuIGdsX21hdHJpeF8xLnF1YXQuc3FsZXJwKG91dCwgbGVmdC5WZWN0b3IsIGxlZnQuT3V0VGFuLCByaWdodC5JblRhbiwgcmlnaHQuVmVjdG9yLCB0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnbF9tYXRyaXhfMS5xdWF0LnNsZXJwKG91dCwgbGVmdC5WZWN0b3IsIHJpZ2h0LlZlY3RvciwgdCk7XG4gICAgfVxufVxuZXhwb3J0cy5pbnRlcnBRdWF0ID0gaW50ZXJwUXVhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbnRlcnBfMSA9IHJlcXVpcmUoXCIuL2ludGVycFwiKTtcbnZhciBmaW5kTG9jYWxGcmFtZVJlcyA9IHtcbiAgICBmcmFtZTogMCxcbiAgICBmcm9tOiAwLFxuICAgIHRvOiAwXG59O1xudmFyIE1vZGVsSW50ZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbEludGVycChyZW5kZXJlckRhdGEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEgPSByZW5kZXJlckRhdGE7XG4gICAgfVxuICAgIE1vZGVsSW50ZXJwLm1heEFuaW1WZWN0b3JWYWwgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4ID0gdmVjdG9yLktleXNbMF0uVmVjdG9yWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZlY3Rvci5LZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodmVjdG9yLktleXNbaV0uVmVjdG9yWzBdID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdmVjdG9yLktleXNbaV0uVmVjdG9yWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfTtcbiAgICBNb2RlbEludGVycC5wcm90b3R5cGUubnVtID0gZnVuY3Rpb24gKGFuaW1WZWN0b3IpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZmluZEtleWZyYW1lcyhhbmltVmVjdG9yKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnBfMS5pbnRlcnBOdW0ocmVzLmZyYW1lLCByZXMubGVmdCwgcmVzLnJpZ2h0LCBhbmltVmVjdG9yLkxpbmVUeXBlKTtcbiAgICB9O1xuICAgIE1vZGVsSW50ZXJwLnByb3RvdHlwZS52ZWMzID0gZnVuY3Rpb24gKG91dCwgYW5pbVZlY3Rvcikge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5maW5kS2V5ZnJhbWVzKGFuaW1WZWN0b3IpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVycF8xLmludGVycFZlYzMob3V0LCByZXMuZnJhbWUsIHJlcy5sZWZ0LCByZXMucmlnaHQsIGFuaW1WZWN0b3IuTGluZVR5cGUpO1xuICAgIH07XG4gICAgTW9kZWxJbnRlcnAucHJvdG90eXBlLnF1YXQgPSBmdW5jdGlvbiAob3V0LCBhbmltVmVjdG9yKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmZpbmRLZXlmcmFtZXMoYW5pbVZlY3Rvcik7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJwXzEuaW50ZXJwUXVhdChvdXQsIHJlcy5mcmFtZSwgcmVzLmxlZnQsIHJlcy5yaWdodCwgYW5pbVZlY3Rvci5MaW5lVHlwZSk7XG4gICAgfTtcbiAgICBNb2RlbEludGVycC5wcm90b3R5cGUuYW5pbVZlY3RvclZhbCA9IGZ1bmN0aW9uICh2ZWN0b3IsIGRlZmF1bHRWYWwpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2ZWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXMgPSB2ZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLm51bSh2ZWN0b3IpO1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IGRlZmF1bHRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE1vZGVsSW50ZXJwLnByb3RvdHlwZS5maW5kS2V5ZnJhbWVzID0gZnVuY3Rpb24gKGFuaW1WZWN0b3IpIHtcbiAgICAgICAgaWYgKCFhbmltVmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLmZpbmRMb2NhbEZyYW1lKGFuaW1WZWN0b3IpLCBmcmFtZSA9IF9hLmZyYW1lLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bztcbiAgICAgICAgcmV0dXJuIGludGVycF8xLmZpbmRLZXlmcmFtZXMoYW5pbVZlY3RvciwgZnJhbWUsIGZyb20sIHRvKTtcbiAgICB9O1xuICAgIE1vZGVsSW50ZXJwLnByb3RvdHlwZS5maW5kTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChhbmltVmVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5pbVZlY3Rvci5HbG9iYWxTZXFJZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZpbmRMb2NhbEZyYW1lUmVzLmZyYW1lID0gdGhpcy5yZW5kZXJlckRhdGEuZ2xvYmFsU2VxdWVuY2VzRnJhbWVzW2FuaW1WZWN0b3IuR2xvYmFsU2VxSWRdO1xuICAgICAgICAgICAgZmluZExvY2FsRnJhbWVSZXMuZnJvbSA9IDA7XG4gICAgICAgICAgICBmaW5kTG9jYWxGcmFtZVJlcy50byA9IHRoaXMucmVuZGVyZXJEYXRhLm1vZGVsLkdsb2JhbFNlcXVlbmNlc1thbmltVmVjdG9yLkdsb2JhbFNlcUlkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmRMb2NhbEZyYW1lUmVzLmZyYW1lID0gdGhpcy5yZW5kZXJlckRhdGEuZnJhbWU7XG4gICAgICAgICAgICBmaW5kTG9jYWxGcmFtZVJlcy5mcm9tID0gdGhpcy5yZW5kZXJlckRhdGEuYW5pbWF0aW9uSW5mby5JbnRlcnZhbFswXTtcbiAgICAgICAgICAgIGZpbmRMb2NhbEZyYW1lUmVzLnRvID0gdGhpcy5yZW5kZXJlckRhdGEuYW5pbWF0aW9uSW5mby5JbnRlcnZhbFsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZExvY2FsRnJhbWVSZXM7XG4gICAgfTtcbiAgICByZXR1cm4gTW9kZWxJbnRlcnA7XG59KCkpO1xuZXhwb3J0cy5Nb2RlbEludGVycCA9IE1vZGVsSW50ZXJwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWxJbnRlcnAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbFwiKTtcbnZhciBnbF9tYXRyaXhfMSA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBtb2RlbEludGVycF8xID0gcmVxdWlyZShcIi4vbW9kZWxJbnRlcnBcIik7XG52YXIgcGFydGljbGVzXzEgPSByZXF1aXJlKFwiLi9wYXJ0aWNsZXNcIik7XG52YXIgcmliYm9uc18xID0gcmVxdWlyZShcIi4vcmliYm9uc1wiKTtcbnZhciBNQVhfTk9ERVMgPSAxMjg7XG52YXIgZ2w7XG52YXIgc2hhZGVyUHJvZ3JhbTtcbnZhciBzaGFkZXJQcm9ncmFtTG9jYXRpb25zID0ge307XG52YXIgYW5pc290cm9waWNFeHQ7XG52YXIgdmVydGV4U2hhZGVySGFyZHdhcmVTa2lubmluZyA9IFwiXFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG4gICAgYXR0cmlidXRlIHZlYzQgYUdyb3VwO1xcblxcbiAgICB1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xcbiAgICB1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XFxuICAgIHVuaWZvcm0gbWF0NCB1Tm9kZXNNYXRyaWNlc1tcIiArIE1BWF9OT0RFUyArIFwiXTtcXG5cXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICB2ZWM0IHBvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgICAgICBpbnQgY291bnQgPSAxO1xcbiAgICAgICAgdmVjNCBzdW0gPSB1Tm9kZXNNYXRyaWNlc1tpbnQoYUdyb3VwWzBdKV0gKiBwb3NpdGlvbjtcXG5cXG4gICAgICAgIGlmIChhR3JvdXBbMV0gPCBcIiArIE1BWF9OT0RFUyArIFwiLikge1xcbiAgICAgICAgICAgIHN1bSArPSB1Tm9kZXNNYXRyaWNlc1tpbnQoYUdyb3VwWzFdKV0gKiBwb3NpdGlvbjtcXG4gICAgICAgICAgICBjb3VudCArPSAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGFHcm91cFsyXSA8IFwiICsgTUFYX05PREVTICsgXCIuKSB7XFxuICAgICAgICAgICAgc3VtICs9IHVOb2Rlc01hdHJpY2VzW2ludChhR3JvdXBbMl0pXSAqIHBvc2l0aW9uO1xcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYUdyb3VwWzNdIDwgXCIgKyBNQVhfTk9ERVMgKyBcIi4pIHtcXG4gICAgICAgICAgICBzdW0gKz0gdU5vZGVzTWF0cmljZXNbaW50KGFHcm91cFszXSldICogcG9zaXRpb247XFxuICAgICAgICAgICAgY291bnQgKz0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN1bS54eXogLz0gZmxvYXQoY291bnQpO1xcbiAgICAgICAgc3VtLncgPSAxLjtcXG4gICAgICAgIHBvc2l0aW9uID0gc3VtO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1UE1hdHJpeCAqIHVNVk1hdHJpeCAqIHBvc2l0aW9uO1xcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIH1cXG5cIjtcbnZhciB2ZXJ0ZXhTaGFkZXJTb2Z0d2FyZVNraW5uaW5nID0gXCJcXG4gICAgYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbiAgICB1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xcbiAgICB1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XFxuXFxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgdmVjNCBwb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1UE1hdHJpeCAqIHVNVk1hdHJpeCAqIHBvc2l0aW9uO1xcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIH1cXG5cIjtcbnZhciBmcmFnbWVudFNoYWRlciA9IFwiXFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuICAgIHVuaWZvcm0gdmVjMyB1UmVwbGFjZWFibGVDb2xvcjtcXG4gICAgdW5pZm9ybSBmbG9hdCB1UmVwbGFjZWFibGVUeXBlO1xcbiAgICB1bmlmb3JtIGZsb2F0IHVEaXNjYXJkQWxwaGFMZXZlbDtcXG4gICAgdW5pZm9ybSBtYXQzIHVUVmV4dGV4QW5pbTtcXG5cXG4gICAgZmxvYXQgaHlwb3QgKHZlYzIgeikge1xcbiAgICAgICAgZmxvYXQgdDtcXG4gICAgICAgIGZsb2F0IHggPSBhYnMoei54KTtcXG4gICAgICAgIGZsb2F0IHkgPSBhYnMoei55KTtcXG4gICAgICAgIHQgPSBtaW4oeCwgeSk7XFxuICAgICAgICB4ID0gbWF4KHgsIHkpO1xcbiAgICAgICAgdCA9IHQgLyB4O1xcbiAgICAgICAgcmV0dXJuICh6LnggPT0gMC4wICYmIHoueSA9PSAwLjApID8gMC4wIDogeCAqIHNxcnQoMS4wICsgdCAqIHQpO1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICB2ZWMyIHRleENvb3JkID0gKHVUVmV4dGV4QW5pbSAqIHZlYzModlRleHR1cmVDb29yZC5zLCB2VGV4dHVyZUNvb3JkLnQsIDEuKSkuc3Q7XFxuXFxuICAgICAgICBpZiAodVJlcGxhY2VhYmxlVHlwZSA9PSAwLikge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdGV4Q29vcmQpO1xcbiAgICAgICAgfSBlbHNlIGlmICh1UmVwbGFjZWFibGVUeXBlID09IDEuKSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1UmVwbGFjZWFibGVDb2xvciwgMS4wKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodVJlcGxhY2VhYmxlVHlwZSA9PSAyLikge1xcbiAgICAgICAgICAgIGZsb2F0IGRpc3QgPSBoeXBvdCh0ZXhDb29yZCAtIHZlYzIoMC41LCAwLjUpKSAqIDIuO1xcbiAgICAgICAgICAgIGZsb2F0IHRydW5jYXRlRGlzdCA9IGNsYW1wKDEuIC0gZGlzdCAqIDEuNCwgMC4sIDEuKTtcXG4gICAgICAgICAgICBmbG9hdCBhbHBoYSA9IHNpbih0cnVuY2F0ZURpc3QpO1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodVJlcGxhY2VhYmxlQ29sb3IgKiBhbHBoYSwgMS4wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIGhhbmQtbWFkZSBhbHBoYS10ZXN0XFxuICAgICAgICBpZiAoZ2xfRnJhZ0NvbG9yWzNdIDwgdURpc2NhcmRBbHBoYUxldmVsKSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgfVxcblwiO1xudmFyIHRyYW5zbGF0aW9uID0gZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKTtcbnZhciByb3RhdGlvbiA9IGdsX21hdHJpeF8xLnF1YXQuY3JlYXRlKCk7XG52YXIgc2NhbGluZyA9IGdsX21hdHJpeF8xLnZlYzMuY3JlYXRlKCk7XG52YXIgZGVmYXVsdFRyYW5zbGF0aW9uID0gZ2xfbWF0cml4XzEudmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApO1xudmFyIGRlZmF1bHRSb3RhdGlvbiA9IGdsX21hdHJpeF8xLnF1YXQuZnJvbVZhbHVlcygwLCAwLCAwLCAxKTtcbnZhciBkZWZhdWx0U2NhbGluZyA9IGdsX21hdHJpeF8xLnZlYzMuZnJvbVZhbHVlcygxLCAxLCAxKTtcbnZhciB0ZW1wUGFyZW50Um90YXRpb25RdWF0ID0gZ2xfbWF0cml4XzEucXVhdC5jcmVhdGUoKTtcbnZhciB0ZW1wUGFyZW50Um90YXRpb25NYXQgPSBnbF9tYXRyaXhfMS5tYXQ0LmNyZWF0ZSgpO1xudmFyIHRlbXBDYW1lcmFNYXQgPSBnbF9tYXRyaXhfMS5tYXQ0LmNyZWF0ZSgpO1xudmFyIHRlbXBUcmFuc2Zvcm1lZFBpdm90UG9pbnQgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBBeGlzID0gZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKTtcbnZhciB0ZW1wTG9ja1F1YXQgPSBnbF9tYXRyaXhfMS5xdWF0LmNyZWF0ZSgpO1xudmFyIHRlbXBMb2NrTWF0ID0gZ2xfbWF0cml4XzEubWF0NC5jcmVhdGUoKTtcbnZhciB0ZW1wWEF4aXMgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBDYW1lcmFWZWMgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBDcm9zczAgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBDcm9zczEgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBQb3MgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBTdW0gPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHRlbXBWZWMzID0gZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKTtcbnZhciBpZGVudGlmeU1hdDMgPSBnbF9tYXRyaXhfMS5tYXQzLmNyZWF0ZSgpO1xudmFyIHRleENvb3JkTWF0NCA9IGdsX21hdHJpeF8xLm1hdDQuY3JlYXRlKCk7XG52YXIgdGV4Q29vcmRNYXQzID0gZ2xfbWF0cml4XzEubWF0My5jcmVhdGUoKTtcbnZhciBNb2RlbFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbFJlbmRlcmVyKG1vZGVsKSB7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gW107XG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTsgLy8gQXJyYXkgcGVyIGdlb3NldCBmb3Igc29mdHdhcmUgc2tpbm5pbmdcbiAgICAgICAgdGhpcy50ZXhDb29yZEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuZ3JvdXBCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgICAgIGZyYW1lOiAwLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBudWxsLFxuICAgICAgICAgICAgYW5pbWF0aW9uSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGdsb2JhbFNlcXVlbmNlc0ZyYW1lczogW10sXG4gICAgICAgICAgICByb290Tm9kZTogbnVsbCxcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIGdlb3NldEFuaW1zOiBbXSxcbiAgICAgICAgICAgIGdlb3NldEFscGhhOiBbXSxcbiAgICAgICAgICAgIG1hdGVyaWFsTGF5ZXJUZXh0dXJlSUQ6IFtdLFxuICAgICAgICAgICAgdGVhbUNvbG9yOiBudWxsLFxuICAgICAgICAgICAgY2FtZXJhUG9zOiBudWxsLFxuICAgICAgICAgICAgY2FtZXJhUXVhdDogbnVsbCxcbiAgICAgICAgICAgIHRleHR1cmVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlcmVyRGF0YS50ZWFtQ29sb3IgPSBnbF9tYXRyaXhfMS52ZWMzLmZyb21WYWx1ZXMoMS4sIDAuLCAwLik7XG4gICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmNhbWVyYVBvcyA9IGdsX21hdHJpeF8xLnZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmNhbWVyYVF1YXQgPSBnbF9tYXRyaXhfMS5xdWF0LmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLnNldFNlcXVlbmNlKDApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyRGF0YS5yb290Tm9kZSA9IHtcbiAgICAgICAgICAgIC8vIHRvZG9cbiAgICAgICAgICAgIG5vZGU6IHt9LFxuICAgICAgICAgICAgbWF0cml4OiBnbF9tYXRyaXhfMS5tYXQ0LmNyZWF0ZSgpLFxuICAgICAgICAgICAgY2hpbGRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbW9kZWwuTm9kZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLm5vZGVzW25vZGUuT2JqZWN0SWRdID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgbWF0cml4OiBnbF9tYXRyaXhfMS5tYXQ0LmNyZWF0ZSgpLFxuICAgICAgICAgICAgICAgIGNoaWxkczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IG1vZGVsLk5vZGVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfY1tfYl07XG4gICAgICAgICAgICBpZiAoIW5vZGUuUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEucm9vdE5vZGUuY2hpbGRzLnB1c2godGhpcy5yZW5kZXJlckRhdGEubm9kZXNbbm9kZS5PYmplY3RJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEubm9kZXNbbm9kZS5QYXJlbnRdLmNoaWxkcy5wdXNoKHRoaXMucmVuZGVyZXJEYXRhLm5vZGVzW25vZGUuT2JqZWN0SWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZWwuR2xvYmFsU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVsLkdsb2JhbFNlcXVlbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmdsb2JhbFNlcXVlbmNlc0ZyYW1lc1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbC5HZW9zZXRBbmltcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEuZ2Vvc2V0QW5pbXNbbW9kZWwuR2Vvc2V0QW5pbXNbaV0uR2Vvc2V0SWRdID0gbW9kZWwuR2Vvc2V0QW5pbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbC5NYXRlcmlhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLm1hdGVyaWFsTGF5ZXJUZXh0dXJlSURbaV0gPSBuZXcgQXJyYXkobW9kZWwuTWF0ZXJpYWxzW2ldLkxheWVycy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJwID0gbmV3IG1vZGVsSW50ZXJwXzEuTW9kZWxJbnRlcnAodGhpcy5yZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlc0NvbnRyb2xsZXIgPSBuZXcgcGFydGljbGVzXzEuUGFydGljbGVzQ29udHJvbGxlcih0aGlzLmludGVycCwgdGhpcy5yZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLnJpYmJvbnNDb250cm9sbGVyID0gbmV3IHJpYmJvbnNfMS5SaWJib25zQ29udHJvbGxlcih0aGlzLmludGVycCwgdGhpcy5yZW5kZXJlckRhdGEpO1xuICAgIH1cbiAgICBNb2RlbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0R0wgPSBmdW5jdGlvbiAoZ2xDb250ZXh0KSB7XG4gICAgICAgIGdsID0gZ2xDb250ZXh0O1xuICAgICAgICAvLyBNYXggYm9uZXMgKyBNViArIFBcbiAgICAgICAgdGhpcy5zb2Z0d2FyZVNraW5uaW5nID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSA8IDQgKiAoTUFYX05PREVTICsgMik7XG4gICAgICAgIGFuaXNvdHJvcGljRXh0ID0gKGdsLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJykgfHxcbiAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8XG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSk7XG4gICAgICAgIHRoaXMuaW5pdFNoYWRlcnMoKTtcbiAgICAgICAgdGhpcy5pbml0QnVmZmVycygpO1xuICAgICAgICBwYXJ0aWNsZXNfMS5QYXJ0aWNsZXNDb250cm9sbGVyLmluaXRHTChnbENvbnRleHQpO1xuICAgICAgICByaWJib25zXzEuUmliYm9uc0NvbnRyb2xsZXIuaW5pdEdMKGdsQ29udGV4dCk7XG4gICAgfTtcbiAgICBNb2RlbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0dXJlSW1hZ2UgPSBmdW5jdGlvbiAocGF0aCwgaW1nLCBmbGFncykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyRGF0YS50ZXh0dXJlc1twYXRoXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJlckRhdGEudGV4dHVyZXNbcGF0aF0pO1xuICAgICAgICAvLyBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcpO1xuICAgICAgICB0aGlzLnNldFRleHR1cmVQYXJhbWV0ZXJzKGZsYWdzKTtcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH07XG4gICAgTW9kZWxSZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dHVyZUltYWdlRGF0YSA9IGZ1bmN0aW9uIChwYXRoLCBpbWFnZURhdGEsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLnRleHR1cmVzW3BhdGhdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnJlbmRlcmVyRGF0YS50ZXh0dXJlc1twYXRoXSk7XG4gICAgICAgIC8vIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBpLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZURhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZVBhcmFtZXRlcnMoZmxhZ3MpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLnNldENhbWVyYSA9IGZ1bmN0aW9uIChjYW1lcmFQb3MsIGNhbWVyYVF1YXQpIHtcbiAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5jb3B5KHRoaXMucmVuZGVyZXJEYXRhLmNhbWVyYVBvcywgY2FtZXJhUG9zKTtcbiAgICAgICAgZ2xfbWF0cml4XzEucXVhdC5jb3B5KHRoaXMucmVuZGVyZXJEYXRhLmNhbWVyYVF1YXQsIGNhbWVyYVF1YXQpO1xuICAgIH07XG4gICAgTW9kZWxSZW5kZXJlci5wcm90b3R5cGUuc2V0U2VxdWVuY2UgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEuYW5pbWF0aW9uID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmFuaW1hdGlvbkluZm8gPSB0aGlzLm1vZGVsLlNlcXVlbmNlc1t0aGlzLnJlbmRlcmVyRGF0YS5hbmltYXRpb25dO1xuICAgICAgICB0aGlzLnJlbmRlcmVyRGF0YS5mcmFtZSA9IHRoaXMucmVuZGVyZXJEYXRhLmFuaW1hdGlvbkluZm8uSW50ZXJ2YWxbMF07XG4gICAgfTtcbiAgICBNb2RlbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZWFtQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5jb3B5KHRoaXMucmVuZGVyZXJEYXRhLnRlYW1Db2xvciwgY29sb3IpO1xuICAgIH07XG4gICAgTW9kZWxSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmZyYW1lICs9IGRlbHRhO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlckRhdGEuZnJhbWUgPiB0aGlzLnJlbmRlcmVyRGF0YS5hbmltYXRpb25JbmZvLkludGVydmFsWzFdKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyRGF0YS5mcmFtZSA9IHRoaXMucmVuZGVyZXJEYXRhLmFuaW1hdGlvbkluZm8uSW50ZXJ2YWxbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVHbG9iYWxTZXF1ZW5jZXMoZGVsdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZU5vZGUodGhpcy5yZW5kZXJlckRhdGEucm9vdE5vZGUpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlc0NvbnRyb2xsZXIudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgdGhpcy5yaWJib25zQ29udHJvbGxlci51cGRhdGUoZGVsdGEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kZWwuR2Vvc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEuZ2Vvc2V0QWxwaGFbaV0gPSB0aGlzLmZpbmRBbHBoYShpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVuZGVyZXJEYXRhLm1hdGVyaWFsTGF5ZXJUZXh0dXJlSUQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5yZW5kZXJlckRhdGEubWF0ZXJpYWxMYXllclRleHR1cmVJRFtpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGF5ZXJUZXh0dXJlSWQoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChtdk1hdHJpeCwgcE1hdHJpeCkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMucE1hdHJpeFVuaWZvcm0sIGZhbHNlLCBwTWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLm12TWF0cml4VW5pZm9ybSwgZmFsc2UsIG12TWF0cml4KTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSk7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudGV4dHVyZUNvb3JkQXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLnNvZnR3YXJlU2tpbm5pbmcpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZ3JvdXBBdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zb2Z0d2FyZVNraW5uaW5nKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IE1BWF9OT0RFUzsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyZXJEYXRhLm5vZGVzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5ub2Rlc01hdHJpY2VzQXR0cmlidXRlc1tqXSwgZmFsc2UsIHRoaXMucmVuZGVyZXJEYXRhLm5vZGVzW2pdLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbC5HZW9zZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlckRhdGEuZ2Vvc2V0QWxwaGFbaV0gPCAxZS02KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zb2Z0d2FyZVNraW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUdlb3NldFZlcnRpY2VzKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1hdGVyaWFsSUQgPSB0aGlzLm1vZGVsLkdlb3NldHNbaV0uTWF0ZXJpYWxJRDtcbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMubW9kZWwuTWF0ZXJpYWxzW21hdGVyaWFsSURdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRlcmlhbC5MYXllcnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExheWVyUHJvcHMobWF0ZXJpYWwuTGF5ZXJzW2pdLCB0aGlzLnJlbmRlcmVyRGF0YS5tYXRlcmlhbExheWVyVGV4dHVyZUlEW21hdGVyaWFsSURdW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXJbaV0pO1xuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50ZXhDb29yZEJ1ZmZlcltpXSk7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc29mdHdhcmVTa2lubmluZykge1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5ncm91cEJ1ZmZlcltpXSk7XG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5ncm91cEF0dHJpYnV0ZSwgNCwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyW2ldKTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLm1vZGVsLkdlb3NldHNbaV0uRmFjZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIXRoaXMuc29mdHdhcmVTa2lubmluZykge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZ3JvdXBBdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGljbGVzQ29udHJvbGxlci5yZW5kZXIobXZNYXRyaXgsIHBNYXRyaXgpO1xuICAgICAgICB0aGlzLnJpYmJvbnNDb250cm9sbGVyLnJlbmRlcihtdk1hdHJpeCwgcE1hdHJpeCk7XG4gICAgfTtcbiAgICBNb2RlbFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUdlb3NldFZlcnRpY2VzID0gZnVuY3Rpb24gKGdlb3NldEluZGV4KSB7XG4gICAgICAgIHZhciBnZW9zZXQgPSB0aGlzLm1vZGVsLkdlb3NldHNbZ2Vvc2V0SW5kZXhdO1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy52ZXJ0aWNlc1tnZW9zZXRJbmRleF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpIC8gMztcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdlb3NldC5Hcm91cHNbZ2Vvc2V0LlZlcnRleEdyb3VwW2luZGV4XV07XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnNldCh0ZW1wUG9zLCBnZW9zZXQuVmVydGljZXNbaV0sIGdlb3NldC5WZXJ0aWNlc1tpICsgMV0sIGdlb3NldC5WZXJ0aWNlc1tpICsgMl0pO1xuICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5zZXQodGVtcFN1bSwgMCwgMCwgMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5hZGQodGVtcFN1bSwgdGVtcFN1bSwgZ2xfbWF0cml4XzEudmVjMy50cmFuc2Zvcm1NYXQ0KHRlbXBWZWMzLCB0ZW1wUG9zLCB0aGlzLnJlbmRlcmVyRGF0YS5ub2Rlc1tncm91cFtqXV0ubWF0cml4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnNjYWxlKHRlbXBQb3MsIHRlbXBTdW0sIDEgLyBncm91cC5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyW2ldID0gdGVtcFBvc1swXTtcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMV0gPSB0ZW1wUG9zWzFdO1xuICAgICAgICAgICAgYnVmZmVyW2kgKyAyXSA9IHRlbXBQb3NbMl07XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyW2dlb3NldEluZGV4XSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgfTtcbiAgICBNb2RlbFJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0dXJlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgJiBtb2RlbF8xLlRleHR1cmVGbGFncy5XcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiBtb2RlbF8xLlRleHR1cmVGbGFncy5XcmFwSGVpZ2h0KSB7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICBpZiAoYW5pc290cm9waWNFeHQpIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBnbC5nZXRQYXJhbWV0ZXIoYW5pc290cm9waWNFeHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCwgYW5pc290cm9waWNFeHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIG1heCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUxheWVyVGV4dHVyZUlkID0gZnVuY3Rpb24gKG1hdGVyaWFsSWQsIGxheWVySWQpIHtcbiAgICAgICAgdmFyIFRleHR1cmVJRCA9IHRoaXMubW9kZWwuTWF0ZXJpYWxzW21hdGVyaWFsSWRdLkxheWVyc1tsYXllcklkXS5UZXh0dXJlSUQ7XG4gICAgICAgIGlmICh0eXBlb2YgVGV4dHVyZUlEID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEubWF0ZXJpYWxMYXllclRleHR1cmVJRFttYXRlcmlhbElkXVtsYXllcklkXSA9IFRleHR1cmVJRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLm1hdGVyaWFsTGF5ZXJUZXh0dXJlSURbbWF0ZXJpYWxJZF1bbGF5ZXJJZF0gPSB0aGlzLmludGVycC5udW0oVGV4dHVyZUlEKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWxSZW5kZXJlci5wcm90b3R5cGUuaW5pdFNoYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzaGFkZXJQcm9ncmFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnRleCA9IHV0aWxfMS5nZXRTaGFkZXIoZ2wsIHRoaXMuc29mdHdhcmVTa2lubmluZyA/IHZlcnRleFNoYWRlclNvZnR3YXJlU2tpbm5pbmcgOiB2ZXJ0ZXhTaGFkZXJIYXJkd2FyZVNraW5uaW5nLCBnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gdXRpbF8xLmdldFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXIsIGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgIHNoYWRlclByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXgpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgZnJhZ21lbnQpO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICAgICAgYWxlcnQoJ0NvdWxkIG5vdCBpbml0aWFsaXNlIHNoYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBnbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sICdhVGV4dHVyZUNvb3JkJyk7XG4gICAgICAgIGlmICghdGhpcy5zb2Z0d2FyZVNraW5uaW5nKSB7XG4gICAgICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmdyb3VwQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FHcm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMucE1hdHJpeFVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ3VQTWF0cml4Jyk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMubXZNYXRyaXhVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1TVZNYXRyaXgnKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5zYW1wbGVyVW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndVNhbXBsZXInKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZUNvbG9yVW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndVJlcGxhY2VhYmxlQ29sb3InKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZVR5cGVVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1UmVwbGFjZWFibGVUeXBlJyk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZGlzY2FyZEFscGhhTGV2ZWxVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1RGlzY2FyZEFscGhhTGV2ZWwnKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy50VmVydGV4QW5pbVVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ3VUVmV4dGV4QW5pbScpO1xuICAgICAgICBpZiAoIXRoaXMuc29mdHdhcmVTa2lubmluZykge1xuICAgICAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5ub2Rlc01hdHJpY2VzQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNQVhfTk9ERVM7ICsraSkge1xuICAgICAgICAgICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMubm9kZXNNYXRyaWNlc0F0dHJpYnV0ZXNbaV0gPVxuICAgICAgICAgICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ1Tm9kZXNNYXRyaWNlc1tcIiArIGkgKyBcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLmluaXRCdWZmZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kZWwuR2Vvc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJbaV0gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvZnR3YXJlU2tpbm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZGVsLkdlb3NldHNbaV0uVmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcltpXSk7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMubW9kZWwuR2Vvc2V0c1tpXS5WZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50ZXhDb29yZEJ1ZmZlcltpXSA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4Q29vcmRCdWZmZXJbaV0pO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMubW9kZWwuR2Vvc2V0c1tpXS5UVmVydGljZXNbMF0sIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zb2Z0d2FyZVNraW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEJ1ZmZlcltpXSA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmdyb3VwQnVmZmVyW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tb2RlbC5HZW9zZXRzW2ldLlZlcnRleEdyb3VwLmxlbmd0aCAqIDQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVmZmVyLmxlbmd0aDsgaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGogLyA0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLm1vZGVsLkdlb3NldHNbaV0uR3JvdXBzW3RoaXMubW9kZWwuR2Vvc2V0c1tpXS5WZXJ0ZXhHcm91cFtpbmRleF1dO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbal0gPSBncm91cFswXTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ogKyAxXSA9IGdyb3VwLmxlbmd0aCA+IDEgPyBncm91cFsxXSA6IE1BWF9OT0RFUztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ogKyAyXSA9IGdyb3VwLmxlbmd0aCA+IDIgPyBncm91cFsyXSA6IE1BWF9OT0RFUztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ogKyAzXSA9IGdyb3VwLmxlbmd0aCA+IDMgPyBncm91cFszXSA6IE1BWF9OT0RFUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlcltpXSA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcltpXSk7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLm1vZGVsLkdlb3NldHNbaV0uRmFjZXMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypwcml2YXRlIHJlc2V0R2xvYmFsU2VxdWVuY2VzICgpOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlbmRlcmVyRGF0YS5nbG9iYWxTZXF1ZW5jZXNGcmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmdsb2JhbFNlcXVlbmNlc0ZyYW1lc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9Ki9cbiAgICBNb2RlbFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVHbG9iYWxTZXF1ZW5jZXMgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlbmRlcmVyRGF0YS5nbG9iYWxTZXF1ZW5jZXNGcmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmdsb2JhbFNlcXVlbmNlc0ZyYW1lc1tpXSArPSBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyRGF0YS5nbG9iYWxTZXF1ZW5jZXNGcmFtZXNbaV0gPiB0aGlzLm1vZGVsLkdsb2JhbFNlcXVlbmNlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXJEYXRhLmdsb2JhbFNlcXVlbmNlc0ZyYW1lc1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdHJhbnNsYXRpb25SZXMgPSB0aGlzLmludGVycC52ZWMzKHRyYW5zbGF0aW9uLCBub2RlLm5vZGUuVHJhbnNsYXRpb24pO1xuICAgICAgICB2YXIgcm90YXRpb25SZXMgPSB0aGlzLmludGVycC5xdWF0KHJvdGF0aW9uLCBub2RlLm5vZGUuUm90YXRpb24pO1xuICAgICAgICB2YXIgc2NhbGluZ1JlcyA9IHRoaXMuaW50ZXJwLnZlYzMoc2NhbGluZywgbm9kZS5ub2RlLlNjYWxpbmcpO1xuICAgICAgICBpZiAoIXRyYW5zbGF0aW9uUmVzICYmICFyb3RhdGlvblJlcyAmJiAhc2NhbGluZ1Jlcykge1xuICAgICAgICAgICAgZ2xfbWF0cml4XzEubWF0NC5pZGVudGl0eShub2RlLm1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb25SZXMgJiYgIXJvdGF0aW9uUmVzICYmICFzY2FsaW5nUmVzKSB7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS5tYXQ0LmZyb21UcmFuc2xhdGlvbihub2RlLm1hdHJpeCwgdHJhbnNsYXRpb25SZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0cmFuc2xhdGlvblJlcyAmJiByb3RhdGlvblJlcyAmJiAhc2NhbGluZ1Jlcykge1xuICAgICAgICAgICAgdXRpbF8xLm1hdDRmcm9tUm90YXRpb25PcmlnaW4obm9kZS5tYXRyaXgsIHJvdGF0aW9uUmVzLCBub2RlLm5vZGUuUGl2b3RQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4obm9kZS5tYXRyaXgsIHJvdGF0aW9uUmVzIHx8IGRlZmF1bHRSb3RhdGlvbiwgdHJhbnNsYXRpb25SZXMgfHwgZGVmYXVsdFRyYW5zbGF0aW9uLCBzY2FsaW5nUmVzIHx8IGRlZmF1bHRTY2FsaW5nLCBub2RlLm5vZGUuUGl2b3RQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubm9kZS5QYXJlbnQpIHtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLm1hdDQubXVsKG5vZGUubWF0cml4LCB0aGlzLnJlbmRlcmVyRGF0YS5ub2Rlc1tub2RlLm5vZGUuUGFyZW50XS5tYXRyaXgsIG5vZGUubWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmlsbGJvYXJkZWRMb2NrID0gbm9kZS5ub2RlLkZsYWdzICYgbW9kZWxfMS5Ob2RlRmxhZ3MuQmlsbGJvYXJkZWRMb2NrWCB8fFxuICAgICAgICAgICAgbm9kZS5ub2RlLkZsYWdzICYgbW9kZWxfMS5Ob2RlRmxhZ3MuQmlsbGJvYXJkZWRMb2NrWSB8fFxuICAgICAgICAgICAgbm9kZS5ub2RlLkZsYWdzICYgbW9kZWxfMS5Ob2RlRmxhZ3MuQmlsbGJvYXJkZWRMb2NrWjtcbiAgICAgICAgaWYgKG5vZGUubm9kZS5GbGFncyAmIG1vZGVsXzEuTm9kZUZsYWdzLkJpbGxib2FyZGVkKSB7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnRyYW5zZm9ybU1hdDQodGVtcFRyYW5zZm9ybWVkUGl2b3RQb2ludCwgbm9kZS5ub2RlLlBpdm90UG9pbnQsIG5vZGUubWF0cml4KTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGUuUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIHBhcmVudCByb3RhdGlvbiBmcm9tIFBpdm90UG9pbnRcbiAgICAgICAgICAgICAgICBnbF9tYXRyaXhfMS5tYXQ0LmdldFJvdGF0aW9uKHRlbXBQYXJlbnRSb3RhdGlvblF1YXQsIHRoaXMucmVuZGVyZXJEYXRhLm5vZGVzW25vZGUubm9kZS5QYXJlbnRdLm1hdHJpeCk7XG4gICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEucXVhdC5pbnZlcnQodGVtcFBhcmVudFJvdGF0aW9uUXVhdCwgdGVtcFBhcmVudFJvdGF0aW9uUXVhdCk7XG4gICAgICAgICAgICAgICAgdXRpbF8xLm1hdDRmcm9tUm90YXRpb25PcmlnaW4odGVtcFBhcmVudFJvdGF0aW9uTWF0LCB0ZW1wUGFyZW50Um90YXRpb25RdWF0LCB0ZW1wVHJhbnNmb3JtZWRQaXZvdFBvaW50KTtcbiAgICAgICAgICAgICAgICBnbF9tYXRyaXhfMS5tYXQ0Lm11bChub2RlLm1hdHJpeCwgdGVtcFBhcmVudFJvdGF0aW9uTWF0LCBub2RlLm1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByb3RhdGUgdG8gY2FtZXJhXG4gICAgICAgICAgICB1dGlsXzEubWF0NGZyb21Sb3RhdGlvbk9yaWdpbih0ZW1wQ2FtZXJhTWF0LCB0aGlzLnJlbmRlcmVyRGF0YS5jYW1lcmFRdWF0LCB0ZW1wVHJhbnNmb3JtZWRQaXZvdFBvaW50KTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLm1hdDQubXVsKG5vZGUubWF0cml4LCB0ZW1wQ2FtZXJhTWF0LCBub2RlLm1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmlsbGJvYXJkZWRMb2NrKSB7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnRyYW5zZm9ybU1hdDQodGVtcFRyYW5zZm9ybWVkUGl2b3RQb2ludCwgbm9kZS5ub2RlLlBpdm90UG9pbnQsIG5vZGUubWF0cml4KTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuY29weSh0ZW1wQXhpcywgbm9kZS5ub2RlLlBpdm90UG9pbnQpO1xuICAgICAgICAgICAgLy8gdG9kbyBCaWxsYm9hcmRlZExvY2tYID9cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGUuRmxhZ3MgJiBtb2RlbF8xLk5vZGVGbGFncy5CaWxsYm9hcmRlZExvY2tYKSB7XG4gICAgICAgICAgICAgICAgdGVtcEF4aXNbMF0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZS5GbGFncyAmIG1vZGVsXzEuTm9kZUZsYWdzLkJpbGxib2FyZGVkTG9ja1kpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQXhpc1sxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlLkZsYWdzICYgbW9kZWxfMS5Ob2RlRmxhZ3MuQmlsbGJvYXJkZWRMb2NrWikge1xuICAgICAgICAgICAgICAgIHRlbXBBeGlzWzJdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnRyYW5zZm9ybU1hdDQodGVtcEF4aXMsIHRlbXBBeGlzLCBub2RlLm1hdHJpeCk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnN1Yih0ZW1wQXhpcywgdGVtcEF4aXMsIHRlbXBUcmFuc2Zvcm1lZFBpdm90UG9pbnQpO1xuICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5zZXQodGVtcFhBeGlzLCAxLCAwLCAwKTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuYWRkKHRlbXBYQXhpcywgdGVtcFhBeGlzLCBub2RlLm5vZGUuUGl2b3RQb2ludCk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnRyYW5zZm9ybU1hdDQodGVtcFhBeGlzLCB0ZW1wWEF4aXMsIG5vZGUubWF0cml4KTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuc3ViKHRlbXBYQXhpcywgdGVtcFhBeGlzLCB0ZW1wVHJhbnNmb3JtZWRQaXZvdFBvaW50KTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuc2V0KHRlbXBDYW1lcmFWZWMsIC0xLCAwLCAwKTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMudHJhbnNmb3JtUXVhdCh0ZW1wQ2FtZXJhVmVjLCB0ZW1wQ2FtZXJhVmVjLCB0aGlzLnJlbmRlcmVyRGF0YS5jYW1lcmFRdWF0KTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuY3Jvc3ModGVtcENyb3NzMCwgdGVtcEF4aXMsIHRlbXBDYW1lcmFWZWMpO1xuICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5jcm9zcyh0ZW1wQ3Jvc3MxLCB0ZW1wQXhpcywgdGVtcENyb3NzMCk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLm5vcm1hbGl6ZSh0ZW1wQ3Jvc3MxLCB0ZW1wQ3Jvc3MxKTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLnF1YXQucm90YXRpb25Ubyh0ZW1wTG9ja1F1YXQsIHRlbXBYQXhpcywgdGVtcENyb3NzMSk7XG4gICAgICAgICAgICB1dGlsXzEubWF0NGZyb21Sb3RhdGlvbk9yaWdpbih0ZW1wTG9ja01hdCwgdGVtcExvY2tRdWF0LCB0ZW1wVHJhbnNmb3JtZWRQaXZvdFBvaW50KTtcbiAgICAgICAgICAgIGdsX21hdHJpeF8xLm1hdDQubXVsKG5vZGUubWF0cml4LCB0ZW1wTG9ja01hdCwgbm9kZS5tYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBub2RlLmNoaWxkczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLmZpbmRBbHBoYSA9IGZ1bmN0aW9uIChnZW9zZXRJZCkge1xuICAgICAgICB2YXIgZ2Vvc2V0QW5pbSA9IHRoaXMucmVuZGVyZXJEYXRhLmdlb3NldEFuaW1zW2dlb3NldElkXTtcbiAgICAgICAgaWYgKCFnZW9zZXRBbmltIHx8IGdlb3NldEFuaW0uQWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnZW9zZXRBbmltLkFscGhhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGdlb3NldEFuaW0uQWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVycFJlcyA9IHRoaXMuaW50ZXJwLm51bShnZW9zZXRBbmltLkFscGhhKTtcbiAgICAgICAgaWYgKGludGVycFJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVycFJlcztcbiAgICB9O1xuICAgIE1vZGVsUmVuZGVyZXIucHJvdG90eXBlLnNldExheWVyUHJvcHMgPSBmdW5jdGlvbiAobGF5ZXIsIHRleHR1cmVJRCkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMubW9kZWwuVGV4dHVyZXNbdGV4dHVyZUlEXTtcbiAgICAgICAgaWYgKGxheWVyLlNoYWRpbmcgJiBtb2RlbF8xLkxheWVyU2hhZGluZy5Ud29TaWRlZCkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyLkZpbHRlck1vZGUgPT09IG1vZGVsXzEuRmlsdGVyTW9kZS5UcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZGlzY2FyZEFscGhhTGV2ZWxVbmlmb3JtLCAwLjc1KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmRpc2NhcmRBbHBoYUxldmVsVW5pZm9ybSwgMC4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuTm9uZSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICAvLyBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5GaWx0ZXJNb2RlLkJsZW5kKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuQWRkaXRpdmUpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0NPTE9SLCBnbC5PTkUpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuQWRkQWxwaGEpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuTW9kdWxhdGUpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5aRVJPLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVyLkZpbHRlck1vZGUgPT09IG1vZGVsXzEuRmlsdGVyTW9kZS5Nb2R1bGF0ZTJ4KSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuRFNUX0NPTE9SLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLkltYWdlKSB7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyZXJEYXRhLnRleHR1cmVzW3RleHR1cmUuSW1hZ2VdKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnNhbXBsZXJVbmlmb3JtLCAwKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnJlcGxhY2VhYmxlVHlwZVVuaWZvcm0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuUmVwbGFjZWFibGVJZCA9PT0gMSB8fCB0ZXh0dXJlLlJlcGxhY2VhYmxlSWQgPT09IDIpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZUNvbG9yVW5pZm9ybSwgdGhpcy5yZW5kZXJlckRhdGEudGVhbUNvbG9yKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnJlcGxhY2VhYmxlVHlwZVVuaWZvcm0sIHRleHR1cmUuUmVwbGFjZWFibGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyLlNoYWRpbmcgJiBtb2RlbF8xLkxheWVyU2hhZGluZy5Ob0RlcHRoVGVzdCkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIuU2hhZGluZyAmIG1vZGVsXzEuTGF5ZXJTaGFkaW5nLk5vRGVwdGhTZXQpIHtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYXllci5UVmVydGV4QW5pbUlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLnJlbmRlcmVyRGF0YS5tb2RlbC5UZXh0dXJlQW5pbXNbbGF5ZXIuVFZlcnRleEFuaW1JZF07XG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25SZXMgPSB0aGlzLmludGVycC52ZWMzKHRyYW5zbGF0aW9uLCBhbmltLlRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgIHZhciByb3RhdGlvblJlcyA9IHRoaXMuaW50ZXJwLnF1YXQocm90YXRpb24sIGFuaW0uUm90YXRpb24pO1xuICAgICAgICAgICAgdmFyIHNjYWxpbmdSZXMgPSB0aGlzLmludGVycC52ZWMzKHNjYWxpbmcsIGFuaW0uU2NhbGluZyk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUodGV4Q29vcmRNYXQ0LCByb3RhdGlvblJlcyB8fCBkZWZhdWx0Um90YXRpb24sIHRyYW5zbGF0aW9uUmVzIHx8IGRlZmF1bHRUcmFuc2xhdGlvbiwgc2NhbGluZ1JlcyB8fCBkZWZhdWx0U2NhbGluZyk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS5tYXQzLnNldCh0ZXhDb29yZE1hdDMsIHRleENvb3JkTWF0NFswXSwgdGV4Q29vcmRNYXQ0WzFdLCAwLCB0ZXhDb29yZE1hdDRbNF0sIHRleENvb3JkTWF0NFs1XSwgMCwgdGV4Q29vcmRNYXQ0WzEyXSwgdGV4Q29vcmRNYXQ0WzEzXSwgMCk7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudFZlcnRleEFuaW1Vbmlmb3JtLCBmYWxzZSwgdGV4Q29vcmRNYXQzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy50VmVydGV4QW5pbVVuaWZvcm0sIGZhbHNlLCBpZGVudGlmeU1hdDMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW9kZWxSZW5kZXJlcjtcbn0oKSk7XG5leHBvcnRzLk1vZGVsUmVuZGVyZXIgPSBNb2RlbFJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWxSZW5kZXJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uL21vZGVsXCIpO1xudmFyIGdsX21hdHJpeF8xID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKTtcbnZhciBtb2RlbEludGVycF8xID0gcmVxdWlyZShcIi4vbW9kZWxJbnRlcnBcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpbnRlcnBfMSA9IHJlcXVpcmUoXCIuL2ludGVycFwiKTtcbnZhciBnbDtcbnZhciBzaGFkZXJQcm9ncmFtO1xudmFyIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMgPSB7fTtcbnZhciBwYXJ0aWNsZVN0b3JhZ2UgPSBbXTtcbnZhciByb3RhdGVDZW50ZXIgPSBnbF9tYXRyaXhfMS52ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCk7XG52YXIgZmlyc3RDb2xvciA9IGdsX21hdHJpeF8xLnZlYzQuY3JlYXRlKCk7XG52YXIgc2Vjb25kQ29sb3IgPSBnbF9tYXRyaXhfMS52ZWM0LmNyZWF0ZSgpO1xudmFyIGNvbG9yID0gZ2xfbWF0cml4XzEudmVjNC5jcmVhdGUoKTtcbnZhciB0YWlsUG9zID0gZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKTtcbnZhciB0YWlsQ3Jvc3MgPSBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpO1xudmFyIHZlcnRleFNoYWRlciA9IFwiXFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbiAgICB1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xcbiAgICB1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XFxuXFxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgdmVjNCBwb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1UE1hdHJpeCAqIHVNVk1hdHJpeCAqIHBvc2l0aW9uO1xcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgIH1cXG5cIjtcbnZhciBmcmFnbWVudFNoYWRlciA9IFwiXFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuICAgIHVuaWZvcm0gdmVjMyB1UmVwbGFjZWFibGVDb2xvcjtcXG4gICAgdW5pZm9ybSBmbG9hdCB1UmVwbGFjZWFibGVUeXBlO1xcbiAgICB1bmlmb3JtIGZsb2F0IHVEaXNjYXJkQWxwaGFMZXZlbDtcXG5cXG4gICAgZmxvYXQgaHlwb3QgKHZlYzIgeikge1xcbiAgICAgICAgZmxvYXQgdDtcXG4gICAgICAgIGZsb2F0IHggPSBhYnMoei54KTtcXG4gICAgICAgIGZsb2F0IHkgPSBhYnMoei55KTtcXG4gICAgICAgIHQgPSBtaW4oeCwgeSk7XFxuICAgICAgICB4ID0gbWF4KHgsIHkpO1xcbiAgICAgICAgdCA9IHQgLyB4O1xcbiAgICAgICAgcmV0dXJuICh6LnggPT0gMC4wICYmIHoueSA9PSAwLjApID8gMC4wIDogeCAqIHNxcnQoMS4wICsgdCAqIHQpO1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IHZlYzIodlRleHR1cmVDb29yZC5zLCB2VGV4dHVyZUNvb3JkLnQpO1xcbiAgICAgICAgaWYgKHVSZXBsYWNlYWJsZVR5cGUgPT0gMC4pIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3Jkcyk7XFxuICAgICAgICB9IGVsc2UgaWYgKHVSZXBsYWNlYWJsZVR5cGUgPT0gMS4pIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVSZXBsYWNlYWJsZUNvbG9yLCAxLjApO1xcbiAgICAgICAgfSBlbHNlIGlmICh1UmVwbGFjZWFibGVUeXBlID09IDIuKSB7XFxuICAgICAgICAgICAgZmxvYXQgZGlzdCA9IGh5cG90KGNvb3JkcyAtIHZlYzIoMC41LCAwLjUpKSAqIDIuO1xcbiAgICAgICAgICAgIGZsb2F0IHRydW5jYXRlRGlzdCA9IGNsYW1wKDEuIC0gZGlzdCAqIDEuNCwgMC4sIDEuKTtcXG4gICAgICAgICAgICBmbG9hdCBhbHBoYSA9IHNpbih0cnVuY2F0ZURpc3QpO1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodVJlcGxhY2VhYmxlQ29sb3IgKiBhbHBoYSwgMS4wKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsX0ZyYWdDb2xvciAqPSB2Q29sb3I7XFxuICAgICAgICBcXG4gICAgICAgIGlmIChnbF9GcmFnQ29sb3JbM10gPCB1RGlzY2FyZEFscGhhTGV2ZWwpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXCI7XG52YXIgRElTQ0FSRF9BTFBIQV9LRVlfTEVWRUwgPSAwLjgzO1xudmFyIERJU0NBUkRfTU9EVUxBVEVfTEVWRUwgPSAwLjAxO1xudmFyIFBhcnRpY2xlc0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnRpY2xlc0NvbnRyb2xsZXIoaW50ZXJwLCByZW5kZXJlckRhdGEpIHtcbiAgICAgICAgdGhpcy5pbnRlcnAgPSBpbnRlcnA7XG4gICAgICAgIHRoaXMucmVuZGVyZXJEYXRhID0gcmVuZGVyZXJEYXRhO1xuICAgICAgICB0aGlzLmVtaXR0ZXJzID0gW107XG4gICAgICAgIGlmIChyZW5kZXJlckRhdGEubW9kZWwuUGFydGljbGVFbWl0dGVyczIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlQmFzZVZlY3RvcnMgPSBbXG4gICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKSxcbiAgICAgICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpLFxuICAgICAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuY3JlYXRlKCksXG4gICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5jcmVhdGUoKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSByZW5kZXJlckRhdGEubW9kZWwuUGFydGljbGVFbWl0dGVyczI7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpY2xlRW1pdHRlciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgZW1pdHRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW1pc3Npb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHNxdWlydEZyYW1lOiAwLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogcGFydGljbGVFbWl0dGVyLFxuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUNhcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJ0aWNsZUVtaXR0ZXIuRnJhbWVGbGFncyxcbiAgICAgICAgICAgICAgICAgICAgdGFpbFZlcnRpY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0YWlsVmVydGV4QnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkVmVydGljZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRWZXJ0ZXhCdWZmZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRhaWxUZXhDb29yZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRhaWxUZXhDb29yZEJ1ZmZlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFRleENvb3JkczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFRleENvb3JkQnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpbmRleEJ1ZmZlcjogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZW1pdHRlci5iYXNlQ2FwYWNpdHkgPSBNYXRoLmNlaWwobW9kZWxJbnRlcnBfMS5Nb2RlbEludGVycC5tYXhBbmltVmVjdG9yVmFsKGVtaXR0ZXIucHJvcHMuRW1pc3Npb25SYXRlKSAqIGVtaXR0ZXIucHJvcHMuTGlmZVNwYW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlcnMucHVzaChlbWl0dGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJ0aWNsZXNDb250cm9sbGVyLmluaXRHTCA9IGZ1bmN0aW9uIChnbENvbnRleHQpIHtcbiAgICAgICAgZ2wgPSBnbENvbnRleHQ7XG4gICAgICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIuaW5pdFNoYWRlcnMoKTtcbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIuaW5pdFNoYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXggPSB1dGlsXzEuZ2V0U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXIsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSB1dGlsXzEuZ2V0U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlciwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleCk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnbWVudCk7XG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBhbGVydCgnQ291bGQgbm90IGluaXRpYWxpc2Ugc2hhZGVycycpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAnYVRleHR1cmVDb29yZCcpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmNvbG9yQXR0cmlidXRlID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sICdhQ29sb3InKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5wTWF0cml4VW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndVBNYXRyaXgnKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5tdk1hdHJpeFVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ3VNVk1hdHJpeCcpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnNhbXBsZXJVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1U2FtcGxlcicpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnJlcGxhY2VhYmxlQ29sb3JVbmlmb3JtID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndVJlcGxhY2VhYmxlQ29sb3InKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZVR5cGVVbmlmb3JtID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndVJlcGxhY2VhYmxlVHlwZScpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmRpc2NhcmRBbHBoYUxldmVsVW5pZm9ybSA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ3VEaXNjYXJkQWxwaGFMZXZlbCcpO1xuICAgIH07XG4gICAgUGFydGljbGVzQ29udHJvbGxlci51cGRhdGVQYXJ0aWNsZSA9IGZ1bmN0aW9uIChwYXJ0aWNsZSwgZGVsdGEpIHtcbiAgICAgICAgZGVsdGEgLz0gMTAwMDtcbiAgICAgICAgcGFydGljbGUubGlmZVNwYW4gLT0gZGVsdGE7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5saWZlU3BhbiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFydGljbGUuc3BlZWRbMl0gLT0gcGFydGljbGUuZ3Jhdml0eSAqIGRlbHRhO1xuICAgICAgICBwYXJ0aWNsZS5wb3NbMF0gKz0gcGFydGljbGUuc3BlZWRbMF0gKiBkZWx0YTtcbiAgICAgICAgcGFydGljbGUucG9zWzFdICs9IHBhcnRpY2xlLnNwZWVkWzFdICogZGVsdGE7XG4gICAgICAgIHBhcnRpY2xlLnBvc1syXSArPSBwYXJ0aWNsZS5zcGVlZFsyXSAqIGRlbHRhO1xuICAgIH07XG4gICAgUGFydGljbGVzQ29udHJvbGxlci5yZXNpemVFbWl0dGVyQnVmZmVycyA9IGZ1bmN0aW9uIChlbWl0dGVyLCBzaXplKSB7XG4gICAgICAgIGlmIChzaXplIDw9IGVtaXR0ZXIuY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgZW1pdHRlci5iYXNlQ2FwYWNpdHkpO1xuICAgICAgICB2YXIgdGFpbFZlcnRpY2VzO1xuICAgICAgICB2YXIgaGVhZFZlcnRpY2VzO1xuICAgICAgICB2YXIgdGFpbFRleENvb3JkcztcbiAgICAgICAgdmFyIGhlYWRUZXhDb29yZHM7XG4gICAgICAgIGlmIChlbWl0dGVyLnR5cGUgJiBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncy5UYWlsKSB7XG4gICAgICAgICAgICB0YWlsVmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0ICogMyk7IC8vIDQgdmVydGljZXMgKiB4eXpcbiAgICAgICAgICAgIHRhaWxUZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0ICogMik7IC8vIDQgdmVydGljZXMgKiB4eVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0dGVyLnR5cGUgJiBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncy5IZWFkKSB7XG4gICAgICAgICAgICBoZWFkVmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0ICogMyk7IC8vIDQgdmVydGljZXMgKiB4eXpcbiAgICAgICAgICAgIGhlYWRUZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0ICogMik7IC8vIDQgdmVydGljZXMgKiB4eVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0ICogNCk7IC8vIDQgdmVydGljZXMgKiByZ2JhXG4gICAgICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHNpemUgKiA2KTsgLy8gNCB2ZXJ0aWNlcyAqIDIgdHJpYW5nbGVzXG4gICAgICAgIGlmIChlbWl0dGVyLmNhcGFjaXR5KSB7XG4gICAgICAgICAgICBpbmRpY2VzLnNldChlbWl0dGVyLmluZGljZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBlbWl0dGVyLmNhcGFjaXR5OyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBpbmRpY2VzW2kgKiA2XSA9IGkgKiA0O1xuICAgICAgICAgICAgaW5kaWNlc1tpICogNiArIDFdID0gaSAqIDQgKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tpICogNiArIDJdID0gaSAqIDQgKyAyO1xuICAgICAgICAgICAgaW5kaWNlc1tpICogNiArIDNdID0gaSAqIDQgKyAyO1xuICAgICAgICAgICAgaW5kaWNlc1tpICogNiArIDRdID0gaSAqIDQgKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tpICogNiArIDVdID0gaSAqIDQgKyAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWlsVmVydGljZXMpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzID0gdGFpbFZlcnRpY2VzO1xuICAgICAgICAgICAgZW1pdHRlci50YWlsVGV4Q29vcmRzID0gdGFpbFRleENvb3JkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZFZlcnRpY2VzKSB7XG4gICAgICAgICAgICBlbWl0dGVyLmhlYWRWZXJ0aWNlcyA9IGhlYWRWZXJ0aWNlcztcbiAgICAgICAgICAgIGVtaXR0ZXIuaGVhZFRleENvb3JkcyA9IGhlYWRUZXhDb29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIGVtaXR0ZXIuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgICAgIGVtaXR0ZXIuY2FwYWNpdHkgPSBzaXplO1xuICAgICAgICBpZiAoIWVtaXR0ZXIuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChlbWl0dGVyLnR5cGUgJiBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncy5UYWlsKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci50YWlsVmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgZW1pdHRlci50YWlsVGV4Q29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbWl0dGVyLnR5cGUgJiBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncy5IZWFkKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVGV4Q29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXR0ZXIuY29sb3JCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGVtaXR0ZXIuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFydGljbGVzQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVtaXR0ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVtaXR0ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVtaXR0ZXIoZW1pdHRlciwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJ0aWNsZXNDb250cm9sbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobXZNYXRyaXgsIHBNYXRyaXgpIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5wTWF0cml4VW5pZm9ybSwgZmFsc2UsIHBNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMubXZNYXRyaXhVbmlmb3JtLCBmYWxzZSwgbXZNYXRyaXgpO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUpO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmNvbG9yQXR0cmlidXRlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZW1pdHRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW1pdHRlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghZW1pdHRlci5wYXJ0aWNsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldExheWVyUHJvcHMoZW1pdHRlcik7XG4gICAgICAgICAgICB0aGlzLnNldEdlbmVyYWxCdWZmZXJzKGVtaXR0ZXIpO1xuICAgICAgICAgICAgaWYgKGVtaXR0ZXIudHlwZSAmIG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLlRhaWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVtaXR0ZXJUeXBlKGVtaXR0ZXIsIG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLlRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtaXR0ZXIudHlwZSAmIG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLkhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVtaXR0ZXJUeXBlKGVtaXR0ZXIsIG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLkhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlKTtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudGV4dHVyZUNvb3JkQXR0cmlidXRlKTtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuY29sb3JBdHRyaWJ1dGUpO1xuICAgIH07XG4gICAgUGFydGljbGVzQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlRW1pdHRlciA9IGZ1bmN0aW9uIChlbWl0dGVyLCBkZWx0YSkge1xuICAgICAgICB2YXIgdmlzaWJpbGl0eSA9IHRoaXMuaW50ZXJwLmFuaW1WZWN0b3JWYWwoZW1pdHRlci5wcm9wcy5WaXNpYmlsaXR5LCAxKTtcbiAgICAgICAgaWYgKHZpc2liaWxpdHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZW1pdHRlci5wcm9wcy5TcXVpcnQgJiYgdHlwZW9mIGVtaXR0ZXIucHJvcHMuRW1pc3Npb25SYXRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnAgPSB0aGlzLmludGVycC5maW5kS2V5ZnJhbWVzKGVtaXR0ZXIucHJvcHMuRW1pc3Npb25SYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJwICYmIGludGVycC5sZWZ0ICYmIGludGVycC5sZWZ0LkZyYW1lICE9PSBlbWl0dGVyLnNxdWlydEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuc3F1aXJ0RnJhbWUgPSBpbnRlcnAubGVmdC5GcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVycC5sZWZ0LlZlY3RvclswXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pc3Npb24gKz0gaW50ZXJwLmxlZnQuVmVjdG9yWzBdICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlbWlzc2lvblJhdGUgPSB0aGlzLmludGVycC5hbmltVmVjdG9yVmFsKGVtaXR0ZXIucHJvcHMuRW1pc3Npb25SYXRlLCAwKTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXNzaW9uICs9IGVtaXNzaW9uUmF0ZSAqIGRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGVtaXR0ZXIuZW1pc3Npb24gPj0gMTAwMCkge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pc3Npb24gLT0gMTAwMDtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnBhcnRpY2xlcy5wdXNoKHRoaXMuY3JlYXRlUGFydGljbGUoZW1pdHRlciwgdGhpcy5yZW5kZXJlckRhdGEubm9kZXNbZW1pdHRlci5wcm9wcy5PYmplY3RJZF0ubWF0cml4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtaXR0ZXIucGFydGljbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRQYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBlbWl0dGVyLnBhcnRpY2xlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydGljbGUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgUGFydGljbGVzQ29udHJvbGxlci51cGRhdGVQYXJ0aWNsZShwYXJ0aWNsZSwgZGVsdGEpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5saWZlU3BhbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlU3RvcmFnZS5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0dGVyLnBhcnRpY2xlcyA9IHVwZGF0ZWRQYXJ0aWNsZXM7XG4gICAgICAgICAgICBpZiAoZW1pdHRlci50eXBlICYgbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3MuSGVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChlbWl0dGVyLnByb3BzLkZsYWdzICYgbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRmxhZ3MuWFlRdWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuc2V0KHRoaXMucGFydGljbGVCYXNlVmVjdG9yc1swXSwgLTEsIDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnNldCh0aGlzLnBhcnRpY2xlQmFzZVZlY3RvcnNbMV0sIC0xLCAtMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuc2V0KHRoaXMucGFydGljbGVCYXNlVmVjdG9yc1syXSwgMSwgMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuc2V0KHRoaXMucGFydGljbGVCYXNlVmVjdG9yc1szXSwgMSwgLTEsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5zZXQodGhpcy5wYXJ0aWNsZUJhc2VWZWN0b3JzWzBdLCAwLCAtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGdsX21hdHJpeF8xLnZlYzMuc2V0KHRoaXMucGFydGljbGVCYXNlVmVjdG9yc1sxXSwgMCwgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5zZXQodGhpcy5wYXJ0aWNsZUJhc2VWZWN0b3JzWzJdLCAwLCAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5zZXQodGhpcy5wYXJ0aWNsZUJhc2VWZWN0b3JzWzNdLCAwLCAxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnRyYW5zZm9ybVF1YXQodGhpcy5wYXJ0aWNsZUJhc2VWZWN0b3JzW2ldLCB0aGlzLnBhcnRpY2xlQmFzZVZlY3RvcnNbaV0sIHRoaXMucmVuZGVyZXJEYXRhLmNhbWVyYVF1YXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUGFydGljbGVzQ29udHJvbGxlci5yZXNpemVFbWl0dGVyQnVmZmVycyhlbWl0dGVyLCBlbWl0dGVyLnBhcnRpY2xlcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbWl0dGVyLnBhcnRpY2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVCdWZmZXJzKGVtaXR0ZXIucGFydGljbGVzW2ldLCBpLCBlbWl0dGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFydGljbGVzQ29udHJvbGxlci5wcm90b3R5cGUuY3JlYXRlUGFydGljbGUgPSBmdW5jdGlvbiAoZW1pdHRlciwgZW1pdHRlck1hdHJpeCkge1xuICAgICAgICB2YXIgcGFydGljbGU7XG4gICAgICAgIGlmIChwYXJ0aWNsZVN0b3JhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZSA9IHBhcnRpY2xlU3RvcmFnZS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRpY2xlID0ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgcG9zOiBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgIHNwZWVkOiBnbF9tYXRyaXhfMS52ZWMzLmNyZWF0ZSgpLFxuICAgICAgICAgICAgICAgIGdyYXZpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgbGlmZVNwYW46IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5pbnRlcnAuYW5pbVZlY3RvclZhbChlbWl0dGVyLnByb3BzLldpZHRoLCAwKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJwLmFuaW1WZWN0b3JWYWwoZW1pdHRlci5wcm9wcy5MZW5ndGgsIDApO1xuICAgICAgICB2YXIgc3BlZWRTY2FsZSA9IHRoaXMuaW50ZXJwLmFuaW1WZWN0b3JWYWwoZW1pdHRlci5wcm9wcy5TcGVlZCwgMCk7XG4gICAgICAgIHZhciB2YXJpYXRpb24gPSB0aGlzLmludGVycC5hbmltVmVjdG9yVmFsKGVtaXR0ZXIucHJvcHMuVmFyaWF0aW9uLCAwKTtcbiAgICAgICAgdmFyIGxhdGl0dWRlID0gdXRpbF8xLmRlZ1RvUmFkKHRoaXMuaW50ZXJwLmFuaW1WZWN0b3JWYWwoZW1pdHRlci5wcm9wcy5MYXRpdHVkZSwgMCkpO1xuICAgICAgICBwYXJ0aWNsZS5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgcGFydGljbGUucG9zWzBdID0gZW1pdHRlci5wcm9wcy5QaXZvdFBvaW50WzBdICsgdXRpbF8xLnJhbmQoLXdpZHRoLCB3aWR0aCk7XG4gICAgICAgIHBhcnRpY2xlLnBvc1sxXSA9IGVtaXR0ZXIucHJvcHMuUGl2b3RQb2ludFsxXSArIHV0aWxfMS5yYW5kKC1sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgIHBhcnRpY2xlLnBvc1syXSA9IGVtaXR0ZXIucHJvcHMuUGl2b3RQb2ludFsyXTtcbiAgICAgICAgZ2xfbWF0cml4XzEudmVjMy50cmFuc2Zvcm1NYXQ0KHBhcnRpY2xlLnBvcywgcGFydGljbGUucG9zLCBlbWl0dGVyTWF0cml4KTtcbiAgICAgICAgaWYgKHZhcmlhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHNwZWVkU2NhbGUgKj0gMSArIHV0aWxfMS5yYW5kKC12YXJpYXRpb24sIHZhcmlhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5zZXQocGFydGljbGUuc3BlZWQsIDAsIDAsIHNwZWVkU2NhbGUpO1xuICAgICAgICBwYXJ0aWNsZS5hbmdsZSA9IHV0aWxfMS5yYW5kKDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgZ2xfbWF0cml4XzEudmVjMy5yb3RhdGVZKHBhcnRpY2xlLnNwZWVkLCBwYXJ0aWNsZS5zcGVlZCwgcm90YXRlQ2VudGVyLCB1dGlsXzEucmFuZCgwLCBsYXRpdHVkZSkpO1xuICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnJvdGF0ZVoocGFydGljbGUuc3BlZWQsIHBhcnRpY2xlLnNwZWVkLCByb3RhdGVDZW50ZXIsIHBhcnRpY2xlLmFuZ2xlKTtcbiAgICAgICAgaWYgKGVtaXR0ZXIucHJvcHMuRmxhZ3MgJiBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGbGFncy5MaW5lRW1pdHRlcikge1xuICAgICAgICAgICAgcGFydGljbGUuc3BlZWRbMF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGdsX21hdHJpeF8xLnZlYzMudHJhbnNmb3JtTWF0NChwYXJ0aWNsZS5zcGVlZCwgcGFydGljbGUuc3BlZWQsIGVtaXR0ZXJNYXRyaXgpO1xuICAgICAgICAvLyBtaW51cyB0cmFuc2xhdGlvbiBvZiBlbWl0dGVyTWF0cml4XG4gICAgICAgIHBhcnRpY2xlLnNwZWVkWzBdIC09IGVtaXR0ZXJNYXRyaXhbMTJdO1xuICAgICAgICBwYXJ0aWNsZS5zcGVlZFsxXSAtPSBlbWl0dGVyTWF0cml4WzEzXTtcbiAgICAgICAgcGFydGljbGUuc3BlZWRbMl0gLT0gZW1pdHRlck1hdHJpeFsxNF07XG4gICAgICAgIHBhcnRpY2xlLmdyYXZpdHkgPSB0aGlzLmludGVycC5hbmltVmVjdG9yVmFsKGVtaXR0ZXIucHJvcHMuR3Jhdml0eSwgMCk7XG4gICAgICAgIHBhcnRpY2xlLmxpZmVTcGFuID0gZW1pdHRlci5wcm9wcy5MaWZlU3BhbjtcbiAgICAgICAgcmV0dXJuIHBhcnRpY2xlO1xuICAgIH07XG4gICAgUGFydGljbGVzQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlUGFydGljbGVCdWZmZXJzID0gZnVuY3Rpb24gKHBhcnRpY2xlLCBpbmRleCwgZW1pdHRlcikge1xuICAgICAgICB2YXIgZ2xvYmFsVCA9IDEgLSBwYXJ0aWNsZS5saWZlU3BhbiAvIGVtaXR0ZXIucHJvcHMuTGlmZVNwYW47XG4gICAgICAgIHZhciBmaXJzdEhhbGYgPSBnbG9iYWxUIDwgZW1pdHRlci5wcm9wcy5UaW1lO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaWYgKGZpcnN0SGFsZikge1xuICAgICAgICAgICAgdCA9IGdsb2JhbFQgLyBlbWl0dGVyLnByb3BzLlRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ID0gKGdsb2JhbFQgLSBlbWl0dGVyLnByb3BzLlRpbWUpIC8gKDEgLSBlbWl0dGVyLnByb3BzLlRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVWZXJ0aWNlcyhwYXJ0aWNsZSwgaW5kZXgsIGVtaXR0ZXIsIGZpcnN0SGFsZiwgdCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVUZXhDb29yZHMoaW5kZXgsIGVtaXR0ZXIsIGZpcnN0SGFsZiwgdCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVDb2xvcihpbmRleCwgZW1pdHRlciwgZmlyc3RIYWxmLCB0KTtcbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVBhcnRpY2xlVmVydGljZXMgPSBmdW5jdGlvbiAocGFydGljbGUsIGluZGV4LCBlbWl0dGVyLCBmaXJzdEhhbGYsIHQpIHtcbiAgICAgICAgdmFyIGZpcnN0U2NhbGU7XG4gICAgICAgIHZhciBzZWNvbmRTY2FsZTtcbiAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICBpZiAoZmlyc3RIYWxmKSB7XG4gICAgICAgICAgICBmaXJzdFNjYWxlID0gZW1pdHRlci5wcm9wcy5QYXJ0aWNsZVNjYWxpbmdbMF07XG4gICAgICAgICAgICBzZWNvbmRTY2FsZSA9IGVtaXR0ZXIucHJvcHMuUGFydGljbGVTY2FsaW5nWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3RTY2FsZSA9IGVtaXR0ZXIucHJvcHMuUGFydGljbGVTY2FsaW5nWzFdO1xuICAgICAgICAgICAgc2Vjb25kU2NhbGUgPSBlbWl0dGVyLnByb3BzLlBhcnRpY2xlU2NhbGluZ1syXTtcbiAgICAgICAgfVxuICAgICAgICBzY2FsZSA9IGludGVycF8xLmxlcnAoZmlyc3RTY2FsZSwgc2Vjb25kU2NhbGUsIHQpO1xuICAgICAgICBpZiAoZW1pdHRlci50eXBlICYgbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3MuSGVhZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmhlYWRWZXJ0aWNlc1tpbmRleCAqIDEyICsgaSAqIDNdID0gdGhpcy5wYXJ0aWNsZUJhc2VWZWN0b3JzW2ldWzBdICogc2NhbGU7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVmVydGljZXNbaW5kZXggKiAxMiArIGkgKiAzICsgMV0gPSB0aGlzLnBhcnRpY2xlQmFzZVZlY3RvcnNbaV1bMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmhlYWRWZXJ0aWNlc1tpbmRleCAqIDEyICsgaSAqIDMgKyAyXSA9IHRoaXMucGFydGljbGVCYXNlVmVjdG9yc1tpXVsyXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIGlmIChlbWl0dGVyLnByb3BzLkZsYWdzICYgbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRmxhZ3MuWFlRdWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZW1pdHRlci5oZWFkVmVydGljZXNbaW5kZXggKiAxMiArIGkgKiAzXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlbWl0dGVyLmhlYWRWZXJ0aWNlc1tpbmRleCAqIDEyICsgaSAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVmVydGljZXNbaW5kZXggKiAxMiArIGkgKiAzXSA9IHggKiBNYXRoLmNvcyhwYXJ0aWNsZS5hbmdsZSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgeSAqIE1hdGguc2luKHBhcnRpY2xlLmFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVmVydGljZXNbaW5kZXggKiAxMiArIGkgKiAzICsgMV0gPSB4ICogTWF0aC5zaW4ocGFydGljbGUuYW5nbGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKiBNYXRoLmNvcyhwYXJ0aWNsZS5hbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0dGVyLnR5cGUgJiBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGcmFtZXNGbGFncy5UYWlsKSB7XG4gICAgICAgICAgICB0YWlsUG9zWzBdID0gLXBhcnRpY2xlLnNwZWVkWzBdICogZW1pdHRlci5wcm9wcy5UYWlsTGVuZ3RoO1xuICAgICAgICAgICAgdGFpbFBvc1sxXSA9IC1wYXJ0aWNsZS5zcGVlZFsxXSAqIGVtaXR0ZXIucHJvcHMuVGFpbExlbmd0aDtcbiAgICAgICAgICAgIHRhaWxQb3NbMl0gPSAtcGFydGljbGUuc3BlZWRbMl0gKiBlbWl0dGVyLnByb3BzLlRhaWxMZW5ndGg7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLmNyb3NzKHRhaWxDcm9zcywgcGFydGljbGUuc3BlZWQsIHRoaXMucmVuZGVyZXJEYXRhLmNhbWVyYVBvcyk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLm5vcm1hbGl6ZSh0YWlsQ3Jvc3MsIHRhaWxDcm9zcyk7XG4gICAgICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnNjYWxlKHRhaWxDcm9zcywgdGFpbENyb3NzLCBzY2FsZSk7XG4gICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyXSA9IHRhaWxDcm9zc1swXTtcbiAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzW2luZGV4ICogMTIgKyAxXSA9IHRhaWxDcm9zc1sxXTtcbiAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzW2luZGV4ICogMTIgKyAyXSA9IHRhaWxDcm9zc1syXTtcbiAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzW2luZGV4ICogMTIgKyAzXSA9IC10YWlsQ3Jvc3NbMF07XG4gICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyICsgMyArIDFdID0gLXRhaWxDcm9zc1sxXTtcbiAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzW2luZGV4ICogMTIgKyAzICsgMl0gPSAtdGFpbENyb3NzWzJdO1xuICAgICAgICAgICAgZW1pdHRlci50YWlsVmVydGljZXNbaW5kZXggKiAxMiArIDIgKiAzXSA9IHRhaWxDcm9zc1swXSArIHRhaWxQb3NbMF07XG4gICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyICsgMiAqIDMgKyAxXSA9IHRhaWxDcm9zc1sxXSArIHRhaWxQb3NbMV07XG4gICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyICsgMiAqIDMgKyAyXSA9IHRhaWxDcm9zc1syXSArIHRhaWxQb3NbMl07XG4gICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyICsgMyAqIDNdID0gLXRhaWxDcm9zc1swXSArIHRhaWxQb3NbMF07XG4gICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyICsgMyAqIDMgKyAxXSA9IC10YWlsQ3Jvc3NbMV0gKyB0YWlsUG9zWzFdO1xuICAgICAgICAgICAgZW1pdHRlci50YWlsVmVydGljZXNbaW5kZXggKiAxMiArIDMgKiAzICsgMl0gPSAtdGFpbENyb3NzWzJdICsgdGFpbFBvc1syXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKGVtaXR0ZXIuaGVhZFZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVmVydGljZXNbaW5kZXggKiAxMiArIGkgKiAzXSArPSBwYXJ0aWNsZS5wb3NbMF07XG4gICAgICAgICAgICAgICAgZW1pdHRlci5oZWFkVmVydGljZXNbaW5kZXggKiAxMiArIGkgKiAzICsgMV0gKz0gcGFydGljbGUucG9zWzFdO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuaGVhZFZlcnRpY2VzW2luZGV4ICogMTIgKyBpICogMyArIDJdICs9IHBhcnRpY2xlLnBvc1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbWl0dGVyLnRhaWxWZXJ0aWNlcykge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzW2luZGV4ICogMTIgKyBpICogM10gKz0gcGFydGljbGUucG9zWzBdO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIudGFpbFZlcnRpY2VzW2luZGV4ICogMTIgKyBpICogMyArIDFdICs9IHBhcnRpY2xlLnBvc1sxXTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnRhaWxWZXJ0aWNlc1tpbmRleCAqIDEyICsgaSAqIDMgKyAyXSArPSBwYXJ0aWNsZS5wb3NbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVBhcnRpY2xlVGV4Q29vcmRzID0gZnVuY3Rpb24gKGluZGV4LCBlbWl0dGVyLCBmaXJzdEhhbGYsIHQpIHtcbiAgICAgICAgaWYgKGVtaXR0ZXIudHlwZSAmIG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLkhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVUZXhDb29yZHNCeVR5cGUoaW5kZXgsIGVtaXR0ZXIsIGZpcnN0SGFsZiwgdCwgbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3MuSGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtaXR0ZXIudHlwZSAmIG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLlRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVUZXhDb29yZHNCeVR5cGUoaW5kZXgsIGVtaXR0ZXIsIGZpcnN0SGFsZiwgdCwgbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRnJhbWVzRmxhZ3MuVGFpbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVBhcnRpY2xlVGV4Q29vcmRzQnlUeXBlID0gZnVuY3Rpb24gKGluZGV4LCBlbWl0dGVyLCBmaXJzdEhhbGYsIHQsIHR5cGUpIHtcbiAgICAgICAgdmFyIHV2QW5pbTtcbiAgICAgICAgdmFyIHRleENvb3JkcztcbiAgICAgICAgaWYgKHR5cGUgPT09IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLlRhaWwpIHtcbiAgICAgICAgICAgIHV2QW5pbSA9IGZpcnN0SGFsZiA/IGVtaXR0ZXIucHJvcHMuVGFpbFVWQW5pbSA6IGVtaXR0ZXIucHJvcHMuVGFpbERlY2F5VVZBbmltO1xuICAgICAgICAgICAgdGV4Q29vcmRzID0gZW1pdHRlci50YWlsVGV4Q29vcmRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXZBbmltID0gZmlyc3RIYWxmID8gZW1pdHRlci5wcm9wcy5MaWZlU3BhblVWQW5pbSA6IGVtaXR0ZXIucHJvcHMuRGVjYXlVVkFuaW07XG4gICAgICAgICAgICB0ZXhDb29yZHMgPSBlbWl0dGVyLmhlYWRUZXhDb29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0RnJhbWUgPSB1dkFuaW1bMF07XG4gICAgICAgIHZhciBzZWNvbmRGcmFtZSA9IHV2QW5pbVsxXTtcbiAgICAgICAgdmFyIGZyYW1lID0gTWF0aC5yb3VuZChpbnRlcnBfMS5sZXJwKGZpcnN0RnJhbWUsIHNlY29uZEZyYW1lLCB0KSk7XG4gICAgICAgIHZhciB0ZXhDb29yZFggPSBmcmFtZSAlIGVtaXR0ZXIucHJvcHMuQ29sdW1ucztcbiAgICAgICAgdmFyIHRleENvb3JkWSA9IE1hdGguZmxvb3IoZnJhbWUgLyBlbWl0dGVyLnByb3BzLlJvd3MpO1xuICAgICAgICB2YXIgY2VsbFdpZHRoID0gMSAvIGVtaXR0ZXIucHJvcHMuQ29sdW1ucztcbiAgICAgICAgdmFyIGNlbGxIZWlnaHQgPSAxIC8gZW1pdHRlci5wcm9wcy5Sb3dzO1xuICAgICAgICB0ZXhDb29yZHNbaW5kZXggKiA4XSA9IHRleENvb3JkWCAqIGNlbGxXaWR0aDtcbiAgICAgICAgdGV4Q29vcmRzW2luZGV4ICogOCArIDFdID0gdGV4Q29vcmRZICogY2VsbEhlaWdodDtcbiAgICAgICAgdGV4Q29vcmRzW2luZGV4ICogOCArIDJdID0gdGV4Q29vcmRYICogY2VsbFdpZHRoO1xuICAgICAgICB0ZXhDb29yZHNbaW5kZXggKiA4ICsgM10gPSAoMSArIHRleENvb3JkWSkgKiBjZWxsSGVpZ2h0O1xuICAgICAgICB0ZXhDb29yZHNbaW5kZXggKiA4ICsgNF0gPSAoMSArIHRleENvb3JkWCkgKiBjZWxsV2lkdGg7XG4gICAgICAgIHRleENvb3Jkc1tpbmRleCAqIDggKyA1XSA9IHRleENvb3JkWSAqIGNlbGxIZWlnaHQ7XG4gICAgICAgIHRleENvb3Jkc1tpbmRleCAqIDggKyA2XSA9ICgxICsgdGV4Q29vcmRYKSAqIGNlbGxXaWR0aDtcbiAgICAgICAgdGV4Q29vcmRzW2luZGV4ICogOCArIDddID0gKDEgKyB0ZXhDb29yZFkpICogY2VsbEhlaWdodDtcbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVBhcnRpY2xlQ29sb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGVtaXR0ZXIsIGZpcnN0SGFsZiwgdCkge1xuICAgICAgICBpZiAoZmlyc3RIYWxmKSB7XG4gICAgICAgICAgICBmaXJzdENvbG9yWzBdID0gZW1pdHRlci5wcm9wcy5TZWdtZW50Q29sb3JbMF1bMF07XG4gICAgICAgICAgICBmaXJzdENvbG9yWzFdID0gZW1pdHRlci5wcm9wcy5TZWdtZW50Q29sb3JbMF1bMV07XG4gICAgICAgICAgICBmaXJzdENvbG9yWzJdID0gZW1pdHRlci5wcm9wcy5TZWdtZW50Q29sb3JbMF1bMl07XG4gICAgICAgICAgICBmaXJzdENvbG9yWzNdID0gZW1pdHRlci5wcm9wcy5BbHBoYVswXSAvIDI1NTtcbiAgICAgICAgICAgIHNlY29uZENvbG9yWzBdID0gZW1pdHRlci5wcm9wcy5TZWdtZW50Q29sb3JbMV1bMF07XG4gICAgICAgICAgICBzZWNvbmRDb2xvclsxXSA9IGVtaXR0ZXIucHJvcHMuU2VnbWVudENvbG9yWzFdWzFdO1xuICAgICAgICAgICAgc2Vjb25kQ29sb3JbMl0gPSBlbWl0dGVyLnByb3BzLlNlZ21lbnRDb2xvclsxXVsyXTtcbiAgICAgICAgICAgIHNlY29uZENvbG9yWzNdID0gZW1pdHRlci5wcm9wcy5BbHBoYVsxXSAvIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0Q29sb3JbMF0gPSBlbWl0dGVyLnByb3BzLlNlZ21lbnRDb2xvclsxXVswXTtcbiAgICAgICAgICAgIGZpcnN0Q29sb3JbMV0gPSBlbWl0dGVyLnByb3BzLlNlZ21lbnRDb2xvclsxXVsxXTtcbiAgICAgICAgICAgIGZpcnN0Q29sb3JbMl0gPSBlbWl0dGVyLnByb3BzLlNlZ21lbnRDb2xvclsxXVsyXTtcbiAgICAgICAgICAgIGZpcnN0Q29sb3JbM10gPSBlbWl0dGVyLnByb3BzLkFscGhhWzFdIC8gMjU1O1xuICAgICAgICAgICAgc2Vjb25kQ29sb3JbMF0gPSBlbWl0dGVyLnByb3BzLlNlZ21lbnRDb2xvclsyXVswXTtcbiAgICAgICAgICAgIHNlY29uZENvbG9yWzFdID0gZW1pdHRlci5wcm9wcy5TZWdtZW50Q29sb3JbMl1bMV07XG4gICAgICAgICAgICBzZWNvbmRDb2xvclsyXSA9IGVtaXR0ZXIucHJvcHMuU2VnbWVudENvbG9yWzJdWzJdO1xuICAgICAgICAgICAgc2Vjb25kQ29sb3JbM10gPSBlbWl0dGVyLnByb3BzLkFscGhhWzJdIC8gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGdsX21hdHJpeF8xLnZlYzQubGVycChjb2xvciwgZmlyc3RDb2xvciwgc2Vjb25kQ29sb3IsIHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgZW1pdHRlci5jb2xvcnNbaW5kZXggKiAxNiArIGkgKiA0XSA9IGNvbG9yWzBdO1xuICAgICAgICAgICAgZW1pdHRlci5jb2xvcnNbaW5kZXggKiAxNiArIGkgKiA0ICsgMV0gPSBjb2xvclsxXTtcbiAgICAgICAgICAgIGVtaXR0ZXIuY29sb3JzW2luZGV4ICogMTYgKyBpICogNCArIDJdID0gY29sb3JbMl07XG4gICAgICAgICAgICBlbWl0dGVyLmNvbG9yc1tpbmRleCAqIDE2ICsgaSAqIDQgKyAzXSA9IGNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJ0aWNsZXNDb250cm9sbGVyLnByb3RvdHlwZS5zZXRMYXllclByb3BzID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICAgICAgaWYgKGVtaXR0ZXIucHJvcHMuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZS5BbHBoYUtleSkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZGlzY2FyZEFscGhhTGV2ZWxVbmlmb3JtLCBESVNDQVJEX0FMUEhBX0tFWV9MRVZFTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW1pdHRlci5wcm9wcy5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlLk1vZHVsYXRlIHx8XG4gICAgICAgICAgICBlbWl0dGVyLnByb3BzLkZpbHRlck1vZGUgPT09IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGUuTW9kdWxhdGUyeCkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZGlzY2FyZEFscGhhTGV2ZWxVbmlmb3JtLCBESVNDQVJEX01PRFVMQVRFX0xFVkVMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmRpc2NhcmRBbHBoYUxldmVsVW5pZm9ybSwgMC4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0dGVyLnByb3BzLkZpbHRlck1vZGUgPT09IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZpbHRlck1vZGUuQmxlbmQpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVtaXR0ZXIucHJvcHMuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZS5BZGRpdGl2ZSkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVtaXR0ZXIucHJvcHMuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZS5BbHBoYUtleSkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVtaXR0ZXIucHJvcHMuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5QYXJ0aWNsZUVtaXR0ZXIyRmlsdGVyTW9kZS5Nb2R1bGF0ZSkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW1pdHRlci5wcm9wcy5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLlBhcnRpY2xlRW1pdHRlcjJGaWx0ZXJNb2RlLk1vZHVsYXRlMngpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5EU1RfQ09MT1IsIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLnJlbmRlcmVyRGF0YS5tb2RlbC5UZXh0dXJlc1tlbWl0dGVyLnByb3BzLlRleHR1cmVJRF07XG4gICAgICAgIGlmICh0ZXh0dXJlLkltYWdlKSB7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyZXJEYXRhLnRleHR1cmVzW3RleHR1cmUuSW1hZ2VdKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnNhbXBsZXJVbmlmb3JtLCAwKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnJlcGxhY2VhYmxlVHlwZVVuaWZvcm0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuUmVwbGFjZWFibGVJZCA9PT0gMSB8fCB0ZXh0dXJlLlJlcGxhY2VhYmxlSWQgPT09IDIpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZUNvbG9yVW5pZm9ybSwgdGhpcy5yZW5kZXJlckRhdGEudGVhbUNvbG9yKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnJlcGxhY2VhYmxlVHlwZVVuaWZvcm0sIHRleHR1cmUuUmVwbGFjZWFibGVJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIucHJvdG90eXBlLnNldEdlbmVyYWxCdWZmZXJzID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGVtaXR0ZXIuY29sb3JCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZW1pdHRlci5jb2xvcnMsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5jb2xvckF0dHJpYnV0ZSwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZW1pdHRlci5pbmRleEJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVtaXR0ZXIuaW5kaWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICB9O1xuICAgIFBhcnRpY2xlc0NvbnRyb2xsZXIucHJvdG90eXBlLnJlbmRlckVtaXR0ZXJUeXBlID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLlRhaWwpIHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBlbWl0dGVyLnRhaWxUZXhDb29yZEJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZW1pdHRlci50YWlsVGV4Q29vcmRzLCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGVtaXR0ZXIuaGVhZFRleENvb3JkQnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBlbWl0dGVyLmhlYWRUZXhDb29yZHMsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IG1vZGVsXzEuUGFydGljbGVFbWl0dGVyMkZyYW1lc0ZsYWdzLlRhaWwpIHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBlbWl0dGVyLnRhaWxWZXJ0ZXhCdWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGVtaXR0ZXIudGFpbFZlcnRpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGVtaXR0ZXIuaGVhZFZlcnRleEJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZW1pdHRlci5oZWFkVmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBlbWl0dGVyLnBhcnRpY2xlcy5sZW5ndGggKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFydGljbGVzQ29udHJvbGxlcjtcbn0oKSk7XG5leHBvcnRzLlBhcnRpY2xlc0NvbnRyb2xsZXIgPSBQYXJ0aWNsZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGljbGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbW9kZWxJbnRlcnBfMSA9IHJlcXVpcmUoXCIuL21vZGVsSW50ZXJwXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vbW9kZWxcIik7XG52YXIgZ2xfbWF0cml4XzEgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpO1xudmFyIGdsO1xudmFyIHNoYWRlclByb2dyYW07XG52YXIgc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucyA9IHt9O1xudmFyIHZlcnRleFNoYWRlciA9IFwiXFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG4gICAgdW5pZm9ybSBtYXQ0IHVNVk1hdHJpeDtcXG4gICAgdW5pZm9ybSBtYXQ0IHVQTWF0cml4O1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIHZlYzQgcG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdVBNYXRyaXggKiB1TVZNYXRyaXggKiBwb3NpdGlvbjtcXG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB9XFxuXCI7XG52YXIgZnJhZ21lbnRTaGFkZXIgPSBcIlxcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbiAgICB1bmlmb3JtIHZlYzMgdVJlcGxhY2VhYmxlQ29sb3I7XFxuICAgIHVuaWZvcm0gZmxvYXQgdVJlcGxhY2VhYmxlVHlwZTtcXG4gICAgdW5pZm9ybSBmbG9hdCB1RGlzY2FyZEFscGhhTGV2ZWw7XFxuICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxuICAgIGZsb2F0IGh5cG90ICh2ZWMyIHopIHtcXG4gICAgICAgIGZsb2F0IHQ7XFxuICAgICAgICBmbG9hdCB4ID0gYWJzKHoueCk7XFxuICAgICAgICBmbG9hdCB5ID0gYWJzKHoueSk7XFxuICAgICAgICB0ID0gbWluKHgsIHkpO1xcbiAgICAgICAgeCA9IG1heCh4LCB5KTtcXG4gICAgICAgIHQgPSB0IC8geDtcXG4gICAgICAgIHJldHVybiAoei54ID09IDAuMCAmJiB6LnkgPT0gMC4wKSA/IDAuMCA6IHggKiBzcXJ0KDEuMCArIHQgKiB0KTtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSB2ZWMyKHZUZXh0dXJlQ29vcmQucywgdlRleHR1cmVDb29yZC50KTtcXG4gICAgICAgIGlmICh1UmVwbGFjZWFibGVUeXBlID09IDAuKSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZHMpO1xcbiAgICAgICAgfSBlbHNlIGlmICh1UmVwbGFjZWFibGVUeXBlID09IDEuKSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1UmVwbGFjZWFibGVDb2xvciwgMS4wKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodVJlcGxhY2VhYmxlVHlwZSA9PSAyLikge1xcbiAgICAgICAgICAgIGZsb2F0IGRpc3QgPSBoeXBvdChjb29yZHMgLSB2ZWMyKDAuNSwgMC41KSkgKiAyLjtcXG4gICAgICAgICAgICBmbG9hdCB0cnVuY2F0ZURpc3QgPSBjbGFtcCgxLiAtIGRpc3QgKiAxLjQsIDAuLCAxLik7XFxuICAgICAgICAgICAgZmxvYXQgYWxwaGEgPSBzaW4odHJ1bmNhdGVEaXN0KTtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVSZXBsYWNlYWJsZUNvbG9yICogYWxwaGEsIDEuMCk7XFxuICAgICAgICB9XFxuICAgICAgICBnbF9GcmFnQ29sb3IgKj0gdUNvbG9yO1xcbiAgICAgICAgXFxuICAgICAgICBpZiAoZ2xfRnJhZ0NvbG9yWzNdIDwgdURpc2NhcmRBbHBoYUxldmVsKSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgfVxcblwiO1xudmFyIFJpYmJvbnNDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSaWJib25zQ29udHJvbGxlcihpbnRlcnAsIHJlbmRlcmVyRGF0YSkge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycDtcbiAgICAgICAgdGhpcy5yZW5kZXJlckRhdGEgPSByZW5kZXJlckRhdGE7XG4gICAgICAgIHRoaXMuZW1pdHRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHJlbmRlcmVyRGF0YS5tb2RlbC5SaWJib25FbWl0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSByZW5kZXJlckRhdGEubW9kZWwuUmliYm9uRW1pdHRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpYmJvbkVtaXR0ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGVtaXR0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXNzaW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogcmliYm9uRW1pdHRlcixcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDYXBhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRpb25UaW1lczogW10sXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRleENvb3JkczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4Q29vcmRCdWZmZXI6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuYmFzZUNhcGFjaXR5ID0gTWF0aC5jZWlsKG1vZGVsSW50ZXJwXzEuTW9kZWxJbnRlcnAubWF4QW5pbVZlY3RvclZhbChlbWl0dGVyLnByb3BzLkVtaXNzaW9uUmF0ZSkgKiBlbWl0dGVyLnByb3BzLkxpZmVTcGFuKSArIDE7IC8vIGV4dHJhIHBvaW50c1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlcnMucHVzaChlbWl0dGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSaWJib25zQ29udHJvbGxlci5pbml0R0wgPSBmdW5jdGlvbiAoZ2xDb250ZXh0KSB7XG4gICAgICAgIGdsID0gZ2xDb250ZXh0O1xuICAgICAgICBSaWJib25zQ29udHJvbGxlci5pbml0U2hhZGVycygpO1xuICAgIH07XG4gICAgUmliYm9uc0NvbnRyb2xsZXIuaW5pdFNoYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXggPSB1dGlsXzEuZ2V0U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXIsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSB1dGlsXzEuZ2V0U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlciwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleCk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnbWVudCk7XG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBhbGVydCgnQ291bGQgbm90IGluaXRpYWxpc2Ugc2hhZGVycycpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAnYVRleHR1cmVDb29yZCcpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnBNYXRyaXhVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1UE1hdHJpeCcpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLm12TWF0cml4VW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndU1WTWF0cml4Jyk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuc2FtcGxlclVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ3VTYW1wbGVyJyk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMucmVwbGFjZWFibGVDb2xvclVuaWZvcm0gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1UmVwbGFjZWFibGVDb2xvcicpO1xuICAgICAgICBzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnJlcGxhY2VhYmxlVHlwZVVuaWZvcm0gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sICd1UmVwbGFjZWFibGVUeXBlJyk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuZGlzY2FyZEFscGhhTGV2ZWxVbmlmb3JtID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndURpc2NhcmRBbHBoYUxldmVsJyk7XG4gICAgICAgIHNoYWRlclByb2dyYW1Mb2NhdGlvbnMuY29sb3JVbmlmb3JtID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndUNvbG9yJyk7XG4gICAgfTtcbiAgICBSaWJib25zQ29udHJvbGxlci5yZXNpemVFbWl0dGVyQnVmZmVycyA9IGZ1bmN0aW9uIChlbWl0dGVyLCBzaXplKSB7XG4gICAgICAgIGlmIChzaXplIDw9IGVtaXR0ZXIuY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgZW1pdHRlci5iYXNlQ2FwYWNpdHkpO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiAyICogMyk7IC8vIDIgdmVydGljZXMgKiB4eXpcbiAgICAgICAgdmFyIHRleENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDIgKiAyKTsgLy8gMiB2ZXJ0aWNlcyAqIHh5XG4gICAgICAgIGlmIChlbWl0dGVyLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5zZXQoZW1pdHRlci52ZXJ0aWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICBlbWl0dGVyLnRleENvb3JkcyA9IHRleENvb3JkcztcbiAgICAgICAgZW1pdHRlci5jYXBhY2l0eSA9IHNpemU7XG4gICAgICAgIGlmICghZW1pdHRlci52ZXJ0ZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBlbWl0dGVyLnRleENvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJpYmJvbnNDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZW1pdHRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW1pdHRlciA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRW1pdHRlcihlbWl0dGVyLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJpYmJvbnNDb250cm9sbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobXZNYXRyaXgsIHBNYXRyaXgpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnBNYXRyaXhVbmlmb3JtLCBmYWxzZSwgcE1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5tdk1hdHJpeFVuaWZvcm0sIGZhbHNlLCBtdk1hdHJpeCk7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVtaXR0ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVtaXR0ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoZW1pdHRlci5jcmVhdGlvblRpbWVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmNvbG9yVW5pZm9ybSwgZW1pdHRlci5wcm9wcy5Db2xvclswXSwgZW1pdHRlci5wcm9wcy5Db2xvclsxXSwgZW1pdHRlci5wcm9wcy5Db2xvclsyXSwgdGhpcy5pbnRlcnAuYW5pbVZlY3RvclZhbChlbWl0dGVyLnByb3BzLkFscGhhLCAxKSk7XG4gICAgICAgICAgICB0aGlzLnNldEdlbmVyYWxCdWZmZXJzKGVtaXR0ZXIpO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsSUQgPSBlbWl0dGVyLnByb3BzLk1hdGVyaWFsSUQ7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLnJlbmRlcmVyRGF0YS5tb2RlbC5NYXRlcmlhbHNbbWF0ZXJpYWxJRF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGVyaWFsLkxheWVycy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJQcm9wcyhtYXRlcmlhbC5MYXllcnNbal0sIHRoaXMucmVuZGVyZXJEYXRhLm1hdGVyaWFsTGF5ZXJUZXh0dXJlSURbbWF0ZXJpYWxJRF1bal0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW1pdHRlcihlbWl0dGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSk7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICBSaWJib25zQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlRW1pdHRlciA9IGZ1bmN0aW9uIChlbWl0dGVyLCBkZWx0YSkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHZpc2liaWxpdHkgPSB0aGlzLmludGVycC5hbmltVmVjdG9yVmFsKGVtaXR0ZXIucHJvcHMuVmlzaWJpbGl0eSwgMSk7XG4gICAgICAgIGlmICh2aXNpYmlsaXR5ID4gMCkge1xuICAgICAgICAgICAgdmFyIGVtaXNzaW9uUmF0ZSA9IGVtaXR0ZXIucHJvcHMuRW1pc3Npb25SYXRlO1xuICAgICAgICAgICAgZW1pdHRlci5lbWlzc2lvbiArPSBlbWlzc2lvblJhdGUgKiBkZWx0YTtcbiAgICAgICAgICAgIGlmIChlbWl0dGVyLmVtaXNzaW9uID49IDEwMDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG9uY2UgcGVyIHRpY2tcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXNzaW9uID0gZW1pdHRlci5lbWlzc2lvbiAlIDEwMDA7XG4gICAgICAgICAgICAgICAgaWYgKGVtaXR0ZXIuY3JlYXRpb25UaW1lcy5sZW5ndGggKyAxID4gZW1pdHRlci5jYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICBSaWJib25zQ29udHJvbGxlci5yZXNpemVFbWl0dGVyQnVmZmVycyhlbWl0dGVyLCBlbWl0dGVyLmNyZWF0aW9uVGltZXMubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kVmVydGljZXMoZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5jcmVhdGlvblRpbWVzLnB1c2gobm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdHRlci5jcmVhdGlvblRpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpbGUgKGVtaXR0ZXIuY3JlYXRpb25UaW1lc1swXSArIGVtaXR0ZXIucHJvcHMuTGlmZVNwYW4gKiAxMDAwIDwgbm93KSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5jcmVhdGlvblRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyA2ICsgNSA8IGVtaXR0ZXIudmVydGljZXMubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci52ZXJ0aWNlc1tpXSA9IGVtaXR0ZXIudmVydGljZXNbaSArIDZdO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2kgKyAxXSA9IGVtaXR0ZXIudmVydGljZXNbaSArIDddO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2kgKyAyXSA9IGVtaXR0ZXIudmVydGljZXNbaSArIDhdO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2kgKyAzXSA9IGVtaXR0ZXIudmVydGljZXNbaSArIDldO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2kgKyA0XSA9IGVtaXR0ZXIudmVydGljZXNbaSArIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci52ZXJ0aWNlc1tpICsgNV0gPSBlbWl0dGVyLnZlcnRpY2VzW2kgKyAxMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0aWxsIGV4aXN0c1xuICAgICAgICBpZiAoZW1pdHRlci5jcmVhdGlvblRpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbWl0dGVyVGV4Q29vcmRzKGVtaXR0ZXIsIG5vdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJpYmJvbnNDb250cm9sbGVyLnByb3RvdHlwZS5hcHBlbmRWZXJ0aWNlcyA9IGZ1bmN0aW9uIChlbWl0dGVyKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IGdsX21hdHJpeF8xLnZlYzMuY2xvbmUoZW1pdHRlci5wcm9wcy5QaXZvdFBvaW50KTtcbiAgICAgICAgdmFyIHNlY29uZCA9IGdsX21hdHJpeF8xLnZlYzMuY2xvbmUoZW1pdHRlci5wcm9wcy5QaXZvdFBvaW50KTtcbiAgICAgICAgZmlyc3RbMV0gLT0gdGhpcy5pbnRlcnAuYW5pbVZlY3RvclZhbChlbWl0dGVyLnByb3BzLkhlaWdodEJlbG93LCAwKTtcbiAgICAgICAgc2Vjb25kWzFdICs9IHRoaXMuaW50ZXJwLmFuaW1WZWN0b3JWYWwoZW1pdHRlci5wcm9wcy5IZWlnaHRBYm92ZSwgMCk7XG4gICAgICAgIHZhciBlbWl0dGVyTWF0cml4ID0gdGhpcy5yZW5kZXJlckRhdGEubm9kZXNbZW1pdHRlci5wcm9wcy5PYmplY3RJZF0ubWF0cml4O1xuICAgICAgICBnbF9tYXRyaXhfMS52ZWMzLnRyYW5zZm9ybU1hdDQoZmlyc3QsIGZpcnN0LCBlbWl0dGVyTWF0cml4KTtcbiAgICAgICAgZ2xfbWF0cml4XzEudmVjMy50cmFuc2Zvcm1NYXQ0KHNlY29uZCwgc2Vjb25kLCBlbWl0dGVyTWF0cml4KTtcbiAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gZW1pdHRlci5jcmVhdGlvblRpbWVzLmxlbmd0aDtcbiAgICAgICAgZW1pdHRlci52ZXJ0aWNlc1tjdXJyZW50U2l6ZSAqIDZdID0gZmlyc3RbMF07XG4gICAgICAgIGVtaXR0ZXIudmVydGljZXNbY3VycmVudFNpemUgKiA2ICsgMV0gPSBmaXJzdFsxXTtcbiAgICAgICAgZW1pdHRlci52ZXJ0aWNlc1tjdXJyZW50U2l6ZSAqIDYgKyAyXSA9IGZpcnN0WzJdO1xuICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2N1cnJlbnRTaXplICogNiArIDNdID0gc2Vjb25kWzBdO1xuICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2N1cnJlbnRTaXplICogNiArIDRdID0gc2Vjb25kWzFdO1xuICAgICAgICBlbWl0dGVyLnZlcnRpY2VzW2N1cnJlbnRTaXplICogNiArIDVdID0gc2Vjb25kWzJdO1xuICAgIH07XG4gICAgUmliYm9uc0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZUVtaXR0ZXJUZXhDb29yZHMgPSBmdW5jdGlvbiAoZW1pdHRlciwgbm93KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW1pdHRlci5jcmVhdGlvblRpbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVQb3MgPSAobm93IC0gZW1pdHRlci5jcmVhdGlvblRpbWVzW2ldKSAvIChlbWl0dGVyLnByb3BzLkxpZmVTcGFuICogMTAwMCk7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZVNsb3QgPSB0aGlzLmludGVycC5hbmltVmVjdG9yVmFsKGVtaXR0ZXIucHJvcHMuVGV4dHVyZVNsb3QsIDApO1xuICAgICAgICAgICAgdmFyIHRleENvb3JkWCA9IHRleHR1cmVTbG90ICUgZW1pdHRlci5wcm9wcy5Db2x1bW5zO1xuICAgICAgICAgICAgdmFyIHRleENvb3JkWSA9IE1hdGguZmxvb3IodGV4dHVyZVNsb3QgLyBlbWl0dGVyLnByb3BzLlJvd3MpO1xuICAgICAgICAgICAgdmFyIGNlbGxXaWR0aCA9IDEgLyBlbWl0dGVyLnByb3BzLkNvbHVtbnM7XG4gICAgICAgICAgICB2YXIgY2VsbEhlaWdodCA9IDEgLyBlbWl0dGVyLnByb3BzLlJvd3M7XG4gICAgICAgICAgICByZWxhdGl2ZVBvcyA9IHRleENvb3JkWCAqIGNlbGxXaWR0aCArIHJlbGF0aXZlUG9zICogY2VsbFdpZHRoO1xuICAgICAgICAgICAgZW1pdHRlci50ZXhDb29yZHNbaSAqIDIgKiAyXSA9IHJlbGF0aXZlUG9zO1xuICAgICAgICAgICAgZW1pdHRlci50ZXhDb29yZHNbaSAqIDIgKiAyICsgMV0gPSB0ZXhDb29yZFkgKiBjZWxsSGVpZ2h0O1xuICAgICAgICAgICAgZW1pdHRlci50ZXhDb29yZHNbaSAqIDIgKiAyICsgMl0gPSByZWxhdGl2ZVBvcztcbiAgICAgICAgICAgIGVtaXR0ZXIudGV4Q29vcmRzW2kgKiAyICogMiArIDNdID0gKDEgKyB0ZXhDb29yZFkpICogY2VsbEhlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmliYm9uc0NvbnRyb2xsZXIucHJvdG90eXBlLnNldExheWVyUHJvcHMgPSBmdW5jdGlvbiAobGF5ZXIsIHRleHR1cmVJRCkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMucmVuZGVyZXJEYXRhLm1vZGVsLlRleHR1cmVzW3RleHR1cmVJRF07XG4gICAgICAgIGlmIChsYXllci5TaGFkaW5nICYgbW9kZWxfMS5MYXllclNoYWRpbmcuVHdvU2lkZWQpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLmRpc2NhcmRBbHBoYUxldmVsVW5pZm9ybSwgMC43NSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5kaXNjYXJkQWxwaGFMZXZlbFVuaWZvcm0sIDAuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5GaWx0ZXJNb2RlLk5vbmUpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgLy8gZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5GaWx0ZXJNb2RlLlRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVyLkZpbHRlck1vZGUgPT09IG1vZGVsXzEuRmlsdGVyTW9kZS5CbGVuZCkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5GaWx0ZXJNb2RlLkFkZGl0aXZlKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19DT0xPUiwgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5GaWx0ZXJNb2RlLkFkZEFscGhhKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGF5ZXIuRmlsdGVyTW9kZSA9PT0gbW9kZWxfMS5GaWx0ZXJNb2RlLk1vZHVsYXRlKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5PTkUpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllci5GaWx0ZXJNb2RlID09PSBtb2RlbF8xLkZpbHRlck1vZGUuTW9kdWxhdGUyeCkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLkRTVF9DT0xPUiwgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5PTkUpO1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dHVyZS5JbWFnZSkge1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnJlbmRlcmVyRGF0YS50ZXh0dXJlc1t0ZXh0dXJlLkltYWdlXSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5zYW1wbGVyVW5pZm9ybSwgMCk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZVR5cGVVbmlmb3JtLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0dXJlLlJlcGxhY2VhYmxlSWQgPT09IDEgfHwgdGV4dHVyZS5SZXBsYWNlYWJsZUlkID09PSAyKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMucmVwbGFjZWFibGVDb2xvclVuaWZvcm0sIHRoaXMucmVuZGVyZXJEYXRhLnRlYW1Db2xvcik7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy5yZXBsYWNlYWJsZVR5cGVVbmlmb3JtLCB0ZXh0dXJlLlJlcGxhY2VhYmxlSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci5TaGFkaW5nICYgbW9kZWxfMS5MYXllclNoYWRpbmcuTm9EZXB0aFRlc3QpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyLlNoYWRpbmcgJiBtb2RlbF8xLkxheWVyU2hhZGluZy5Ob0RlcHRoU2V0KSB7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qaWYgKHR5cGVvZiBsYXllci5UVmVydGV4QW5pbUlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbGV0IGFuaW06IFRWZXJ0ZXhBbmltID0gdGhpcy5yZW5kZXJlckRhdGEubW9kZWwuVGV4dHVyZUFuaW1zW2xheWVyLlRWZXJ0ZXhBbmltSWRdO1xuICAgICAgICAgICAgbGV0IHRyYW5zbGF0aW9uUmVzID0gdGhpcy5pbnRlcnAudmVjMyh0cmFuc2xhdGlvbiwgYW5pbS5UcmFuc2xhdGlvbik7XG4gICAgICAgICAgICBsZXQgcm90YXRpb25SZXMgPSB0aGlzLmludGVycC5xdWF0KHJvdGF0aW9uLCBhbmltLlJvdGF0aW9uKTtcbiAgICAgICAgICAgIGxldCBzY2FsaW5nUmVzID0gdGhpcy5pbnRlcnAudmVjMyhzY2FsaW5nLCBhbmltLlNjYWxpbmcpO1xuICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKFxuICAgICAgICAgICAgICAgIHRleENvb3JkTWF0NCxcbiAgICAgICAgICAgICAgICByb3RhdGlvblJlcyB8fCBkZWZhdWx0Um90YXRpb24sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25SZXMgfHwgZGVmYXVsdFRyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgIHNjYWxpbmdSZXMgfHwgZGVmYXVsdFNjYWxpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYXQzLnNldChcbiAgICAgICAgICAgICAgICB0ZXhDb29yZE1hdDMsXG4gICAgICAgICAgICAgICAgdGV4Q29vcmRNYXQ0WzBdLCB0ZXhDb29yZE1hdDRbMV0sIDAsXG4gICAgICAgICAgICAgICAgdGV4Q29vcmRNYXQ0WzRdLCB0ZXhDb29yZE1hdDRbNV0sIDAsXG4gICAgICAgICAgICAgICAgdGV4Q29vcmRNYXQ0WzEyXSwgdGV4Q29vcmRNYXQ0WzEzXSwgMFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRWZXJ0ZXhBbmltVW5pZm9ybSwgZmFsc2UsIHRleENvb3JkTWF0Myk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlclByb2dyYW1Mb2NhdGlvbnMudFZlcnRleEFuaW1Vbmlmb3JtLCBmYWxzZSwgaWRlbnRpZnlNYXQzKTtcbiAgICAgICAgfSovXG4gICAgfTtcbiAgICBSaWJib25zQ29udHJvbGxlci5wcm90b3R5cGUuc2V0R2VuZXJhbEJ1ZmZlcnMgPSBmdW5jdGlvbiAoZW1pdHRlcikge1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZW1pdHRlci50ZXhDb29yZEJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBlbWl0dGVyLnRleENvb3JkcywgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtTG9jYXRpb25zLnRleHR1cmVDb29yZEF0dHJpYnV0ZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGVtaXR0ZXIudmVydGV4QnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGVtaXR0ZXIudmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbUxvY2F0aW9ucy52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICB9O1xuICAgIFJpYmJvbnNDb250cm9sbGVyLnByb3RvdHlwZS5yZW5kZXJFbWl0dGVyID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgZW1pdHRlci5jcmVhdGlvblRpbWVzLmxlbmd0aCAqIDIpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpYmJvbnNDb250cm9sbGVyO1xufSgpKTtcbmV4cG9ydHMuUmliYm9uc0NvbnRyb2xsZXIgPSBSaWJib25zQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpYmJvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtYXQ0ZnJvbVJvdGF0aW9uT3JpZ2luKG91dCwgcm90YXRpb24sIG9yaWdpbikge1xuICAgIHZhciB4ID0gcm90YXRpb25bMF0sIHkgPSByb3RhdGlvblsxXSwgeiA9IHJvdGF0aW9uWzJdLCB3ID0gcm90YXRpb25bM10sIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHosIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejIsIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejIsIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejIsIG94ID0gb3JpZ2luWzBdLCBveSA9IG9yaWdpblsxXSwgb3ogPSBvcmlnaW5bMl07XG4gICAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpO1xuICAgIG91dFsxXSA9ICh4eSArIHd6KTtcbiAgICBvdXRbMl0gPSAoeHogLSB3eSk7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAoeHkgLSB3eik7XG4gICAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpO1xuICAgIG91dFs2XSA9ICh5eiArIHd4KTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9ICh4eiArIHd5KTtcbiAgICBvdXRbOV0gPSAoeXogLSB3eCk7XG4gICAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gb3ggLSAob3V0WzBdICogb3ggKyBvdXRbNF0gKiBveSArIG91dFs4XSAqIG96KTtcbiAgICBvdXRbMTNdID0gb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgICBvdXRbMTRdID0gb3ogLSAob3V0WzJdICogb3ggKyBvdXRbNl0gKiBveSArIG91dFsxMF0gKiBveik7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMubWF0NGZyb21Sb3RhdGlvbk9yaWdpbiA9IG1hdDRmcm9tUm90YXRpb25PcmlnaW47XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdmVjM1JvdGF0ZVoob3V0LCBhLCBjKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIE1hdGguY29zKGMpIC0gYVsxXSAqIE1hdGguc2luKGMpO1xuICAgIG91dFsxXSA9IGFbMF0gKiBNYXRoLnNpbihjKSArIGFbMV0gKiBNYXRoLmNvcyhjKTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnZlYzNSb3RhdGVaID0gdmVjM1JvdGF0ZVo7XG5mdW5jdGlvbiByYW5kKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGZyb20gKyBNYXRoLnJhbmRvbSgpICogKHRvIC0gZnJvbSk7XG59XG5leHBvcnRzLnJhbmQgPSByYW5kO1xuZnVuY3Rpb24gZGVnVG9SYWQoYW5nbGUpIHtcbiAgICByZXR1cm4gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xufVxuZXhwb3J0cy5kZWdUb1JhZCA9IGRlZ1RvUmFkO1xuZnVuY3Rpb24gZ2V0U2hhZGVyKGdsLCBzb3VyY2UsIHR5cGUpIHtcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIGFsZXJ0KGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xufVxuZXhwb3J0cy5nZXRTaGFkZXIgPSBnZXRTaGFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qXG4gQ29weXJpZ2h0IDIwMTEgbm90bWFzdGVyeWV0XG5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gLSBUaGUgSlBFRyBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSVRVIENDSVRUIFJlY29tbWVuZGF0aW9uIFQuODFcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZilcbi8vIC0gVGhlIEpGSUYgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIEpQRUcgRmlsZSBJbnRlcmNoYW5nZSBGb3JtYXRcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9qZmlmMy5wZGYpXG4vLyAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzXG4vLyAgIGluIFBvc3RTY3JpcHQgTGV2ZWwgMiwgVGVjaG5pY2FsIE5vdGUgIzUxMTZcbi8vICAgKHBhcnRuZXJzLmFkb2JlLmNvbS9wdWJsaWMvZGV2ZWxvcGVyL2VuL3BzL3Nkay81MTE2LkRDVF9GaWx0ZXIucGRmKVxuXG4vLyBOT1RFOiBUaGlzIGZpbGUgd2FzIGVkaXRlZCB0byBtYXRjaCB0aGUgY3J1ZGUgdXNhZ2Ugb2YgdGhlIEpQRyBmb3JtYXQgYnkgQmxpenphcmQgZm9yIHRoZWlyIEJMUDEgZm9ybWF0LlxuXG52YXIgSnBlZ0ltYWdlID0gKGZ1bmN0aW9uIGpwZWdJbWFnZSgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGN0WmlnWmFnID0gbmV3IEludDMyQXJyYXkoW1xuICAgICAgICAwLFxuICAgICAgICAxLCAgOCxcbiAgICAgICAgMTYsICA5LCAgMixcbiAgICAgICAgMywgMTAsIDE3LCAyNCxcbiAgICAgICAgMzIsIDI1LCAxOCwgMTEsIDQsXG4gICAgICAgIDUsIDEyLCAxOSwgMjYsIDMzLCA0MCxcbiAgICAgICAgNDgsIDQxLCAzNCwgMjcsIDIwLCAxMywgIDYsXG4gICAgICAgIDcsIDE0LCAyMSwgMjgsIDM1LCA0MiwgNDksIDU2LFxuICAgICAgICA1NywgNTAsIDQzLCAzNiwgMjksIDIyLCAxNSxcbiAgICAgICAgMjMsIDMwLCAzNywgNDQsIDUxLCA1OCxcbiAgICAgICAgNTksIDUyLCA0NSwgMzgsIDMxLFxuICAgICAgICAzOSwgNDYsIDUzLCA2MCxcbiAgICAgICAgNjEsIDU0LCA0NyxcbiAgICAgICAgNTUsIDYyLFxuICAgICAgICA2M1xuICAgIF0pO1xuXG4gICAgdmFyIGRjdENvczEgID0gIDQwMTcgICAvLyBjb3MocGkvMTYpXG4gICAgdmFyIGRjdFNpbjEgID0gICA3OTkgICAvLyBzaW4ocGkvMTYpXG4gICAgdmFyIGRjdENvczMgID0gIDM0MDYgICAvLyBjb3MoMypwaS8xNilcbiAgICB2YXIgZGN0U2luMyAgPSAgMjI3NiAgIC8vIHNpbigzKnBpLzE2KVxuICAgIHZhciBkY3RDb3M2ICA9ICAxNTY3ICAgLy8gY29zKDYqcGkvMTYpXG4gICAgdmFyIGRjdFNpbjYgID0gIDM3ODQgICAvLyBzaW4oNipwaS8xNilcbiAgICB2YXIgZGN0U3FydDIgPSAgNTc5MyAgIC8vIHNxcnQoMilcbiAgICB2YXIgZGN0U3FydDFkMiA9IDI4OTYgIC8vIHNxcnQoMikgLyAyXG5cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBrID0gMCwgY29kZSA9IFtdLCBpLCBqLCBsZW5ndGggPSAxNjtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgIWNvZGVMZW5ndGhzW2xlbmd0aCAtIDFdKVxuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIGNvZGUucHVzaCh7Y2hpbGRyZW46IFtdLCBpbmRleDogMH0pO1xuICAgICAgICB2YXIgcCA9IGNvZGVbMF0sIHE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcC5pbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPD0gaSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2gocSA9IHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XG4gICAgICAgICAgICAgICAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSBxLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBwID0gcTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gcCBoZXJlIHBvaW50cyB0byBsYXN0IGNvZGVcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2gocSA9IHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XG4gICAgICAgICAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVbMF0uY2hpbGRyZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCByb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gNjQgKiAoKGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lICsgMSkgKiByb3cgKyBjb2wpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYW4oZGF0YSwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVQcmV2LCBzdWNjZXNzaXZlKSB7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBmcmFtZS5wcmVjaXNpb247XG4gICAgICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lO1xuICAgICAgICB2YXIgc2NhbkxpbmVzID0gZnJhbWUuc2NhbkxpbmVzO1xuICAgICAgICB2YXIgbWN1c1BlckxpbmUgPSBmcmFtZS5tY3VzUGVyTGluZTtcbiAgICAgICAgdmFyIHByb2dyZXNzaXZlID0gZnJhbWUucHJvZ3Jlc3NpdmU7XG4gICAgICAgIHZhciBtYXhIID0gZnJhbWUubWF4SCwgbWF4ViA9IGZyYW1lLm1heFY7XG5cbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0LCBiaXRzRGF0YSA9IDAsIGJpdHNDb3VudCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZEJpdCgpIHtcbiAgICAgICAgICAgIGlmIChiaXRzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYml0c0NvdW50LS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChiaXRzRGF0YSA+PiBiaXRzQ291bnQpICYgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHNEYXRhID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBpZiAoYml0c0RhdGEgPT0gMHhGRikge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Qnl0ZSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Qnl0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcInVuZXhwZWN0ZWQgbWFya2VyOiBcIiArICgoYml0c0RhdGEgPDwgOCkgfCBuZXh0Qnl0ZSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1bnN0dWZmIDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHNDb3VudCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gYml0c0RhdGEgPj4+IDc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdHJlZTtcbiAgICAgICAgICAgIHZhciBiaXQ7XG4gICAgICAgICAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVtiaXRdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlY2VpdmUobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSByZWFkQml0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGJpdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG4gPSAobiA8PCAxKSB8IGJpdDtcbiAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZUFuZEV4dGVuZChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuID0gcmVjZWl2ZShsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKG4gPj0gMSA8PCAobGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdCA9PT0gMCA/IDAgOiByZWNlaXZlQW5kRXh0ZW5kKHQpO1xuICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXRdID0gKGNvbXBvbmVudC5wcmVkICs9IGRpZmYpO1xuICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGsgPCA2NCkge1xuICAgICAgICAgICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHJzICYgMTUsIHIgPSBycyA+PiA0O1xuICAgICAgICAgICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyIDwgMTUpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgayArPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgKz0gcjtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVEQ0ZpcnN0KGNvbXBvbmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdCA9PT0gMCA/IDAgOiAocmVjZWl2ZUFuZEV4dGVuZCh0KSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0XSA9IChjb21wb25lbnQucHJlZCArPSBkaWZmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXRdIHw9IHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVvYnJ1biA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChlb2JydW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgZW9icnVuLS07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQ7XG4gICAgICAgICAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gcnMgJiAxNSwgciA9IHJzID4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsgKz0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrICs9IHI7XG4gICAgICAgICAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSA9IHJlY2VpdmVBbmRFeHRlbmQocykgKiAoMSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwLCBzdWNjZXNzaXZlQUNOZXh0VmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUFDU3VjY2Vzc2l2ZShjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQsIHIgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3VjY2Vzc2l2ZUFDU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiAvLyBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHJzICYgMTUsIHIgPSBycyA+PiA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiaW52YWxpZCBBQ24gZW5jb2RpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gciA/IDIgOiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gc2tpcHBpbmcgciB6ZXJvIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT0gMiA/IDMgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gc2V0IHZhbHVlIGZvciBhIHplcm8gaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiAvLyBlb2JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGVvYnJ1bi0tO1xuICAgICAgICAgICAgICAgIGlmIChlb2JydW4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZSwgbWN1LCByb3csIGNvbCkge1xuICAgICAgICAgICAgdmFyIG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgICAgICAgICAgdmFyIG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgICAgICAgICAgdmFyIGJsb2NrUm93ID0gbWN1Um93ICogY29tcG9uZW50LnYgKyByb3c7XG4gICAgICAgICAgICB2YXIgYmxvY2tDb2wgPSBtY3VDb2wgKiBjb21wb25lbnQuaCArIGNvbDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICAgICAgICBkZWNvZGUoY29tcG9uZW50LCBvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGUsIG1jdSkge1xuICAgICAgICAgICAgdmFyIGJsb2NrUm93ID0gKG1jdSAvIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lKSB8IDA7XG4gICAgICAgICAgICB2YXIgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICAgICAgICBkZWNvZGUoY29tcG9uZW50LCBvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudHNMZW5ndGggPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCwgaSwgaiwgaywgbjtcbiAgICAgICAgdmFyIGRlY29kZUZuO1xuICAgICAgICBpZiAocHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgIGlmIChzcGVjdHJhbFN0YXJ0ID09PSAwKVxuICAgICAgICAgICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVjb2RlRm4gPSBkZWNvZGVCYXNlbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtY3UgPSAwLCBtYXJrZXI7XG4gICAgICAgIHZhciBtY3VFeHBlY3RlZDtcbiAgICAgICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbWN1RXhwZWN0ZWQgPSBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgKiBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1jdUV4cGVjdGVkID0gbWN1c1BlckxpbmUgKiBmcmFtZS5tY3VzUGVyQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzZXRJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmVzZXRJbnRlcnZhbCA9IG1jdUV4cGVjdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGgsIHY7XG4gICAgICAgIHdoaWxlIChtY3UgPCBtY3VFeHBlY3RlZCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgaW50ZXJ2YWwgc3R1ZmZcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW9icnVuID0gMDtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IHJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xuICAgICAgICAgICAgICAgICAgICBtY3UrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCByZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBjb21wb25lbnQuaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBjb21wb25lbnQudjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZUZuLCBtY3UsIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtY3UrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbmQgbWFya2VyXG4gICAgICAgICAgICBiaXRzQ291bnQgPSAwO1xuICAgICAgICAgICAgbWFya2VyID0gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBpZiAobWFya2VyIDw9IDB4RkYwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwibWFya2VyIHdhcyBub3QgZm91bmRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hcmtlciA+PSAweEZGRDAgJiYgbWFya2VyIDw9IDB4RkZENykgeyAvLyBSU1R4XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICAgIH1cblxuICAgIC8vIEEgcG9ydCBvZiBwb3BwbGVyJ3MgSURDVCBtZXRob2Qgd2hpY2ggaW4gdHVybiBpcyB0YWtlbiBmcm9tOlxuICAgIC8vICAgQ2hyaXN0b3BoIExvZWZmbGVyLCBBZHJpYWFuIExpZ3RlbmJlcmcsIEdlb3JnZSBTLiBNb3NjaHl0eixcbiAgICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXG4gICAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksXG4gICAgLy8gICA5ODgtOTkxLlxuICAgIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQsIGJsb2NrQnVmZmVyT2Zmc2V0LCBwKSB7XG4gICAgICAgIHZhciBxdCA9IGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZTtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdDtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gZGVxdWFudFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgcFtpXSA9IGNvbXBvbmVudC5ibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBpXSAqIHF0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52ZXJzZSBEQ1Qgb24gcm93c1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gOCAqIGk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgICAgICAgIGlmIChwWzEgKyByb3ddID09IDAgJiYgcFsyICsgcm93XSA9PSAwICYmIHBbMyArIHJvd10gPT0gMCAmJlxuICAgICAgICAgICAgICAgIHBbNCArIHJvd10gPT0gMCAmJiBwWzUgKyByb3ddID09IDAgJiYgcFs2ICsgcm93XSA9PSAwICYmXG4gICAgICAgICAgICAgICAgcFs3ICsgcm93XSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IChkY3RTcXJ0MiAqIHBbMCArIHJvd10gKyA1MTIpID4+IDEwO1xuICAgICAgICAgICAgICAgIHBbMCArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbMSArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbMiArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbMyArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbNCArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbNSArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbNiArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIHBbNyArIHJvd10gPSB0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdGFnZSA0XG4gICAgICAgICAgICB2MCA9IChkY3RTcXJ0MiAqIHBbMCArIHJvd10gKyAxMjgpID4+IDg7XG4gICAgICAgICAgICB2MSA9IChkY3RTcXJ0MiAqIHBbNCArIHJvd10gKyAxMjgpID4+IDg7XG4gICAgICAgICAgICB2MiA9IHBbMiArIHJvd107XG4gICAgICAgICAgICB2MyA9IHBbNiArIHJvd107XG4gICAgICAgICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gLSBwWzcgKyByb3ddKSArIDEyOCkgPj4gODtcbiAgICAgICAgICAgIHY3ID0gKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSArIHBbNyArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgICAgICAgdjUgPSBwWzMgKyByb3ddIDw8IDQ7XG4gICAgICAgICAgICB2NiA9IHBbNSArIHJvd10gPDwgNDtcblxuICAgICAgICAgICAgLy8gc3RhZ2UgM1xuICAgICAgICAgICAgdCA9ICh2MCAtIHYxKyAxKSA+PiAxO1xuICAgICAgICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICAgICAgICB2MSA9IHQ7XG4gICAgICAgICAgICB0ID0gKHYyICogZGN0U2luNiArIHYzICogZGN0Q29zNiArIDEyOCkgPj4gODtcbiAgICAgICAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDEyOCkgPj4gODtcbiAgICAgICAgICAgIHYzID0gdDtcbiAgICAgICAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7XG4gICAgICAgICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHY2ID0gdDtcbiAgICAgICAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICAgICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHY3ID0gdDtcblxuICAgICAgICAgICAgLy8gc3RhZ2UgMlxuICAgICAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgICAgICAgdjMgPSB0O1xuICAgICAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgICAgICAgdjIgPSB0O1xuICAgICAgICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgICAgIHY0ID0gKHY0ICogZGN0Q29zMyAtIHY3ICogZGN0U2luMyArIDIwNDgpID4+IDEyO1xuICAgICAgICAgICAgdjcgPSB0O1xuICAgICAgICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgICAgIHY1ID0gKHY1ICogZGN0Q29zMSAtIHY2ICogZGN0U2luMSArIDIwNDgpID4+IDEyO1xuICAgICAgICAgICAgdjYgPSB0O1xuXG4gICAgICAgICAgICAvLyBzdGFnZSAxXG4gICAgICAgICAgICBwWzAgKyByb3ddID0gdjAgKyB2NztcbiAgICAgICAgICAgIHBbNyArIHJvd10gPSB2MCAtIHY3O1xuICAgICAgICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7XG4gICAgICAgICAgICBwWzYgKyByb3ddID0gdjEgLSB2NjtcbiAgICAgICAgICAgIHBbMiArIHJvd10gPSB2MiArIHY1O1xuICAgICAgICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7XG4gICAgICAgICAgICBwWzMgKyByb3ddID0gdjMgKyB2NDtcbiAgICAgICAgICAgIHBbNCArIHJvd10gPSB2MyAtIHY0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29sID0gaTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGFsbC16ZXJvIEFDIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgaWYgKHBbMSo4ICsgY29sXSA9PSAwICYmIHBbMio4ICsgY29sXSA9PSAwICYmIHBbMyo4ICsgY29sXSA9PSAwICYmXG4gICAgICAgICAgICAgICAgcFs0KjggKyBjb2xdID09IDAgJiYgcFs1KjggKyBjb2xdID09IDAgJiYgcFs2KjggKyBjb2xdID09IDAgJiZcbiAgICAgICAgICAgICAgICBwWzcqOCArIGNvbF0gPT0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSAoZGN0U3FydDIgKiBwW2krMF0gKyA4MTkyKSA+PiAxNDtcbiAgICAgICAgICAgICAgICBwWzAqOCArIGNvbF0gPSB0O1xuICAgICAgICAgICAgICAgIHBbMSo4ICsgY29sXSA9IHQ7XG4gICAgICAgICAgICAgICAgcFsyKjggKyBjb2xdID0gdDtcbiAgICAgICAgICAgICAgICBwWzMqOCArIGNvbF0gPSB0O1xuICAgICAgICAgICAgICAgIHBbNCo4ICsgY29sXSA9IHQ7XG4gICAgICAgICAgICAgICAgcFs1KjggKyBjb2xdID0gdDtcbiAgICAgICAgICAgICAgICBwWzYqOCArIGNvbF0gPSB0O1xuICAgICAgICAgICAgICAgIHBbNyo4ICsgY29sXSA9IHQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0YWdlIDRcbiAgICAgICAgICAgIHYwID0gKGRjdFNxcnQyICogcFswKjggKyBjb2xdICsgMjA0OCkgPj4gMTI7XG4gICAgICAgICAgICB2MSA9IChkY3RTcXJ0MiAqIHBbNCo4ICsgY29sXSArIDIwNDgpID4+IDEyO1xuICAgICAgICAgICAgdjIgPSBwWzIqOCArIGNvbF07XG4gICAgICAgICAgICB2MyA9IHBbNio4ICsgY29sXTtcbiAgICAgICAgICAgIHY0ID0gKGRjdFNxcnQxZDIgKiAocFsxKjggKyBjb2xdIC0gcFs3KjggKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwWzEqOCArIGNvbF0gKyBwWzcqOCArIGNvbF0pICsgMjA0OCkgPj4gMTI7XG4gICAgICAgICAgICB2NSA9IHBbMyo4ICsgY29sXTtcbiAgICAgICAgICAgIHY2ID0gcFs1KjggKyBjb2xdO1xuXG4gICAgICAgICAgICAvLyBzdGFnZSAzXG4gICAgICAgICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxO1xuICAgICAgICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICAgICAgICB2MSA9IHQ7XG4gICAgICAgICAgICB0ID0gKHYyICogZGN0U2luNiArIHYzICogZGN0Q29zNiArIDIwNDgpID4+IDEyO1xuICAgICAgICAgICAgdjIgPSAodjIgKiBkY3RDb3M2IC0gdjMgKiBkY3RTaW42ICsgMjA0OCkgPj4gMTI7XG4gICAgICAgICAgICB2MyA9IHQ7XG4gICAgICAgICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICAgICAgICB2NiA9IHQ7XG4gICAgICAgICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICAgICAgICB2NyA9IHQ7XG5cbiAgICAgICAgICAgIC8vIHN0YWdlIDJcbiAgICAgICAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICAgICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHYzID0gdDtcbiAgICAgICAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICAgICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHYyID0gdDtcbiAgICAgICAgICAgIHQgPSAodjQgKiBkY3RTaW4zICsgdjcgKiBkY3RDb3MzICsgMjA0OCkgPj4gMTI7XG4gICAgICAgICAgICB2NCA9ICh2NCAqIGRjdENvczMgLSB2NyAqIGRjdFNpbjMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgICAgIHY3ID0gdDtcbiAgICAgICAgICAgIHQgPSAodjUgKiBkY3RTaW4xICsgdjYgKiBkY3RDb3MxICsgMjA0OCkgPj4gMTI7XG4gICAgICAgICAgICB2NSA9ICh2NSAqIGRjdENvczEgLSB2NiAqIGRjdFNpbjEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgICAgIHY2ID0gdDtcblxuICAgICAgICAgICAgLy8gc3RhZ2UgMVxuICAgICAgICAgICAgcFswKjggKyBjb2xdID0gdjAgKyB2NztcbiAgICAgICAgICAgIHBbNyo4ICsgY29sXSA9IHYwIC0gdjc7XG4gICAgICAgICAgICBwWzEqOCArIGNvbF0gPSB2MSArIHY2O1xuICAgICAgICAgICAgcFs2KjggKyBjb2xdID0gdjEgLSB2NjtcbiAgICAgICAgICAgIHBbMio4ICsgY29sXSA9IHYyICsgdjU7XG4gICAgICAgICAgICBwWzUqOCArIGNvbF0gPSB2MiAtIHY1O1xuICAgICAgICAgICAgcFszKjggKyBjb2xdID0gdjMgKyB2NDtcbiAgICAgICAgICAgIHBbNCo4ICsgY29sXSA9IHYzIC0gdjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRvIDgtYml0IGludGVnZXJzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBibG9ja0J1ZmZlck9mZnNldCArIGk7XG4gICAgICAgICAgICB2YXIgcSA9IHBbaV07XG4gICAgICAgICAgICBxID0gKHEgPD0gLTIwNTYpID8gMCA6IChxID49IDIwMjQpID8gMjU1IDogKHEgKyAyMDU2KSA+PiA0O1xuICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtpbmRleF0gPSBxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xuICAgICAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lIDw8IDM7XG4gICAgICAgIHZhciBjb21wdXRhdGlvbkJ1ZmZlciA9IG5ldyBJbnQzMkFycmF5KDY0KTtcblxuICAgICAgICB2YXIgaSwgaiwgbGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbClcbiAgICAgICAgICAgICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LCBvZmZzZXQsIGNvbXB1dGF0aW9uQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50LmJsb2NrRGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcFRvVWludDgoYSkge1xuICAgICAgICByZXR1cm4gYSA8PSAwID8gMCA6IGEgPj0gMjU1ID8gMjU1IDogYSB8IDA7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlID0ge1xuICAgICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBjYXRjaCBwYXJzZSBlcnJvclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlIHx8IHhoci5tb3pSZXNwb25zZUFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubG9hZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmxvYWQoKTtcbiAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkRnJvbUJ1ZmZlcjogZnVuY3Rpb24gbG9hZEZyb21CdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25sb2FkKVxuICAgICAgICAgICAgICAgIHRoaXMub25sb2FkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVhZFVpbnQxNigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWREYXRhQmxvY2soKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1jdXNQZXJMaW5lID0gTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCAvIGZyYW1lLm1heEgpO1xuICAgICAgICAgICAgICAgIHZhciBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBmcmFtZS5tYXhWKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCkgKiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zY2FuTGluZXMgIC8gOCkgKiBjb21wb25lbnQudiAvIGZyYW1lLm1heFYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgPSBtY3VzUGVyQ29sdW1uICogY29tcG9uZW50LnY7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2Nrc0J1ZmZlclNpemUgPSA2NCAqIGJsb2Nrc1BlckNvbHVtbkZvck1jdVxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoYmxvY2tzUGVyTGluZUZvck1jdSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhID0gbmV3IEludDE2QXJyYXkoYmxvY2tzQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lID0gYmxvY2tzUGVyTGluZTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbiA9IGJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGpmaWYgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGFkb2JlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBwaXhlbHMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGZyYW1lLCByZXNldEludGVydmFsO1xuICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGh1ZmZtYW5UYWJsZXNBQyA9IFtdLCBodWZmbWFuVGFibGVzREMgPSBbXTtcbiAgICAgICAgICAgIHZhciBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgIT0gMHhGRkQ4KSB7IC8vIFNPSSAoU3RhcnQgb2YgSW1hZ2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJTT0kgbm90IGZvdW5kXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICB3aGlsZSAoZmlsZU1hcmtlciAhPSAweEZGRDkpIHsgLy8gRU9JIChFbmQgb2YgaW1hZ2UpXG4gICAgICAgICAgICAgICAgdmFyIGksIGosIGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoKGZpbGVNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweEZGRTA6IC8vIEFQUDAgKEFwcGxpY2F0aW9uIFNwZWNpZmljKVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMTogLy8gQVBQMVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMjogLy8gQVBQMlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFMzogLy8gQVBQM1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNDogLy8gQVBQNFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNTogLy8gQVBQNVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNjogLy8gQVBQNlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFNzogLy8gQVBQN1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFODogLy8gQVBQOFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFOTogLy8gQVBQOVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFQTogLy8gQVBQMTBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweEZGRUI6IC8vIEFQUDExXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVDOiAvLyBBUFAxMlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZFRDogLy8gQVBQMTNcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweEZGRUU6IC8vIEFQUDE0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVGOiAvLyBBUFAxNVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZGRTogLy8gQ09NIChDb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwcERhdGEgPSByZWFkRGF0YUJsb2NrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0QSAmJiBhcHBEYXRhWzFdID09PSAweDQ2ICYmIGFwcERhdGFbMl0gPT09IDB4NDkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzRdID09PSAwKSB7IC8vICdKRklGXFx4MDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpmaWYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB7IG1ham9yOiBhcHBEYXRhWzVdLCBtaW5vcjogYXBwRGF0YVs2XSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2l0eVVuaXRzOiBhcHBEYXRhWzddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlEZW5zaXR5OiAoYXBwRGF0YVsxMF0gPDwgOCkgfCBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iV2lkdGg6IGFwcERhdGFbMTJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJEYXRhOiBhcHBEYXRhLnN1YmFycmF5KDE0LCAxNCArIDMgKiBhcHBEYXRhWzEyXSAqIGFwcERhdGFbMTNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQVBQMSAtIEV4aWZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVszXSA9PT0gMHg2MiAmJiBhcHBEYXRhWzRdID09PSAweDY1ICYmIGFwcERhdGFbNV0gPT09IDApIHsgLy8gJ0Fkb2JlXFx4MDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb2JlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogYXBwRGF0YVs2XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzMDogKGFwcERhdGFbN10gPDwgOCkgfCBhcHBEYXRhWzhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MxOiAoYXBwRGF0YVs5XSA8PCA4KSB8IGFwcERhdGFbMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQ29kZTogYXBwRGF0YVsxMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZEQjogLy8gRFFUIChEZWZpbmUgUXVhbnRpemF0aW9uIFRhYmxlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDEpIHsgLy8xNiBiaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZXNbcXVhbnRpemF0aW9uVGFibGVTcGVjICYgMTVdID0gdGFibGVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweEZGQzA6IC8vIFNPRjAgKFN0YXJ0IG9mIEZyYW1lLCBCYXNlbGluZSBEQ1QpXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGRkMxOiAvLyBTT0YxIChTdGFydCBvZiBGcmFtZSwgRXh0ZW5kZWQgRENUKVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZDMjogLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiT25seSBzaW5nbGUgZnJhbWUgSlBFR3Mgc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5leHRlbmRlZCA9IChmaWxlTWFya2VyID09PSAweEZGQzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUucHJvZ3Jlc3NpdmUgPSAoZmlsZU1hcmtlciA9PT0gMHhGRkMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnByZWNpc2lvbiA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuc2NhbkxpbmVzID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuc2FtcGxlc1BlckxpbmUgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRJZHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXSwgY29tcG9uZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4SCA9IDAsIG1heFYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBkYXRhW29mZnNldCArIDFdICYgMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heEggPCBoKSBtYXhIID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4ViA8IHYpIG1heFYgPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxSWQgPSBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gZnJhbWUuY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjogdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpemF0aW9uVGFibGU6IHF1YW50aXphdGlvblRhYmxlc1txSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50SWRzW2NvbXBvbmVudElkXSA9IGwgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5tYXhWID0gbWF4VjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGRkM0OiAvLyBESFQgKERlZmluZSBIdWZmbWFuIFRhYmxlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodWZmbWFuTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMjsgaSA8IGh1ZmZtYW5MZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh1ZmZtYW5UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZUxlbmd0aHMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhTdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrLCBvZmZzZXQrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUxlbmd0aFN1bSArPSAoY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1ZmZtYW5WYWx1ZXNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxNyArIGNvZGVMZW5ndGhTdW07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCkgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodWZmbWFuVGFibGVzREMgOiBodWZmbWFuVGFibGVzQUMpW2h1ZmZtYW5UYWJsZVNwZWMgJiAxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RkZERDogLy8gRFJJIChEZWZpbmUgUmVzdGFydCBJbnRlcnZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRJbnRlcnZhbCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGRkRBOiAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nhbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvcnNDb3VudCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXSwgY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9yc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SW5kZXggPSBmcmFtZS5jb21wb25lbnRJZHNbZGF0YVtvZmZzZXQrK11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSBodWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyA9IGh1ZmZtYW5UYWJsZXNBQ1t0YWJsZVNwZWMgJiAxNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BlY3RyYWxTdGFydCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwZWN0cmFsRW5kID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSBkZWNvZGVTY2FuKGRhdGEsIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCAtIDNdID09IDB4RkYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCAtIDJdID49IDB4QzAgJiYgZGF0YVtvZmZzZXQgLSAyXSA8PSAweEZFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgYmUgaW5jb3JyZWN0IGVuY29kaW5nIC0tIGxhc3QgMHhGRiBieXRlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsb2NrIHdhcyBlYXRlbiBieSB0aGUgZW5jb2RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJ1bmtub3duIEpQRUcgbWFya2VyIFwiICsgZmlsZU1hcmtlci50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuc2NhbkxpbmVzO1xuICAgICAgICAgICAgdGhpcy5qZmlmID0gamZpZjtcbiAgICAgICAgICAgIHRoaXMuYWRvYmUgPSBhZG9iZTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVYOiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxuICAgICAgICAgICAgICAgICAgICBibG9ja3NQZXJMaW5lOiBjb21wb25lbnQuYmxvY2tzUGVyTGluZSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzUGVyQ29sdW1uOiBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YShpbWFnZURhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSB0aGlzLndpZHRoIC8gd2lkdGgsIHNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50LCBjb21wb25lbnRTY2FsZVgsIGNvbXBvbmVudFNjYWxlWTtcbiAgICAgICAgICAgIHZhciB4LCB5LCBpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgWSwgQ2IsIENyLCBLLCBDLCBNLCBZZSwgUiwgRywgQjtcbiAgICAgICAgICAgIHZhciBjb2xvclRyYW5zZm9ybTtcbiAgICAgICAgICAgIHZhciBudW1Db21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiBudW1Db21wb25lbnRzO1xuICAgICAgICAgICAgLy92YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRMaW5lO1xuXG4gICAgICAgICAgICAvLyBsaW5lRGF0YSBpcyByZXVzZWQgZm9yIGFsbCBjb21wb25lbnRzLiBBc3N1bWUgZmlyc3QgY29tcG9uZW50IGlzXG4gICAgICAgICAgICAvLyB0aGUgYmlnZ2VzdFxuICAgICAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoKHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lIDw8IDMpICpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uICogOCk7XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnN0cnVjdCBpbWFnZSBkYXRhIC4uLlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUNvbXBvbmVudHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tpIDwgMyA/IDIgLSBpIDogaV07XG4gICAgICAgICAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgICAgICAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lIDw8IDM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaiwgaywgbGwgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FuTGluZSA9IGJsb2NrUm93IDw8IDM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAoc2NhbkxpbmUgKyBqKSAqIHNhbXBsZXNQZXJMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZURhdGFbbGluZU9mZnNldCArIHNhbXBsZSArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vdXRwdXRbYnVmZmVyT2Zmc2V0ICsgb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudC5zY2FsZVggKiBzY2FsZVg7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50LnNjYWxlWSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN4LCBjeTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9IDAgfCAoeSAqIGNvbXBvbmVudFNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9IDAgfCAoeCAqIGNvbXBvbmVudFNjYWxlWCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGN5ICogc2FtcGxlc1BlckxpbmUgKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGxpbmVEYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBudW1Db21wb25lbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLypcbiAgICAgICAgICAgLy8gLi4uIHRoZW4gdHJhbnNmb3JtIGNvbG9ycywgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgIHN3aXRjaCAobnVtQ29tcG9uZW50cykge1xuICAgICAgICAgICBjYXNlIDE6IGNhc2UgMjogYnJlYWs7XG4gICAgICAgICAgIC8vIG5vIGNvbG9yIGNvbnZlcnNpb24gZm9yIG9uZSBvciB0d28gY29tcG9lbmVudHNcblxuICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHRyYW5zZm9ybSBmb3IgdGhyZWUgY29tcG9uZW50cyBpcyB0cnVlXG4gICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgLy8gVGhlIGFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgb3ZlcnJpZGVzIGFueSBwcmV2aW91cyBzZXR0aW5nXG4gICAgICAgICAgIGlmICh0aGlzLmFkb2JlICYmIHRoaXMuYWRvYmUudHJhbnNmb3JtQ29kZSlcbiAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb2xvclRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xuXG4gICAgICAgICAgIGlmIChjb2xvclRyYW5zZm9ybSkge1xuICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XG4gICAgICAgICAgIFkgID0gZGF0YVtpICAgIF07XG4gICAgICAgICAgIENiID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgIENyID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgICAgUiA9IGNsYW1wVG9VaW50OChZIC0gMTc5LjQ1NiArIDEuNDAyICogQ3IpO1xuICAgICAgICAgICBHID0gY2xhbXBUb1VpbnQ4KFkgKyAxMzUuNDU5IC0gMC4zNDQgKiBDYiAtIDAuNzE0ICogQ3IpO1xuICAgICAgICAgICBCID0gY2xhbXBUb1VpbnQ4KFkgLSAyMjYuODE2ICsgMS43NzIgKiBDYik7XG5cbiAgICAgICAgICAgZGF0YVtpICAgIF0gPSBSO1xuICAgICAgICAgICBkYXRhW2kgKyAxXSA9IEc7XG4gICAgICAgICAgIGRhdGFbaSArIDJdID0gQjtcbiAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29sb3JUcmFuc2Zvcm0pO1xuICAgICAgICAgICBpZiAoIXRoaXMuYWRvYmUpXG4gICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlICg0IGNvbXBvbmVudHMpJztcbiAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdHJhbnNmb3JtIGZvciBmb3VyIGNvbXBvbmVudHMgaXMgZmFsc2VcbiAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgLy8gVGhlIGFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgb3ZlcnJpZGVzIGFueSBwcmV2aW91cyBzZXR0aW5nXG4gICAgICAgICAgIGlmICh0aGlzLmFkb2JlICYmIHRoaXMuYWRvYmUudHJhbnNmb3JtQ29kZSlcbiAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb2xvclRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xuXG4gICAgICAgICAgIGlmIChjb2xvclRyYW5zZm9ybSkge1xuICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XG4gICAgICAgICAgIFkgID0gZGF0YVtpXTtcbiAgICAgICAgICAgQ2IgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgQ3IgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICAgICBDID0gY2xhbXBUb1VpbnQ4KDQzNC40NTYgLSBZIC0gMS40MDIgKiBDcik7XG4gICAgICAgICAgIE0gPSBjbGFtcFRvVWludDgoMTE5LjU0MSAtIFkgKyAwLjM0NCAqIENiICsgMC43MTQgKiBDcik7XG4gICAgICAgICAgIFkgPSBjbGFtcFRvVWludDgoNDgxLjgxNiAtIFkgLSAxLjc3MiAqIENiKTtcblxuICAgICAgICAgICBkYXRhW2kgICAgXSA9IEM7XG4gICAgICAgICAgIGRhdGFbaSArIDFdID0gTTtcbiAgICAgICAgICAgZGF0YVtpICsgMl0gPSBZO1xuICAgICAgICAgICAvLyBLIGlzIHVuY2hhbmdlZFxuICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgIHRocm93ICdVbnN1cHBvcnRlZCBjb2xvciBtb2RlJztcbiAgICAgICAgICAgfVxuICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGNvcHlUb0ltYWdlRGF0YTogZnVuY3Rpb24gY29weVRvSW1hZ2VEYXRhKGltYWdlRGF0YSkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLCBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGltYWdlRGF0YUJ5dGVzID0gd2lkdGggKiBoZWlnaHQgKiA0O1xuICAgICAgICAgICAgdmFyIGltYWdlRGF0YUFycmF5ID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBpID0gMCwgaiA9IDAsIGswLCBrMTtcbiAgICAgICAgICAgIHZhciBZLCBLLCBDLCBNLCBSLCBHLCBCO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGltYWdlRGF0YUJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBZID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSBZO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBpbWFnZURhdGFCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEcgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBCID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSBHO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IEI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBpbWFnZURhdGFCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBZID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSyA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgazAgPSAyNTUgLSBLO1xuICAgICAgICAgICAgICAgICAgICAgICAgazEgPSBrMCAvIDI1NTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBSID0gY2xhbXBUb1VpbnQ4KGswIC0gQyAqIGsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEcgPSBjbGFtcFRvVWludDgoazAgLSBNICogazEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQiA9IGNsYW1wVG9VaW50OChrMCAtIFkgKiBrMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSBSO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhQXJyYXlbaisrXSA9IEc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFBcnJheVtqKytdID0gQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YUFycmF5W2orK10gPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVjb2RlIChkYXRhKSB7XG4gICAgY29uc3QganBlZ0ltYWdlID0gbmV3IEpwZWdJbWFnZSgpO1xuXG4gICAganBlZ0ltYWdlLmxvYWRGcm9tQnVmZmVyKGRhdGEpO1xuXG4gICAgdmFyIGltYWdlRGF0YTtcbiAgICBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShqcGVnSW1hZ2Uud2lkdGgsIGpwZWdJbWFnZS5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlRGF0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBqcGVnSW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGpwZWdJbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoanBlZ0ltYWdlLndpZHRoICoganBlZ0ltYWdlLmhlaWdodCAqIDQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGpwZWdJbWFnZS5nZXREYXRhKGltYWdlRGF0YSwganBlZ0ltYWdlLndpZHRoLCBqcGVnSW1hZ2UuaGVpZ2h0KTtcblxuICAgIHJldHVybiBpbWFnZURhdGE7XG59O1xuIl19
